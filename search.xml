<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>串口通信协议-UART、SPI、I2C</title>
      <link href="/2024/031321104.html"/>
      <url>/2024/031321104.html</url>
      
        <content type="html"><![CDATA[<p>未完待续~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AES加解密算法IP</title>
      <link href="/2024/031353724.html"/>
      <url>/2024/031353724.html</url>
      
        <content type="html"><![CDATA[<h2 id="加密算法概念"><a href="#加密算法概念" class="headerlink" title="加密算法概念"></a>加密算法概念</h2><p>一个密码系统的加密密钥和解密密钥相同，或者虽然不相同但是由其中的任意一个可以很容易地推导出另一个，则称该密码系统采用的是对称密码体制。优点是 <strong>加解密速度快</strong>，安全系数不高。AES是对称密钥体制算法。</p><p>如果一个密码系统的加密密钥和解密密钥不同，并且由加密密钥推导出解密密钥(或者由解密密钥推导出加密密钥)是计算上不可行的，则称该密码系统采用的是非对称密码体制。采用非对称密码体制的每个用户都有一对选定的密钥，其中一个是可以公开的，一个由用户自己秘密保存。RSA是非对称加密算法的一种。优点是安全系数高，可以方便、安全的实现数字签名和验证。</p><h4 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h4><p>AES算法是作用在有限域（2^8）,该域中的元素是由8bit组成的字节。它们可以通过异或做加法运算，也可以通过某种方式做乘法运算，而且每一个字节都有逆元。</p><p>密钥长度为128比特。字节（8bits）是AES算法中数据运算的基本单位。AES加密算法由三部分组成：初始密钥加、Nr-1轮循环加密和最后一轮加密。每一轮都有一个由初始密钥生成的轮密钥。</p><ul><li><p>有限域中的加法运算<br>相当于对两个字节做按位异或。</p></li><li><p>有限域中的乘法运算<br>相乘的结果为两个多项式的模乘，AES中不可约多项式(模)为 x^8+x^4+x^3+x+1</p></li><li><p>有限域的X乘运算<br>x（十六进制{02}）乘b(x)可以先对b(x)在字节内左移一位（最后一位补0）；如果b7&#x3D;1，再与十六进制数{1b}做逐比特异或来实现。该运算记为b&#x3D;xtime(x)。</p></li><li><p>四字节运算</p></li></ul><img src="/2024/031353724/image-20240316162412992.png" alt="image-20240316162412992" style="zoom:45%;"><p>AES算法的具体操作是在状态矩阵上进行的。对于128bit的数据，状态矩阵共有4行，32列。每行有4个字节。除了初始密钥（种子密钥），还需要10个轮密钥。</p><p>加密时，将输入字节按照a00，a10，a20，a30；a0,1，a1,1，a2,1，a3,1…的顺序映射到状态矩阵上，加密的最后以同样的顺序提取状态矩阵从而得到输出字节。</p><p>AES加密算法由三部分组成，初始密钥加、Nr-1轮循环加密和最后一轮加密，采用轮迭代结构由四个不同的变换组成。加密过程的四个变换分别为：字节变换（S盒变换）、行移位变换、列混合变换和轮密钥加变换。整个加解密过程如下：</p><img src="/2024/031353724/image-20240316162831828.png" alt="image-20240316162831828" style="zoom:50%;"><ul><li>S盒变换 SubBytes</li></ul><p>​字节替代变换，针对字节的非线性、可逆变换。一个向量乘以一个可逆矩阵，得到输出。它将状态中的每一个字节进行非线性变换为另外一个字节。可以将所有的字节变换排成一个表格，查表直接得到输出。提高速度，减小了矩阵的运算。</p><img src="/2024/031353724/1710436556338.jpg" alt="1710436556338" style="zoom:50%;"><ul><li>行移位变换</li></ul><p>​循环移位。对于128bit的加密，第一行不移动，第二行移动1个字节，第三行移动2个字节，第三行移动3个字节。对于加密，循环左移。解密，后3行依次右循环移动3，2，1个字节。</p><img src="/2024/031353724/image-20240315092725268.png" alt="image-20240315092725268" style="zoom: 50%;"><ul><li>列混合变换</li></ul><img src="/2024/031353724/image-20240315093320194.png" alt="image-20240315093320194" style="zoom:50%;"><img src="/2024/031353724/image-20240315093334980.png" alt="image-20240315093334980" style="zoom:50%;"><p>​解密与加密类似，固定多项式变为拟矩阵，表示如下。</p><img src="/2024/031353724/image-20240316163552550.png" alt="image-20240316163552550" style="zoom:50%;"><ul><li><p>轮密钥加变换</p><p>将状态矩阵与轮密钥进行逐位比特异或操作。</p></li></ul><h4 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h4><p>初始密钥K，共产生4*（Nr+1）个双字。最终的密钥流程产生一个四字节双字的线性数组。{w0,w1,w2,w3}是初始密钥，其中，w0对应的bit[127:96]。</p><p><img src="/2024/031353724/image-20240316163738922.png" alt="image-20240316163738922"></p><ul><li>位置变换</li></ul><p>​将4字节的输入序列，循环左移一个字节输出。</p><ul><li>S盒变换</li></ul><p>​将一个4字节的输入序列的每个字节进行S盒变换输出。</p><ul><li>常量变换</li></ul><p>​Rcon[]是一个具有10个元素的常量数组，x0&#x3D;{01},x1&#x3D;{02},…….x(8)&#x3D;{1b},x(9)&#x3D;{36}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DC_FLOW（二）</title>
      <link href="/2024/03097089.html"/>
      <url>/2024/03097089.html</url>
      
        <content type="html"><![CDATA[<h3 id="异步时钟相关设置"><a href="#异步时钟相关设置" class="headerlink" title="异步时钟相关设置"></a>异步时钟相关设置</h3><h4 id="set-group-path"><a href="#set-group-path" class="headerlink" title="set_group_path"></a>set_group_path</h4><p>用来声明不同clock组之间的关系，比如两个异步时钟不需要做时序分析，需要<code>-asynchronous</code>指定。不同于<code>set_group_path</code>，它是对于所有的path做一个分组。</p><img src="/2024/03097089/image-20240309163503401.png" alt="image-20240309163503401" style="zoom: 67%;"><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_clock_group <span class="token operator">-</span>asynchronous <span class="token operator">-</span>group C1 <span class="token operator">-</span>group C2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>如果一个电路中有两个clock，有一个选择信号控制两个clock输出，这两个时钟在逻辑上是互斥的，需要声明<code>logically_exclusive</code></li></ol><p><img src="/2024/03097089/image-20240309165524200.png" alt="image-20240309165524200"></p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">create_clock <span class="token operator">-</span>period 10 <span class="token operator">-</span>name C1 <span class="token punctuation">[</span>get_ports C1<span class="token punctuation">]</span>create_clock <span class="token operator">-</span>period 20 <span class="token operator">-</span>name C2 <span class="token punctuation">[</span>get_ports C2<span class="token punctuation">]</span>set_clock_group <span class="token operator">-</span>logically_exclusive <span class="token operator">-</span>group C1 <span class="token operator">-</span>group C2<span class="token comment"># 如果不声明 -logically_exclusive  DC会认为有4中可能，CLK1 产生数据 CLK1 去采样，CLK1 产生数据 CLK2 去采样，CLK2 产生数据 CLK1 去采样，CLK2 产生数据 CLK2 去采样。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>如果一个net或者port上又可能存在两个时钟，需要对该net声明physical exclusive</li></ol><img src="/2024/03097089/image-20240309171004892.png" alt="image-20240309171004892" style="zoom:67%;"><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">create_generated_clock <span class="token operator">-</span>name GC1 <span class="token operator">-</span>divide_by 1 <span class="token operator">-</span>souce <span class="token punctuation">[</span>get_pins mux1<span class="token operator">/</span>A<span class="token punctuation">]</span>  \<span class="token punctuation">[</span>get_pins mux1<span class="token operator">/</span>Z<span class="token punctuation">]</span>create_generated_clock <span class="token operator">-</span>name GC2 <span class="token operator">-</span>divide_by 1 <span class="token operator">-</span>souce <span class="token punctuation">[</span>get_pins mux1<span class="token operator">/</span>B<span class="token punctuation">]</span>  \<span class="token punctuation">[</span>get_pins mux1<span class="token operator">/</span>Z<span class="token punctuation">]</span>set_clock_group <span class="token operator">-</span>physically_exclusive <span class="token operator">-</span>group C1 <span class="token operator">-</span>group C2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>总结</li></ul><p>如果两个时钟经过一个mux输出，对这两个输入时钟需要声明<code>logically exclusive</code>。输出的时钟在物理上是唯一的，需要声明<code>physically exclusive</code>。</p><img src="/2024/03097089/image-20240309172447158.png" alt="image-20240309172447158" style="zoom: 33%;"><h4 id="create-generated-clock"><a href="#create-generated-clock" class="headerlink" title="create generated clock"></a>create generated clock</h4><p>明确generated clock和master clock的关系，</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">create_generated_clock <span class="token punctuation">[</span><span class="token operator">-</span>name clock_name<span class="token punctuation">]</span> \    <span class="token operator">-</span>source master_pin \    <span class="token punctuation">[</span><span class="token operator">-</span>master_clock clock<span class="token punctuation">]</span> \    <span class="token punctuation">[</span><span class="token operator">-</span>edge edge_list<span class="token punctuation">]</span> \    <span class="token punctuation">[</span><span class="token operator">-</span>edge_shift shift_list<span class="token punctuation">]</span> \    <span class="token punctuation">[</span><span class="token operator">-</span>divide_by factor<span class="token punctuation">]</span> \    <span class="token punctuation">[</span><span class="token operator">-</span>multiply_by factor<span class="token punctuation">]</span> \    <span class="token punctuation">[</span><span class="token operator">-</span>duty_cycle percent<span class="token punctuation">]</span> \    <span class="token punctuation">[</span><span class="token operator">-</span>combinational<span class="token punctuation">]</span>    <span class="token punctuation">[</span><span class="token operator">-</span>invert<span class="token punctuation">]</span> \    <span class="token punctuation">[</span><span class="token operator">-</span>add<span class="token punctuation">]</span> \source_objects<span class="token comment"># -master_clock clock</span><span class="token comment"># -source 指明master clock的pin(-source 指的是master clock上的出来的pin，可以有多个source pin)</span><span class="token comment"># cts时，默认会减小master clock和generated clock的skew，计算generated clock的clock的latency时会加上这个skew</span><span class="token comment"># -divide_by 指明几分频</span><span class="token comment"># -edges 指明generated_clock一个完整的时钟周期，上升，下降，上升沿的时间点</span><span class="token comment"># -edge_shift&#123;1 1 1&#125; 表示每个沿都往后延迟多少</span><span class="token comment"># -preinvert 基于inverted的master clk</span><span class="token comment"># -invert    基于non-inverted的master clk后的inverted</span><span class="token comment"># -add 在有时钟定义的引脚上添加时钟，不加会覆盖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/03097089/image-20240309173947008.png" alt="image-20240309173947008"></p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">create_generated_clock <span class="token operator">-</span>source <span class="token punctuation">[</span>get_pins Udiv<span class="token operator">/</span>CLK<span class="token punctuation">]</span> <span class="token operator">-</span>name CLKdiv2 <span class="token operator">-</span>divide_by 2 <span class="token punctuation">[</span>get_pins Udiv<span class="token operator">/</span>Q<span class="token punctuation">]</span>create_generated_clock <span class="token operator">-</span>name CLKdiv2 <span class="token operator">-</span>source CLK <span class="token operator">-</span>edges <span class="token punctuation">&#123;</span>2 4 6<span class="token punctuation">&#125;</span> <span class="token punctuation">[</span>get_pins Udiv<span class="token operator">/</span>Q<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="set-false-path"><a href="#set-false-path" class="headerlink" title="set_false_path"></a>set_false_path</h4><p>有些特殊路径不需要进行时序分析，设置false时，sta不会对其分析。</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_false_path <span class="token operator">-</span>from <span class="token punctuation">[</span>get_clocks CKA<span class="token punctuation">]</span> <span class="token operator">-</span>to <span class="token punctuation">[</span>get_clocks CKB<span class="token punctuation">]</span> <span class="token operator">-</span>through <span class="token punctuation">[</span>get_ports OUT<span class="token punctuation">]</span>set_false_path <span class="token operator">-</span>from <span class="token punctuation">[</span>get_clocks CKB<span class="token punctuation">]</span> <span class="token operator">-</span>to <span class="token punctuation">[</span>get_clocks CKA<span class="token punctuation">]</span> <span class="token operator">-</span>through <span class="token punctuation">[</span>get_ports OUT<span class="token punctuation">]</span>set_false_path <span class="token punctuation">[</span><span class="token operator">-</span>from from_list<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>through through_list<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>to to_list<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span>from from_list<span class="token punctuation">]</span> <span class="token comment"># 包括CK, INPUT PORT, INOUT PORT</span><span class="token punctuation">[</span><span class="token operator">-</span>to to_list<span class="token punctuation">]</span>     <span class="token comment"># 包括output port，sequential cell的D，inout port</span><span class="token punctuation">[</span><span class="token operator">-</span>through through_list<span class="token punctuation">]</span> <span class="token comment"># 包括pin，ports，cells，nets</span><span class="token comment"># 包含form 或者 to 或者 through的path 都是false path</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="multi-cycle-path"><a href="#multi-cycle-path" class="headerlink" title="multi-cycle-path"></a>multi-cycle-path</h4><p>多周期设计。适应场景：设计时加入移位寄存器来做使能信号。</p><img src="/2024/03097089/image-20240309214325529.png" alt="image-20240309214325529" style="zoom: 67%;"><img src="/2024/03097089/image-20240309214654478.png" alt="image-20240309214654478" style="zoom: 67%;"><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_multicycle_path <span class="token operator">-</span>setup 6 <span class="token operator">-</span>from CLK1 <span class="token operator">-</span>to CLK2 <span class="token operator">-</span>end <span class="token comment"># 允许6个时钟周期后采样数据</span>set_multicycle_path <span class="token operator">-</span>hold 5 <span class="token operator">-</span>from CLK1 <span class="token operator">-</span>to CLK2  <span class="token operator">-</span>end <span class="token comment"># hold检查要提前5个时钟沿，需要和发射沿对齐。hold检查本身就要早于setup检查一个周期。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>慢时钟到快时钟</li></ul><p><img src="/2024/03097089/image-20240309215949714.png" alt="image-20240309215949714"></p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_multicycle_path <span class="token operator">-</span>from CLK1 <span class="token operator">-</span>to CLK2 <span class="token operator">-</span>setup 3 <span class="token operator">-</span>endset_multicycle_path <span class="token operator">-</span>from CLK1 <span class="token operator">-</span>to CLK2 <span class="token operator">-</span>hold 2 <span class="token operator">-</span>end<span class="token operator">-</span>end 以捕获时钟为基准，移动的是capture clock，<span class="token operator">-</span>setup向右移，<span class="token operator">-</span>hold向左移<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>快时钟到慢时钟</li></ul><p><img src="/2024/03097089/20210313202848917.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_multicycle_path <span class="token operator">-</span>from CLK1 <span class="token operator">-</span>to CLK2 <span class="token operator">-</span>setup 3 <span class="token operator">-</span>start <span class="token comment"># 挪动到第3个周期</span>set_multicycle_path <span class="token operator">-</span>from CLK1 <span class="token operator">-</span>to CLK2 <span class="token operator">-</span>hold 2 <span class="token operator">-</span>start  <span class="token comment"># 向右挪动了2个周期</span><span class="token comment"># -start以发射时钟为基准，移动的是launch clock，-setup向左移，-hold向右移 </span><span class="token comment"># 注意setup和hold检查的位置，都是按照最严格的检查，在发射路径上，hold要比setup晚一个周期。且hold检查的位置为0，setup为1；</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="half-cycle-path"><a href="#half-cycle-path" class="headerlink" title="half cycle path"></a>half cycle path</h4><p>如果在设计中，同时存在上升沿触发的D触发器，以及下降沿触发的D触发器，则视为半周期路径</p><img src="/2024/03097089/image-20240309221504902.png" alt="image-20240309221504902" style="zoom:67%;"><img src="/2024/03097089/image-20240309221510712.png" alt="image-20240309221510712" style="zoom:67%;"><p>hold time 时序很容易满足。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>低功耗方法学（二）</title>
      <link href="/2024/030658141.html"/>
      <url>/2024/030658141.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-电源门控概述（power-gating）"><a href="#4-电源门控概述（power-gating）" class="headerlink" title="4 电源门控概述（power gating）"></a>4 电源门控概述（power gating）</h2><p>为了减少芯片的总泄漏功耗，非常希望添加关闭未使用的模块的机制，这种技术称为电源门控 <strong>power gating</strong></p><h3 id="4-1-动态功耗和泄漏功耗分布"><a href="#4-1-动态功耗和泄漏功耗分布" class="headerlink" title="4.1 动态功耗和泄漏功耗分布"></a>4.1 动态功耗和泄漏功耗分布</h3><p>电源门控的基本策略是提供两种电源模式：低功率模式和活动模式。目标是在恰当的时间以适当的方式在这些模式中切换，以最大限度的节省功耗，同时最大限度的减少对性能的影响。</p><p>电源门控比时钟门控更有复杂，因为需要模块之间复杂的通信和时间延迟以安全进入和退出电源门控模式。电源门控的控制权可以由软件调度，作为设备驱动程序或操作系统空闲任务的一部分，也可以由电源管理控制器在硬件中启动。需要从以下角度考虑选择哪种控制模式</p><ol><li>可能节省的漏电功耗</li><li>产生进入和退出电源门控模式的时间</li><li>进入和离开这个模式消耗的能量</li><li>模块的活动分布（活动或者睡眠的比例）</li></ol><p><strong>术语</strong></p><p>​SLEEP：进入低功耗模式<br>​WAKE：返回活动模式</p><ul><li><p>通过时钟门控降低功耗</p><img src="/2024/030658141/image-20240306225913409.png" alt="image-20240306225913409" style="zoom: 33%;"></li><li><p>通过电源门控降低功耗</p><p>WAKE时间和时钟运行直接的响应时间很重要，在系统设计层次不能</p><img src="/2024/030658141/1709739346255.jpg" alt="1709739346255" style="zoom:33%;"></li><li><p>电源门控切换速度不彻底（真实情况）</p><img src="/2024/030658141/image-20240306234721173.png" alt="image-20240306234721173" style="zoom:33%;"></li></ul><h3 id="4-2-电源门控在不同子系统上的影响"><a href="#4-2-电源门控在不同子系统上的影响" class="headerlink" title="4.2 电源门控在不同子系统上的影响"></a>4.2 电源门控在不同子系统上的影响</h3><p>带有缓存的CPU系统通常可能长期处于休眠或者不活动状态，使得电源门控的设计更加具有必要性。需要考虑一下因素：</p><ul><li>电压门控技术可以很好的降低CPU的泄漏功耗</li><li>如果每次CPU断电时缓存内容都丢失，上电时需要重新填充，可能需要花费大量时间和成本</li><li>节省的净能量取决于睡眠和唤醒的活动性。即电源门控节省的能量和重新加载消耗的能量。</li></ul><p>外围子系统受到设备驱动程序和操作系统的电源管理方案控制。需要在唤醒时快速恢复状态以最大限度的节省功耗</p><ul><li>设备驱动程序可能需要显示加载&#x2F;恢复密钥状态或启动硬件定时器控制作为唤醒&#x2F;睡眠的一部分</li><li>更好的方式是外设在睡眠模式时，保存一些状态，但是需要额外的电路和控制。</li></ul><h3 id="4-3-电源门控的设计原理"><a href="#4-3-电源门控的设计原理" class="headerlink" title="4.3 电源门控的设计原理"></a>4.3 电源门控的设计原理</h3><p>使用电源门控的SoC简化视图如下，与时钟通电的模块不同，电源门控功能模块通过电源开关网络接收电源。电源开关网络分布在电源门控功能模块周围。Isol模块放置在电源门控模块和始终开启模块之间，当输入处于阈值电压时，输出电压的过渡状态很短，不会对后面always on模块产生较大影响，起到了隔离的作用。</p><img src="/2024/030658141/image-20240307135341610.png" alt="image-20240307135341610" style="zoom:40%;"><p>对于某些电源门控模块，非常希望在断电时保留模块内部状态，并在通电期间恢复该状态。这种策略在上电期间可以节省大量时间和功耗。实现方式：将保留寄存器替代普通寄存器。</p><p>保持寄存器通常具有比主寄存器慢但是泄漏电流小得多的辅助寄存器或者影子寄存器。影子寄存器始终处于通电状态，并在电源门控期间存储主存储器的内容。该控制信号由电源门控控制器提供。</p><h4 id="4-3-1-电源切换-细粒度和粗粒度"><a href="#4-3-1-电源切换-细粒度和粗粒度" class="headerlink" title="4.3.1 电源切换-细粒度和粗粒度"></a>4.3.1 电源切换-细粒度和粗粒度</h4><p>电源切换一般有两种方法：细粒度电源门控和粗粒度电源门控</p><p>在细粒度电源切换门控中，开关放置在库中每个标准单元中，由于开关必须提供电源所需要的最坏情况电流，因此必须相当大，以免影响性能。每个单元的面积开销很大（通常是原始单元大小的2到4倍）。下面是带上拉的细粒度与门。</p><img src="/2024/030658141/image-20240307144844883.png" alt="image-20240307144844883" style="zoom:50%;"><p>细粒度电源门控的主要优点是，开关上的IR压降的时序影响和钳位器的行为很容易表征，因为他们包含在单元内，可以采用传统的设计方法部署细粒度电源门控。</p><p>在粗粒度电源门控中，一组门级单元通过一组开关单元来切换电源。时序分析困难，但是面积相比细粒度小很多。</p><p>目前，设计中都是使用粗粒度电源门控。任何电源门控的关键挑战是减小涌浪电流，以避免电源网络中出现过多的IR压降。否则，电源门控模块的功能和状态 当进行睡眠&#x2F;复位顺序不同时会被破坏。</p><h4 id="4-3-2-电源门控的挑战"><a href="#4-3-2-电源门控的挑战" class="headerlink" title="4.3.2 电源门控的挑战"></a>4.3.2 电源门控的挑战</h4><ol><li>电源开关结构设计</li><li>电源门控控制器设计</li><li>保持寄存器和隔离寄存器的选择和使用</li><li>最大限度减少电源门控对时序和面积的影响</li><li>接口隔离</li><li>时钟和复位的功能控制</li><li>对每个受支持的电源状态与状态相关的验证</li><li>制造和生产测试策略</li></ol><h2 id="电源门控设计"><a href="#电源门控设计" class="headerlink" title="电源门控设计"></a>电源门控设计</h2><p>带有电源门控的SoC结构，需要解决的问题：开关网络和电源门控控制器的设计、何时何地插入保留寄存器和隔离寄存器。</p><img src="/2024/030658141/image-20240309092347605.png" alt="image-20240309092347605" style="zoom: 67%;"><h3 id="5-1-开关结构设计"><a href="#5-1-开关结构设计" class="headerlink" title="5.1 开关结构设计"></a>5.1 开关结构设计</h3><p>第一种架构是切换VDD还是VSS，或者同时切换。一般采用NMOS传递低电压，PMOS传递高电压，因为没有阈值电压损失。但是这种切换的开关电源会导致较大的IR Drop在电源上，进而影响设计中门的延迟。</p><img src="/2024/030658141/image-20240309094251614.png" alt="image-20240309094251614" style="zoom:50%;"><p>对于Header-Switch结构，当开关关闭时，GATED VDD输出趋近于低电平。对于Footer-Switch 结构，当开关关闭时，GATED VSS输出趋近于高电平。</p><p>注意，在NMOS导通传递低电平，在PMOS导通传输高电平时，无法保证没有电压损失，因为开关有漏电流。<strong>这也是为什么输出需要隔离单元的原因之一</strong></p><p>推荐的方式:</p><ul><li>切换电源或者低，而不是两者都切换，以减小IR drop。</li><li>在设计前期决定是Header-Switch还是GATED VDD更适合系统设计。</li><li>Header-Switch更适合外部电源门控</li><li>Header-Switch适合用在多电压或者电压调节技术中</li></ul><p>缺点：</p><p>Footer-Switch电源门控与外部开关电源或者多个电源混用时，会导致整个设计的功耗、时序和功能变得复杂，对标准单元库提出了更复杂的要求。</p><h4 id="5-1-1-控制开关网络"><a href="#5-1-1-控制开关网络" class="headerlink" title="5.1.1 控制开关网络"></a>5.1.1 控制开关网络</h4><p>关键问题在于限制模块电源切换时所产生的涌浪电流，过多的这种电流会导致电源出现电压尖峰，可能损坏常开模块中寄存器以及电源门控模块中的保留寄存器。</p><p>一种代表性降低涌浪电流的方法是将控制信号以链表方式连接到开关，来自电源控制器的控制信号连接到第一个开关，它缓冲（具有适当的延迟）信号并将其发送到下一个开关。</p><p>这种链的结果是，从发出“加电”信号到模块加电需要一些时间。因此，交换结构通常会提供确认信号来指示该结构已完全加电。该信号可以简单地是“加电”控制信号的最终缓冲版本。</p><p>更激进的一种方式是依次使用多个上电控制信号，第一控制信号可以打开一组弱开关或“涓流”开关，这些开关启动加电但限制浪涌电流。然后第二控制信号可以打开主电源开关组。</p><p>无论具体的控制方法如何，在上电序列期间，重要的是要等到交换结构完全上电，然后才能使电源门控块恢复正常操作。该上电序列的时序由电源控制器负责。</p><p>电源开关结构的控制信号（电源开&#x2F;关和确认的整个链）必须由始终开启的缓冲区进行缓冲，而不是由电源门控缓冲区进行缓冲。</p><h4 id="5-1-1-电源门控的建议和陷阱"><a href="#5-1-1-电源门控的建议和陷阱" class="headerlink" title="5.1.1 电源门控的建议和陷阱"></a>5.1.1 电源门控的建议和陷阱</h4><p>建议</p><ul><li>电源控制器需要针对特定的电源门控技术来设计</li><li>应该为电源门控控制端口提供断言，以匹配所选的开关技术，确保RTL设计环境中的功能验证和覆盖率</li><li>电源门控控制信号必须在测试期间可控。</li></ul><p>陷阱</p><ul><li>将外部电源门控和内部电源门控相结合可能会很麻烦，因为在内部的电源在外部电源门控期间可能不会“始终开启”。在这种情况下需要仔细设计和验证。</li></ul><h3 id="5-2-信号隔离"><a href="#5-2-信号隔离" class="headerlink" title="5.2 信号隔离"></a>5.2 信号隔离</h3><p>电源门控模块的每个接口都需要进行管理，确保关闭该电压域不会导致其他模块的任何输入出现涌浪电流。并且需要保证掉电模块的输出浮动不会导致上电模块出现虚假翻转行为。</p><p>电源门控模块的输出是主要的问题，因为它们可能导致其他模块出现电气或者功能问题。输入一般不是问题，因为它们可以通过上电模块驱动为有效逻辑值，不会在断电模块中产生电气或者功能问题。</p><h4 id="5-2-1-信号隔离技术"><a href="#5-2-1-信号隔离技术" class="headerlink" title="5.2.1 信号隔离技术"></a>5.2.1 信号隔离技术</h4><p>控制掉电模块输出的基本方法是使用隔离单元将输出钳位到特定的有效值。</p><p>隔离单元分为三种类型：将信号钳位到0的单元、将信号钳位到1的单元以及将信号锁定存为最近值的隔离单元。</p><p>钳位库单元旨在避免信号输入浮动时出现的涌浪电流和泄漏路径，只要控制输入信号处于合适的状态即可。此外，这些钳位库单元具有特殊的属性，保证在综合时不会因逻辑优化而被优化掉或者优化错误。</p><p>两种隔离单元，与门类型和或门类型</p><img src="/2024/030658141/image-20240310183835490.png" alt="image-20240310183835490" style="zoom: 43%;"><p>注意的是，这些钳位单元对于输入到输出带来了一些延迟，对于关键路径，可能会带来setup违例的影响，比如高速缓存接口。另一种不增加延迟的隔离技术是使用上拉或者下拉晶体管。但是可能会带来多个驱动晶体管，需要仔细设计和排序，避免竞争使用。即使上拉或者下拉晶体管是相对较弱的器件，总数也可能足够大，以至于总线产生的电流过量导致问题。</p><img src="/2024/030658141/image-20240310191620029.png" alt="image-20240310191620029" style="zoom: 43%;"><p>为了避免输出毛刺，在上电期间，需要保证输出隔离。这种隔离效果应该是直接的，对于上拉&#x2F;下拉晶体管来说，可能相当具有挑战性，因为只要这些晶体管在活动状态下重新上电，会出现多点驱动问题，输出不定，产生毛刺。</p><p>尽管上拉&#x2F;下拉钳位隔离单元在面积和时序上有优势，但是由于出现的诸多问题，不建议参与RTL设计。相反，建议使用”门级”单元格式。</p><h4 id="5-2-2-输出和输入隔离"><a href="#5-2-2-输出和输入隔离" class="headerlink" title="5.2.2 输出和输入隔离"></a>5.2.2 输出和输入隔离</h4><p>如上所述，有必要隔离电源门控单元的输出，以避免浮动输出驱动上电模块输入的电气问题。从逻辑上讲，将信号钳位在电源门控模块的输出还是目的模块的输入没有什么区别。</p><p>但是有一些实际考虑因素会影响这一选择。</p><p>电源门控模块的输出至少会流向多个上电模块。如果在上电模块的输入隔离，需要多个隔离单元。因此，在电源门控模块的输出隔离更节省面积。在电源门控模块的输出做隔离，使得分析更加容易。</p><p>但是源头隔离输出的方式，对于布局和布线提出了一些限制。与电源门控模块中的其他门不同，隔离单元必须保证在断电期间保持通电状态，所以需要提供常开的电源线，使得电源布线变得复杂，但是现在EDA工具能够解决这个问题。</p><p>因此，强烈建议输出信号采用源头隔离的方式。</p><h4 id="5-2-3-接口协议和隔离"><a href="#5-2-3-接口协议和隔离" class="headerlink" title="5.2.3 接口协议和隔离"></a>5.2.3 接口协议和隔离</h4><p>设计电源门控模块的接口时，有两个目标：最大程度地减少泄漏电流和避免不必要或不正确的行为。</p><p>无论如何，需要考虑在断电期间，将接口信号钳位到0&#x2F;1带来的影响。钳位到错误的电平，可能会增加漏电流。</p><p>对于Header switched设计方式，建议使用高电平有效，低电平有效复位，将所有信号钳位到0。对于Footer-switched方式，建议高电平有效信号和低电平有效复位，并将所有信号钳位为“0”，此规则有一个可能的例外：如果在接收块的输入处使用传输门。如果使用传输门，我们可能需要钳位为“1”以避免潜路径泄漏。</p><img src="/2024/030658141/image-20240310205621878.png" alt="image-20240310205621878" style="zoom: 33%;"><p>普遍倾向于使用高电平有效和低电平有效复位的原因有两个：这是最常用的设计；对于RTL设计也容易、易于调试</p><p>最后一点：对于复杂的协议，可能需要更复杂的隔离策略：将信号在断电时保持不变。这种方法允许重新启动进程，而不是从复位状态开始。但是这种需要带锁存的隔离单元，并不是所有库中都有该单元。只有在绝对必要时才使用该策略。</p><h3 id="隔离的建议和陷阱"><a href="#隔离的建议和陷阱" class="headerlink" title="隔离的建议和陷阱"></a>隔离的建议和陷阱</h3><p>建议</p><ul><li>隔离电源门控模块的输出</li><li>使用隔离单元而不是上拉或下拉式钳位，除非使用非常专门的接口协议</li><li>确保在隔离控制信号测试期间可以检测到卡在 0 和卡在 1 故障</li></ul><p>缺陷</p><ul><li>确保隔离单元始终处于通电状态</li><li>时钟上的隔离钳位会使时钟树合成和时序收敛变得相当复杂，如果可能，请避免在电源门控模块中生成并在该模块外部使用的时钟。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>总线仲裁算法</title>
      <link href="/2024/030241575.html"/>
      <url>/2024/030241575.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要参考博客如下<br><a href="https://blog.csdn.net/Ocean_Yv/article/details/126496121">https://blog.csdn.net/Ocean_Yv/article/details/126496121</a><br><a href="https://blog.csdn.net/weixin_43698385/article/details/126112076">https://blog.csdn.net/weixin_43698385/article/details/126112076</a></p></blockquote><h2 id="总线仲裁算法"><a href="#总线仲裁算法" class="headerlink" title="总线仲裁算法"></a>总线仲裁算法</h2><h3 id="固定优先级算法"><a href="#固定优先级算法" class="headerlink" title="固定优先级算法"></a>固定优先级算法</h3><p>采用固定的优先级，不同请求信号req完成仲裁后，下次请求信号到来时，仲裁机制按照一样的优先级顺序仲裁，纯组合逻辑就可以完成。可以用优先级或者补码特性来判断 </p><h4 id="if-elseif-case"><a href="#if-elseif-case" class="headerlink" title="if elseif &#x2F; case"></a>if elseif &#x2F; case</h4><p>通常使用有优先级的if elseif else或者带优先级的case完成固定优先级算法的仲裁。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// first way : if elseif else</span><span class="token keyword">module</span> <span class="token function">arbiter_fixed</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>      <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   request<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   grant<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// request[0] has high priority</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>request<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        grant <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>request<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        grant <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>request<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        grant <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>request<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        grant <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        grant <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span class="token comment">// second way : case</span><span class="token keyword">module</span> <span class="token function">arbiter_fixed</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>      <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   request<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   grant<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// request[0] has high priority</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">case</span><span class="token punctuation">(</span><span class="token number">1'b1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        request<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> grant <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>        request<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> grant <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>        request<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> grant <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>        request<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> grant <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>         <span class="token keyword">default</span> <span class="token punctuation">:</span> grant <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照上面的case方式综合出来的语句和if else-if else得到的电路是一样的，都是由固定的优先级</p><h4 id="补码特性"><a href="#补码特性" class="headerlink" title="补码特性"></a>补码特性</h4><p>利用补码的特性，原码和补码相 “<strong>与</strong>”，得到一个独热码，该独热码为1的位置 是 原码从右到左第一个为1的位置；</p><p><strong>补码 &#x3D; 原码 取反 + 1；原码 &#x3D;（补码 - 1）+ 1；</strong></p><p>比如，req &#x3D; 4’b0110，（0110 - 0001）&#x3D; 0101； ~0101 &#x3D; 1010 ；   1010 &amp; 0110 &#x3D; <strong>0010</strong></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// third way : con</span><span class="token keyword">module</span> <span class="token function">arbiter_fixed</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>   <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   request<span class="token punctuation">,</span>    <span class="token keyword">output</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   grant<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> grant <span class="token operator">=</span> request<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>request<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token operator">&#123;</span><span class="token number">3'b0</span><span class="token punctuation">,</span> <span class="token number">1'b1</span><span class="token operator">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="轮询优先级算法"><a href="#轮询优先级算法" class="headerlink" title="轮询优先级算法"></a>轮询优先级算法</h3><p>每次仲裁后，需要改变优先级，也就是说输出不仅与输入有关，还和当前的状态有关。所以只能是时序逻辑。轮询的方式有两种，比如优先级A&gt;B&gt;C&gt;D，如果仲裁授予masterC，优先级可以变为D&gt;A&gt;B&gt;C，也可以变为A&gt;B&gt;D&gt;C，第二种方式优先级变化没有规律，实现起来很复杂，通过采用第一种轮询的方式。</p><p>同样有两种方式可以实现该轮询方式，第一种基于状态机跳转实现，第二种基于优化后补码特性实现</p><h4 id="基于状态机跳转"><a href="#基于状态机跳转" class="headerlink" title="基于状态机跳转"></a>基于状态机跳转</h4><p>仲裁后的优先级排序方式共有4种，每次仲裁结果作为当前状态，根据输入信号req决定下次仲裁结果grant；</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// 伪代码</span>mastera<span class="token punctuation">:</span><span class="token function">case</span><span class="token punctuation">(</span>request_abc<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token number">3'b000</span><span class="token punctuation">:</span>nxt_state <span class="token operator">&lt;=</span> mastera<span class="token punctuation">;</span><span class="token number">3'b001</span><span class="token punctuation">:</span>nxt_state <span class="token operator">&lt;=</span> masterc<span class="token punctuation">;</span><span class="token number">3'b010</span><span class="token punctuation">:</span>nxt_state <span class="token operator">&lt;=</span> masterb<span class="token punctuation">;</span><span class="token number">3'b011</span><span class="token punctuation">:</span>nxt_state <span class="token operator">&lt;=</span> masterb<span class="token punctuation">;</span><span class="token number">3'b100</span><span class="token punctuation">:</span>nxt_state <span class="token operator">&lt;=</span> mastera<span class="token punctuation">;</span><span class="token number">3'b101</span><span class="token punctuation">:</span>nxt_state <span class="token operator">&lt;=</span> masterc<span class="token punctuation">;</span><span class="token number">3'b110</span><span class="token punctuation">:</span>nxt_state <span class="token operator">&lt;=</span> masterb<span class="token punctuation">;</span><span class="token number">3'b111</span><span class="token punctuation">:</span>nxt_state <span class="token operator">&lt;=</span> masterb<span class="token punctuation">;</span><span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基于优化后补码特性实现"><a href="#基于优化后补码特性实现" class="headerlink" title="基于优化后补码特性实现"></a>基于优化后补码特性实现</h4><p>参考上面的思路，补码与原码相 “与”，得到从右到左第一个不为0的位置的独热码；计算原码时，**-1 具有特殊的意义，表示从右第一个数开始，向左寻找，第一个不为0的数，将其转换成独热码。**如果减去的值为上次的grant值，相当于从该位置开始，向左寻找第一个不为0的数，将其转换成独热码。但是会存在一个问题，开始位置的后面是无法遍历到的。因此，采用将两个仲裁优先级拼接，从开始位置向左遍历，一定可以遍历完一个循环。如果请求master在开始位置的后面，仲裁结果位于高4bit中，所以再将结果的高4bit和低4bit进行合并，得到最终结果。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">round_robin_arb</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>   clk         <span class="token punctuation">,</span>    <span class="token keyword">input</span>   rst_n       <span class="token punctuation">,</span>        <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> request<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> grant<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 存储移位后上一次仲裁结果</span>    <span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> last_state<span class="token punctuation">;</span>    <span class="token important">always@</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>            last_state <span class="token operator">&lt;=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>     <span class="token comment">// 默认值，表示最低位的优先级最高</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">|</span>request<span class="token punctuation">)</span>            last_state <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span>grant<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>grant<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>grant<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>grant<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 有仲裁请求，根据上一次的仲裁结果，左移1bit后用于控制新的优先级</span>        <span class="token keyword">else</span>            last_state <span class="token operator">&lt;=</span> last_state<span class="token punctuation">;</span>  <span class="token comment">// 无仲裁请求时，pre_state不更新</span>    <span class="token keyword">end</span>    <span class="token comment">// 如果最左侧几个高优先级主机都为发起仲裁请求，需要从最低位开始轮询。</span>    <span class="token comment">// 此处通过两个request拼接，将右侧低位拼接到左侧，即可实现对低位的判断。</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> grant_ext<span class="token punctuation">;</span>    <span class="token keyword">assign</span> grant_ext <span class="token operator">=</span> <span class="token operator">&#123;</span>request<span class="token punctuation">,</span>request<span class="token operator">&#125;</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">&#123;</span>request<span class="token punctuation">,</span>request<span class="token operator">&#125;</span> <span class="token operator">-</span> last_state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 得到的grant_ext必定为一个独热码，但是置高位可能在代表低位的高4bit中，因此进行求或运算</span>    <span class="token keyword">assign</span> grant <span class="token operator">=</span> grant_ext<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">|</span> grant_ext<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低功耗方法学（一）</title>
      <link href="/2024/030235044.html"/>
      <url>/2024/030235044.html</url>
      
        <content type="html"><![CDATA[<h1 id="低功耗方法学-一"><a href="#低功耗方法学-一" class="headerlink" title="低功耗方法学(一)"></a>低功耗方法学(一)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>参考《Low_Power_Methodology_Manual_for_Soc_Design》，将认为重点的知识点进行记录和总结。</p></blockquote><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><h3 id="1-1-功耗和能量"><a href="#1-1-功耗和能量" class="headerlink" title="1.1 功耗和能量"></a>1.1 功耗和能量</h3><p>​功耗是瞬时能量，能量是一个总和；类似于速度和距离的关系；</p><img src="/2024/030235044/image-20240302005439890.png" style="zoom: 40%;"><h3 id="1-2-动态功耗"><a href="#1-2-动态功耗" class="headerlink" title="1.2 动态功耗"></a>1.2 动态功耗</h3><p>动态功耗有两种，电容充放电功耗和短路电流功耗；</p><img src="/2024/030235044/image-20240303101531073.png" alt="image-20240303101531073" style="zoom: 33%;"><p>第一项是电容充放电功耗，第二项是短路电流功耗，tsc为短路电流持续时间。随着工艺尺寸的降低，静态功耗的占比越来越大，甚至超过动态功耗。</p><p>降低电压会大大降低功耗，但是会导致载流子的速度降低，影响性能。一般SoC设计者，使用以下方式降低功耗。</p><ol><li>多电压技术。不同设备采用不同电压，外围低速设备使用低电压。</li><li>电压缩放技术，动态电压管理技术。一个模块支持多电压工作，在执行繁忙任务时，使用高电压，在执行低性能任务时，使用低电压。</li><li>时钟门控技术，降低信号翻转带来的功耗。</li></ol><h3 id="静态功耗"><a href="#静态功耗" class="headerlink" title="静态功耗"></a>静态功耗</h3><p>​静态功耗是在信号不翻转时的功耗，又称为漏电功耗。来源：栅极漏电、衬底电流和漏极反偏结漏电。</p><img src="/2024/030235044/image-20240303151547141.png" alt style="zoom:33%;"><h2 id="2-标准低功耗方法学"><a href="#2-标准低功耗方法学" class="headerlink" title="2 标准低功耗方法学"></a>2 标准低功耗方法学</h2><h3 id="2-1-时钟门控"><a href="#2-1-时钟门控" class="headerlink" title="2.1 时钟门控"></a>2.1 时钟门控</h3><p>动态功耗中，时钟缓冲器带来的功耗占比超过50%，甚至更多。降低这种功耗最常见的办法是在不需要时钟时，关闭时钟。</p><p>在现在的EDA工具中，带有同步使能的寄存器，通过会自动识别并转换成门控时钟电路，而不影响逻辑功能，如下图所示。</p><img src="/2024/030235044/image-20240303154850877.png" alt style="zoom: 40%;"><p>如果使用时钟门控的寄存器为多bit，比如32bit，使用时钟门控技术对于功耗的降低是非常明显的。因为使用一个门控时钟，输出连接32个寄存器，节省了32个重复的选择器逻辑。</p><h3 id="2-2-门级功耗优化"><a href="#2-2-门级功耗优化" class="headerlink" title="2.2 门级功耗优化"></a>2.2 门级功耗优化</h3><p>除了门控时钟优化，也可以通过优化门级逻辑，降低功耗。</p><img src="/2024/030235044/image-20240303162241287.png" alt style="zoom:50%;"><p>上图与门的输出就有较高的活动性，通过降低与门输出线上的负载电容，可以降低功耗。因此，将后级或非门拆分为或门和非门，减小与门输出的负载。</p><p>下图4输入的与门，不同的输入引脚有不同的输入功率。对于活动性高的信号可以接入输入功率低的引脚，活动性低的信号可以接入输入功率高的引脚，避免输入功率大和开关活动性高同时出现，进而降低功耗。</p><p>通过修改管子的尺寸，改变驱动能力，可以降低动态功耗。</p><p><strong>门级逻辑优化技术，由工具自动实现，对RTL设计人员是透明的。</strong></p><h3 id="2-3-多电压"><a href="#2-3-多电压" class="headerlink" title="2.3 多电压"></a>2.3 多电压</h3><p>功耗与电压成二次方关系，不同模块采用不同电压。但是需要复杂的电源网络供电，以及信号电平转换器等。</p><img src="/2024/030235044/image-20240303165214237.png" alt style="zoom:50%;"><h3 id="2-4-多阈值电压逻辑"><a href="#2-4-多阈值电压逻辑" class="headerlink" title="2.4 多阈值电压逻辑"></a>2.4 多阈值电压逻辑</h3><p>工艺库中通常提供不同阈值电压相同逻辑的单元，通常是在满足时序的基础上，使用高阈值电压的管子降低功耗。</p><img src="/2024/030235044/image-20240303165856495.png" alt style="zoom:50%;"><h2 id="3-多电压设计"><a href="#3-多电压设计" class="headerlink" title="3 多电压设计"></a>3 多电压设计</h2><p>使用多个独立电压对芯片进行供电，考虑复杂的供电策略：根据不同的负载提供不同的电压，根据模块不同的行为提供不同的电压，RAM在保持状态时提供低电压，在读写时提供高电压，甚至可以考虑 电源门控技术。多电压策略分类如下：</p><ol><li>静态电压调节SVS：不同模块采用不同的电压，一个模块分配一个电压；</li><li>多电压调节MVS：一个模块可以采用不同电压进行切换。</li><li>动态电压和频率调节DVFS：检测负载变化，对电压和频率进行调节。</li><li>自适应电压调节AVS：DVFS的扩展，构造环路，通过反馈自适应调节电压。</li></ol><h3 id="3-1-多电压设计中挑战"><a href="#3-1-多电压设计中挑战" class="headerlink" title="3.1 多电压设计中挑战"></a>3.1 多电压设计中挑战</h3><ol><li>电平转换器：不同电压域的数据信号传输需要level shifter缓冲器，实现从一个电压摆幅到另外一个摆幅。</li><li>静态时序分析：工艺库中的时序分析都是针对单一电压的单元，多个模块在不同电压下运行，工艺库无法提供准确的时序参数表征和分析。</li><li>布局布线：多电压的版图设计需要更复杂和更仔细的布局规划，电源网络会更复杂。</li><li>PCB板级：需要更多的稳压模块提供不同的电压。</li><li>上电和断电顺序：给电顺序可能会影响电路的功能。</li></ol><h3 id="3-2-电压调节的接口-电平移位器"><a href="#3-2-电压调节的接口-电平移位器" class="headerlink" title="3.2 电压调节的接口-电平移位器"></a>3.2 电压调节的接口-电平移位器</h3><p>现在芯片的电压一般都在1v左右，为什么还需要处理从0.9v到1.2v电压域的信号？</p><p>一个根本的原因在于：0.9v的电压驱动1.2v栅极，会导致NMOS和PMOS同时导通，产生动态短路功耗。</p><p>此外，标准单元库的特点是 最好输入是干净、快速、轨到轨的输入范围。否则，会导致信号在一个电压域的驱动单元和另一个电压域的接收单元之间呈现出明显的上升时间和下降时间降低问题，对时序分析带来不好的影响，甚至带来短路电流。</p><h4 id="3-2-1-高电平-低电平-电平转换器"><a href="#3-2-1-高电平-低电平-电平转换器" class="headerlink" title="3.2.1 高电平-低电平 电平转换器"></a>3.2.1 高电平-低电平 电平转换器</h4><p>实现起来比较容易，两个串联的反相器即可，只需要一个电源轨，来自较低或目标电源域的电源轨。并且，仅引入了缓冲器的延迟，对时序分析影响不大。</p><img src="/2024/030235044/image-20240304210034774.png" alt="image-20240304210034774" style="zoom: 33%;"><h4 id="3-2-2-低电平-高电平-电平移位器"><a href="#3-2-2-低电平-高电平-电平移位器" class="headerlink" title="3.2.2 低电平-高电平 电平移位器"></a>3.2.2 低电平-高电平 电平移位器</h4><p>欠驱动信号会降低接收输入端的上升和下降时间，导致更高的短路电流和降低噪声容限。</p><p>对于跨电压域的时钟信号尤为重要，上升和下降时间的任何退化都会导致时钟偏移skew变大。</p><p>一种简单直接的设计方式：采用缓冲和反向形式的低电压用来驱动交叉耦合的PMOS管，最后输出接一级缓冲。如下图所示，共用一个地。这种电平移位器带来的延迟较大。</p><img src="/2024/030235044/image-20240304215419001.png" alt="image-20240304215419001" style="zoom: 40%;"><h4 id="3-2-3-电平转换器的布局"><a href="#3-2-3-电平转换器的布局" class="headerlink" title="3.2.3 电平转换器的布局"></a>3.2.3 电平转换器的布局</h4><p>高电压域到低电压域的数据传输，通常将电平移位器放在低电压域，因为电平移位器只需要低电压轨道，将缓冲器放在高电压域。</p><img src="/2024/030235044/image-20240304222217976.png" alt="image-20240304222217976" style="zoom:40%;"><p>低电压域到高电压域的数据传输，由于输出驱动器需要比输入级更多的电流，所以将电平转换器放在高电压域中。</p><img src="/2024/030235044/image-20240304225632558.png" alt="image-20240304225632558" style="zoom:40%;"><h4 id="3-2-4-自动化插入"><a href="#3-2-4-自动化插入" class="headerlink" title="3.2.4 自动化插入"></a>3.2.4 自动化插入</h4><p>高电平-低电平 电平移位器的插入应该考虑时序问题；不使用电平移位器会导致延迟计算的误差，如果两个域的电压差很大，则该误差不可接受。</p><p>低电平-高电平 电平移位器的插入应该考虑功耗和时序问题。不使用电平移位器会导致高电压域的输入级不会一直关断，产生短路电流。并且影响了输入转换时间，导致延时计算误差。</p><h4 id="3-2-5-电平移位器的建议和缺陷"><a href="#3-2-5-电平移位器的建议和缺陷" class="headerlink" title="3.2.5 电平移位器的建议和缺陷"></a>3.2.5 电平移位器的建议和缺陷</h4><ul><li>建议</li></ul><ol><li>将高-低 电平移位器放在低电压域；低-高 电平移位器放在高电压域；</li><li>低-高 电平移位器 会带来显著的延迟效应，考虑这些延迟是否影响关键模块的时序。</li><li>确保不同电压域直接存在明确的关系。</li></ol><ul><li><p>缺陷</p><p>电平移位器的加入，导致时序分析困难</p></li></ul><h3 id="3-3-在多电压中的时序问题"><a href="#3-3-在多电压中的时序问题" class="headerlink" title="3.3 在多电压中的时序问题"></a>3.3 在多电压中的时序问题</h3><h4 id="3-3-1-静态时序分析"><a href="#3-3-1-静态时序分析" class="headerlink" title="3.3.1 静态时序分析"></a>3.3.1 静态时序分析</h4><p>在静态电压调节中，只需要一个工艺库，对不同电压的时序参数进行了表征，就可以针对不同电压域进行时序分析。目前，这个问题很容易得到解决。</p><img src="/2024/030235044/image-20240304235232681.png" alt="image-20240304235232681" style="zoom:40%;"><p>对于左面的模块，既有0.9v的电压，也有1v的电压，在时序约束时，应该按照哪个电压约束？</p><p>解决办法：为每个电压指定对应的时钟约束，一组用于0.9v，一组用于1.0v；因为这两个电压对应于不同的性能和时钟速度。当同时满足时序要求时，才算是真正的完成时序检查。</p><h3 id="3-4-多电压带来的系统问题"><a href="#3-4-多电压带来的系统问题" class="headerlink" title="3.4 多电压带来的系统问题"></a>3.4 多电压带来的系统问题</h3><p>不同电压的上电问题，在同一时间启动所有的不同电源是不切实际的，某些IP需要特定的上电顺序。</p><p>电源控制器通常由CPU控制，意味着电源控制软件必须与CPU上运行的系统软件集成。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FMCW频率源系统建模</title>
      <link href="/2024/022817065.html"/>
      <url>/2024/022817065.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5fa476c3bd1b00988e41558eb20bbc902c1ba212322e8d24512178d2529975eb">4630436162ade97ba2718b7d0c4b3b6351ade09e539dfebeb5402828e29e64b0474ba98726a3f48ffd712f7d028c0f8590bc7f86c7306404b3affc0f0001546dd88f03f4ef2e0711b996ee8d42bbcf79da327a1d501a906dc08f19870f01c80be620a7d2b84f91009ed0ba0f601b70a6829b934c0d2cbe664828ac9267a0907d782961a6129afb3496f582ed17d6735d99981128f3cb5b443074e00cc483026afddf1bba17e4596b20db3b825ff12322d8f1694b391dbcf90fa66dd5bd0be7f746870ff27e14d1aade0107678a3ae431154d1fbdfa28a3bdbf965461f3eb1b0b2f92060cb810c8ae6c604646bcc339af0d4b4d8015710cbe47634b2bede05e7bfdc9544129fe2aa5c50000fd4f876317cd33074477c2fa8711aec9dad80e7d1a5116bbb79bfbe32e3f4a7983f8d7f7e9bdc441583e22cd8b85a7e268bb423c29e207bfe92c2c851480f3ee8c250b730ac0450ab6d6258998584da12d69451ab1acb9b52d20868d634287117c9e9ae82eab37b7efbb06d8af5585c7cdd360170496354aac0edf9eccbd4cb08e48a7d76252052ec09ed5b66c4098a11efe2efb78f770b7d6a03c344e8606196ad60b423c85416b354f1b63a7a8bcd420b863fe2f4df3409233f672ea0c13310c963ee9714964e7b2d21afd437d612411fff304e24bd67e26ace6e9625a5f8fda3afb89163dca08f7d1b94973eceefa79711177d505ed4233e598fad8d5fc5d94a2f506b62dc20bcf34b4a35fddee8b029b26d29ce7eaef4a65ab31ae0b0018d9c38e79fd1b2e2d9306efae05fb53cca250b1766db0a690d2a96dd0b5fc5442da8b4111c022282bea19c33cbee4e73488bc230b04e5262ebd93bd504a9c9bc4a6b22da4cc60f029232cd00c3bc70785ec9b866340e94e39abbac166272ab4d68619de42404bd38559d9d3763dadf0d8fc4e864b413a62dc30f4ce2d284a7ee48738f39e93cd9b6ec500cea02c262f75a2ccc6f6447ef8a52bcf08da3fad7e326c037a222a044da8a57e19d7dc2b0ef79cb02fcf242a2c2d0f1654b25c40576e935e0d79a601285382bae6ab7c3e01285e8d701bd30d5a9ce3c891a6d21b4f2be7ee4789d858176593e4df585daae4870d74bade477b9dcdd3c31b2ba3c4fb35e53462d2654b4ea4cf2a754a78725984ef77907a2025f1ddbc6550554125445f3f950cf73a36c69245c2470c10aaf086ede31ba597cd944679a4fd6293f47e20f882230ba1560c194a3fd4716325e6595293f80ec197949ecff26d6b1a116d6f767791f46a2bf6cad29cbd5cb574b23295d987cfb84b7a43385a36ca6d59068ea9279b575749842619b07e2cc9c46178aee4c5d45fc6304009d5501c339685bf3e9497daec45a313213ea14bc893e61c361accc696a452ba972a05aabb5f95d33d383630d9469748f08d957e32be6f6b520fdf055e7fbae13af2816f8d6271a9958ad275b60451e14b2592163b05e5d9eae7640996c2aceb409c8907d0ed2865bcf5162ca498d9e32b97a895a6c539727cafb1839d8a3ddb8956fdd11324052477306e1fa0f69c4a370155fee0dd80b91595637f5c0d177d64bdcee1b020f8afeff36a95c674b877546a912f766c0d35f3fd1c85b2f7561220a5426080cf308211fa2235b4c3730f07fc09a77dbc45ab7acab0d0db0fd5d9bcd9ce3c188e66f3718296a44c8d8a616d11a4f2790a5b1dd4f4beca28861900e327818ee527a314fb3060a3e2bb412c0972fc905a9736f2cf30a96d2ac2bd71edf3320c95bb86b1cf4e1cdad62d9abf2b00813ea9117aaf578dd8ba490cc2b3da08ea05268cdcddcbb56e47bcdd6546b625ef56f9e01a3a65faad974931e1c55e38364ae2a5c0008f22fc0b89bea00c161007bf70f55768cd496bb7aad8527060f29c1d4823f7d08ccd0ff611d26a9a30074798bcae92a7fa70d40bd3968de6d3af61157d469ce8b9cdd4099cb8ec47eacd2e01e52645aa03a0856f118142755416700222d814f65d9dd72a4a9469f5440d09966004d55d08678d7bf16206424fea6cec478a31647fcc1155ea2832a7bd7adcc7c9146c7c0aa4bd29da1b6f8ab4570a9aa573b77ed4199ac3aab9d0b75272da066ab2f629902288bf4074bd7daea7341e2f4e1a4d054070e98d7127616408a1812b3b79139f8741426b0c57fc28efc5e5452ff5d7079f615d1e61b6a814ebd51a99d99e00e4b499d2445466a72e6b04dd3fe51e43923c3804f749734bdaa5bb23b045bb6047ebd6f1493afe99d20b02ae716b5ed021b0ab993e55adcf741ae94651093d904ee14da310fdeda8102265c5fa6789c7013138d03aeae566a5878f8b8058c0775275ea5e63576641732b94b0a4a9c3774c87c5de2470bdd3d6ba5ea04a25bc4de23f2fe51cb89dd203901b3f0e5402533310f5fcd76c92599c0ba2cfd3b56d981bec0f00c40f66f001d9180613c24903eb9a7cfce044c39c41a7a100f58c16b71e6bd7b1776b0a5ffd05c75c6c60aa684d41e16c8d9c7e2b85267f10caf3eda888fe38134d156368f3877bea2c49b8425fed2c49854784237440179a06734ca1d0addc1d5b6e5ea93d3511230c98719315c949bade82607f7cc60d483c702ee6297656bdc937346a4ef28d358144d5d112c62c7a8fd7669469440bb17563ad3ea9237a27ff84498d45d83e87fb9b170b442c627aaeaa355b1d8ded2a649b52507480e100d15b8019bd40d1fe160c6c1c3e154ac904ec5f9b9a5b1c4c17a3323cf014be602f48f0cf592b3c05e18118a3d44e35138680ee419cbe8e901f5a7a2f6bc5a022630e5b81dbcaec0c460f3bf1778de1f0c0bd2943360916d1717f151dcfd5555f962d94a793fe01ccce3651f2eb8ebb18d15e1b45efa29fe4a015d54a2cae169231f8933f97d87c81231f0b13ca81f8ea4b76909f8b218eae89faf64457d8928ad380fad4a176d8b3ca46589d0d9ada0d4035cff024244511c4d94a2fd3ab507712802f7e290ac15fae45a11d490408898769eea80cdd6cb8185b9e6d7ec7b147411106d24c2e5470f2e027146c50502cafb6a30eb1657527598c828c82cb592e3977d62b5d70d1d765164971ddc16ae1a7b8deb4d483e886e67f0eddbec0d5be77c7046692cb94150ee3320cf05a6fd72b61c56c20215d028bd82afe0a44b526e4511d34775f9e0d9e53d81d5dbc9c12b15c36f7a806a8f856457091dc2be4545834a5fbc95bda5daac18550c77fe1be6e2672a2505e33cedf014edcee9057a815ec10378552785007d2ce282017b0c685ad2c7cd5658acf34e58d75af4adf419c8a09713b3ae4854a4e3037f396bd30d617480cdaceb5c35ca88f9ee91b444b35b056d48ec73c5d3c1a99185e5b646f0734d3354d981aec30aa90740195b7eefa39ab976499ea6cac3d86b9095af1ea3d691d35df73944680b2b445195e21a6939d32b22f218cfd020dbc853f542215f1392fbd8135925916eca7ea485ff6159c653b16e63116619a7cb6edba1e30fbfac842a8385c2613bcf0bd732e7603be1996059ccafdbaf6191e1cb5d420d67f15447788622e95a9618399770e7edfc7097281085edae72247f449b514fe4853396e2335baadd2497f3ae2b929553a0f9aeea4a7f909e838e655118bb6cd03b464b6ef78c3867744e8e0add1a05434064eff5fa81c0560fc15bfc4613ed5d8b25f340912660506816246fcb46230deb86a9f8b89ec57816c9d477a0bac5444ea58fa49a09a4935c1179e1cf93a858b365343500df2a214f696bcde7e9a74c9e3d04adbfb6229719272534740e0cdf9c1c67c1264353cb33248e16f147f5512388e17aae29a51fac77ac642bb3fae9531e75be00bfa5692620f794170915a4d55a97dcd8d3ea4492eda08b5336dc2b2ba1fe9546e7411ba5a6ad4d912fd3fb9fc73a6da3f991b83162277802c9137235c9fc59460d7f955feb5810255b9461ce7b95711fb1090fc2396f9d913cd4020a035281bd41f72c5b76477956d611ade53e736342288c2322b1570c116bb7b9e7dcdfa77d3f6dd8659fe75db9d8b86993935cb8c9020cf8bb7bf3d1e29f1039126060936fc0d81fae4ab57ffb6575fef4eae6a2916784d60ca89ffd8d066031df4be91c45018783432d750bfaf74f35b2aabe55d490830e6a36754e36da66ab7359a495c3809f37092f4eb9bb663b5b78ed42aadb806e59916285479f79d7e3b6ed47585193576c2d2829e90d07b948de615afb2256979565d20702f69f9d95b51665bf0c8977c3dba812d7c576a565ea82ac5f9d0a631c643c63e4ea5680c4211983217f84f96e1c3dedc0632423ec70909e434b2ce38b7a7d520f7263aae5eb67108febabaf9238aa699c923735f28b2cf2abd2f91ca22fc5060938ccdb6e57d5b6bc7ec1a2b307db12bb5ec98c241fab82e7ddfdb0d65c78393b739c7a62eb8c1e163a21a6fd2a264ef1aa4c85986cef088a1c7a5a00182424cd1e53e6ed8d16e8ebbac0113bbd95b964be37403cae0e4c1afaabdf81b654cf2ca5a9ab18412fd1011eee657973a5c07a888c1133ef2d7448cacd0a05e4458cb78908e1a63a0e48080a4371c4fa6722c7b7de2a92a4cfe9a514f2721f3b5ddbeeb29ec9941e59375a1a2d1f8d874eb1f18f11aac02c3242045c441772a5f24f6b837af0fb26cba3ebc1d161211d4eab1718c2ed9676024eedf41c65e35345ce6057cadf524a94bb1bb3b6b2852f5efd1e23cc1d2b55509bde453642bc1be01739547efaa7a3e3f10155bb6747f54bd8d8b464a6fa1a3556a32fed838056e4712b14576c127ebd3bdbc6ede10249e7fe517fa50dfaf42c481847b54b627463442e8e648b1475edec309f1a32e8a8413b08e50819d3a23792d434a84c15cd04e4a27edbd5b79c8f9f6f8bc8b9eaba2a3aebe13eb4001398467dda6fb927c8fe7d2e060a2a16acb1bb1d778c90252cd50de6cfc7e3d3d8cfb4186e0a57e53d582f7644d1c86fc1d0b95eb6f33cccde17a0f93a535ad1d8d3a845aa8056ed6265f3318d6a8f97d705b443f3cfa8cb2083ee464df0854fcc08f2ed2fc4881a782f45ca399dc21ead05e8baf7ad971f9790c6fdc68698a4aaf2616c586e35b5d80afca1407a4b9b79b3ba15d080f9db55b890c6537e4d1216a93c7e529f19df42d1a9e421f668e87f1c5e037f83236ab23ea2fd3bccfdb47dc93ff9040791f73cf99386f1645868589cd208004aad30c011d94220f6c5ee5c3baa40ead3928680e478436465a3824b13208aa56bd69d7e3dc54db2449af6a5521075ec67de741731391b08e3f3ab2f87089c83c0140deae719ed62f809d506bfd45dc52e66e797d3ae4839bcb1f24c229ad8efad4877dc9f32bb9f019d119bef625f063e94e3f15b7f4e37857aa96bbf3446a6b43ffc48d947bed2e4b51c72dd42a8437403cab63a7286abc4cb3df20588b90cbc723ad029086422bde611b61eb58acb782b63f8ae42abffec113a38e50a7f241aad18aed47b25cd1dbda1dc162318fc6fc4edc20fc774ef3cb4459d070d93864d6fee71a52784992a58e2351e34b6f83ca5e08c2a17bd5bd75d4ab35c417f1d3ef6a631de82640da7c938fdaa939b8d3fc77db14e1c7f4e7b74816b6101d896705918153baab7829e6c0cc7568a3dc2376823afe68be20365aa5ef734a755cc609d43cfdd633bd4067b22eef38dd16555ba4843774a112795ef8f73f70285993ea328bb3aac6dcba93aeda923571d721516a96170f01bb10406fab3e941f28f4cfb5bb6ccff10a122ee4b918fe0e31f21d0677e26cda3bc4b2a85667479c867039d8b69131f003904d7ce942f21ecb1d32de2ece9665ca33379cb61dfd52b84ae9b57c1bff04d10a7cdd7784c19d1ba42bf200efceb027cd229f4f3af87dbf9905ca7f23e5af7e29f3d8a213fc40e56a4de1358b9b05446133404d4e5adf610e405e11eb8b51f610fa66b9d4e8deccc1f6edf2488ac3e763daffed8acf458bcf432adf1529864173ab5c4f8e480edccaa5d06dfb61a95acca2d548ec9693dc58fca76ec9e1e1d1adbb4bdb4aa6b42f05d7672809215d01269f0a90fab7bc12b7fcad1d613a60162496bbe3c05c7d352580bdb8e93b84dc8e4fa6efb05fe34689582b208ad517d0f44207bc39c712da0c86a1393126bf927026974de0d197861388e70e1d116acf98e8d52d0f0a83bb46e615708e5fe449f0742efe192722992cf1a8bda2700d33f8e7d08bb31020fc8d541be3607975c5298ffd1d60ae3dab93ebc010341a14abe1c5aafcb9e597e5967788099f72543d1bbc2d02784781376c17afb7c76380882cf6bf1e40fd8e7ea337e6b239ff4d056ced7cd7a2614b6da21aca5d834b79a9f29f4b20eb01006e0bfb7e43ac3adf2654e3b39abd82955546b39d4625d26d7998fc5fe38177d7f8acd7f2a18028ab83064fab6474b839c1811c06e3b44d788f9fb8be60d93dc59c826c177d01808cf554cd5f5cb23d1d92e647d2f057636cbf1dd24324260cc30dbcec7f9060e330d2f92c83c64e31a93d1a482e7b64acc69c958f3c41886c3e3348d5476ad1f9a80bc0adc397b3d16ee2cb980658d5e86be55efcc97e92baaf9da5550548f4136515ba01b82bc6aa76fcb302e00fddfb25ffe80f2a9975fcb65ef908f78d76f19b12ff60ea7a99c328bbcd9a4593384036e011cee9cbda378e36f14d70230d426e8b8f773e1ec8dd3f926e15a4a1ad465282e6e9f52101997443936f2117ed30b3ca85af4557ad676c5d05880923d7cfe8758170588cf2040a2713bce186d92797a634dff05da1ca31dac80f570cb165d35e5598e639096c7c3fdb49f21f2579740286251e77e1506e21d281692cf422b6f3f440afe78d9d2599eec394fef1410e5e6fec4fcc66520024d225c8ebf00c5bb2d196f505b2f5e7880ae85fa6473e339e4f3fa19a5eeb4a471ccfab1ff61083ebd58866f27977db8c4611697c255ebdd64a76d6d8ae1da1c5549fcb68979e6235a800f8f9f78635ffa2c714c6f8323172ce9127b010be0cc0c256850c45254766370fa241bd4feba194c67492b9860fe209dd83f20ee63c224d89bf7eed46e76f40c338ee7b7b7f528ae9722cde3ec49522659f7a6741890a5ff6c988fa09fc30421439ba387a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FMCW</title>
      <link href="/2024/022837365.html"/>
      <url>/2024/022837365.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="bcc886015d867e685b6559a1a44adb96ac29f5a8c6a876082b4e78820267315c">10d79030e8222445804370796b90fca106f15dd47c03b7cc3ac7fb0590359f37ccd6ce25dabd9e485ae27a888d7ca1365faa8a02c4def6f2b680714dbfda3152f3e1c340acfd9ff0ccfb8758f48d76fc9b1d64545e4a4abbbe4e54f9a5bc525eb3873879f528981e5cf4dc75af378932210948467a541081f9fe77ad477811a3f1bd4da116b2ebc0184d867743e2d6547a787c27042c570fc5383eb78929b1d4a7d00c7253cf993abc4ea298ad840ae58ecdc6e9b11ff1038c0442badd946644538ca9882ae6ae86523929deb5acc2fbfe4b27919a28501eaa7ac9a9eb86e7a093e710c4a4aa0a2d29d2ecdf38ece2e29b1f62f1f0be16b6777521431f0a86398e38112c884626a2d54841b54856c0cdf0a0b17a33e0368c8c01c5c655e778bb6750ba0d1021a519867fcee72dd3ab0cd37a5f4f7698655764508f14e4753e290e4b98b6435e84a4e221b9c2bc55e078586965c73d478583e60e1005f0f932d0520ab4fc97597faf900e45dd35eb9dad57b36b93b200baadf06e32e06fff981451c60bab187a114a9b69e0d3d9bdae2260fb22b76a4f7e449ec5d66e3de863a73e35b9373995ea3ab27f9ad1106c83409fdaca90bf984aff8d1dbce64c1abfa669ce682a5c5eb865101716ebc98a5f54dabacb2898b8e85cb05a37227a186cd46d6dc08ec9577edcc8b94a3f4f2ce411ac9fb1e74fcc6d3ead1a50b8d0fef91147ef92ec7a658fe7ce2cab39a1eb9847cc43dd76bbe5984c51de5e445b53398573196217409add999afb0f10602845ffcd9854f4ef57108f05a140d4906dfb3e1d41b9a678421951dc93f4f7e0de5f24aff55f31e65f967b71c26f432bb60058b61cf88f3cb315e877c036031a2511ed04e6c4a39b075918abf76742d820024f35ee5a7a6e27f8c9adb853da1faa2e27da2a703a23ae76b617625341c8a3898c5d7249036804bc8cc94994e9cee71d7496153c43e4bb4f57dd461e3fae30bea5c2d3fc7f15240a358f313ff1aca8ef151df3dc3487b28987157972c89b8b8023449028b26881321891d94cb0e5a506ac2a0e37fd986f099ded74b920c78a4f98691b6ea1c5913f4f5b8def831b699a6188601e4b138cf02cbe1f2016e5746c47fa6c73c4ea8530122aa5865eea1886098d5c880f04eb234bfc6518e810dd90ea92e303b1f7d98d1793405089bce16f9e761ba09c5d07dc6504cef4ddb14aed99365faaa61ce1b3c716759740c8e61551cd9597b5aaed29baeba25bed32f1e8be6406aa9f3df69f1118a55f44b51aa9ad9eb0279f58fa4e6fd7962133b37ff133f220ab4210d640b4473ae678c4c376cd3c28a7be4c2ce1f4a6b4943fb75a539f951dd9d23aa3b054b2315bf0cb5a8696ca4c7670bee4e17d315732b57e67863ec6b3a017bc82465d1f2c7972c06a0c2d27c8f808262f01cf9d6f318aab3ec13ce48b7be2fc44643f6c43b2d452c23880d427224d4bfc61722b1e13a2c6cdeca20678dcc3e01e3fb8eeacca2e37c70fa5db0f6c309ccbddfc727b42e5bf51bcdecf6086ffbd86775f9c583ab53d127274d8f05ab56df31b6d1976a98d394280c4b4740e460a295e491c851379e08f984c66f7c76ea38cfa72e3d563707383c4427d1daea64268be9f880440b1e782b135b291cd4fb0ac3b89bd0feb61924fb92d550da3341269e8193072ce1f4f75e8fb0270e3ea698df492edcecf9290700fbb691dfe00af9ee1b04a2634990cfe1d3c1f5e8cf48e2f92ed379efbe8b91fd36227ddbbdac767530a4bbea9aebcce2f753eb6438331523d5a3ddb4b0ea650edecc65ffe6c1c7024c3ad729e98364b6d802b65a8555fa4a967b4d42a3dfe778e1317b353f4778e8d15bf93c0cd00c196030fe0a9af468592c8b34db2d3eb9594cc0f41961e70d61ac96488adef66d18fa51bbaf4b0a2140677d88a6b704fb9add9e6a53983741da4b940087adf3c6b12c89e5fc922ad4469c38c5b8759176f56467b9b65dbe0a4e5abb51f9a76146830e29eb13c80930db10b9653c5c1a64163b7f804e4c4206cd9e1b2b6d32618bd65fcf56eab37957ffe3c9de383541040af43c001adf9160ccc18b053b5d7fae8a5e2bc3f4ef7fa8ab6ac75a839d8c1b88c1599689168a0cf05462af9d81467395ac0635195508abc36889bd1306a69ba95898710ad9b0593d23ff643ebe4efdfc646cf8b42b33aabf42d59a1cb88a1150065571967ac858488c7461cfc41d77a328d71d7e32e342d52db78e9d65812d41447ac2c032fdf55c8339c4d8dc7d8e530ceb93fe1712cbaef00a8239c53ed91a2adbbbd7e97a00a26c7ff415a4e1c508f68f877296ac1ed7068112e134a2231c185</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>握手协议与反压</title>
      <link href="/2024/02265961.html"/>
      <url>/2024/02265961.html</url>
      
        <content type="html"><![CDATA[<h2 id="握手与反压"><a href="#握手与反压" class="headerlink" title="握手与反压"></a>握手与反压</h2><blockquote><p>部分内容参考以下博客<br><a href="https://blog.csdn.net/qq_57502075/article/details/127137378">https://blog.csdn.net/qq_57502075/article/details/127137378</a><br><a href="https://zhuanlan.zhihu.com/p/359330607">https://zhuanlan.zhihu.com/p/359330607</a><br><a href="https://www.bilibili.com/read/cv11100841/">https://www.bilibili.com/read/cv11100841/</a></p></blockquote><h3 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h3><p>主要有三种握手场景</p><ul><li>valid先拉高</li></ul><img src="/2024/02265961/v2-b6e5825d295cd1327c4406681de334e4_720w.webp" alt style="zoom: 50%;"><ul><li>ready先拉高</li></ul><img src="/2024/02265961/v2-df7b58f89b52d56d6b5eabce820acbd9_720w.webp" alt style="zoom:50%;"><ul><li>valid、ready同时拉高</li></ul><img src="/2024/02265961/v2-2ad04643ab5f2f7387675d5891a4a4b3_720w.webp" style="zoom:50%;"><p>需要注意：</p><ol><li>valid和ready信号是独立的，没有明确的依赖关系。（<strong>但是在AXI协议中，ready可以依赖valid拉高再拉高，反之，可能会产生死锁</strong>）</li><li>valid信号需要和有效数据对齐</li><li><strong>握手成功后，数据需要更新；如果没有新的数据更新，需要将valid拉低</strong></li></ol><h3 id="握手接口信号"><a href="#握手接口信号" class="headerlink" title="握手接口信号"></a>握手接口信号</h3><img src="/2024/02265961/image-20240227094825901.png" alt style="zoom: 50%;"><p>说明：一般来说握手的具体描述在master和slave内部，但是可以独立出来作为单独的模块，握手在该模块中完成；（在master端仍然需要一次握手，目的是修改data_i的数据；在salve端不需要握手，ready_i的更新只依赖于slave自身行为）</p><p>握手模块内部采用时序逻辑，将握手时的数据寄存一拍给salve，握手后，将握手的结果valid_o和data_o给slave端，这时valid_o相当于data_i的使能信号，不能当做一般的握手信号了。</p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">handshake</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>       valid_i<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_i<span class="token punctuation">,</span>    <span class="token keyword">output</span>      ready_o<span class="token punctuation">,</span>    <span class="token keyword">output</span>      valid_o<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>data_o<span class="token punctuation">,</span>    <span class="token keyword">input</span>       ready_i <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_o_r<span class="token punctuation">;</span><span class="token keyword">reg</span> valid_o_r<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        valid_o_r <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>valid_i <span class="token operator">&amp;</span> ready_in<span class="token punctuation">)</span>        valid_o_r <span class="token operator">&lt;=</span> valid_i<span class="token punctuation">;</span>    <span class="token keyword">else</span>         valid_o_r <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>valid_i <span class="token operator">&amp;</span> ready_i<span class="token punctuation">)</span>        data_o_r <span class="token operator">&lt;=</span> data_i<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> valid_o <span class="token operator">=</span> valid_o_r<span class="token punctuation">;</span><span class="token keyword">assign</span> data_o <span class="token operator">=</span> data_o_r<span class="token punctuation">;</span><span class="token keyword">assign</span> ready_o <span class="token operator">=</span> ready_i<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre><h3 id="反压"><a href="#反压" class="headerlink" title="反压"></a>反压</h3><p>出现反压有两个场景，</p><ol><li>入口流量大于出口流量，即多对一。</li><li>在流水线中，后级还没有准备好，前级对后级进行数据冲刷，所以需要反压让前级数据保持不变；</li></ol><p><strong>在实际设计中遇到的情况：</strong>第一个对应的仲裁器，在icache和dcache同时读取SRAM数据时，需要以dcache优先，保证取数据优先，这时就要反压icache的访问内存行为，即拉低arready和rvalid；第二个对应在CPU五级流水线设计过程中，如果访存阶段通过axi协议读写内存数据时，需要将流水线停顿下来，发出反压信号stall，让前级流水线的寄存器保持不变。</p><hr><p>不同场景的反压方法</p><ul><li><p>不带存储体的反压</p><p>反压信号需要对流水线的所有寄存器进行控制；</p></li></ul><p>eg. 下面加法问题，要求不使用存储器FIFO，完成握手设计；</p><p>思路：没有FIFO缓冲，相当于每级流水线的FIFO深度为1；逐级反压；</p><img src="/2024/02265961/image-20240227135234852.png" style="zoom: 67%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span> handshake_pb <span class="token punctuation">(</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>         clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>         rst<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>         valid_i<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span>         ready_o<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> d<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> e<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> f<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dout<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>         ready_i<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span>          valid_o    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> ready_o <span class="token operator">=</span> <span class="token operator">~</span>valid_r1 <span class="token operator">||</span> ready_r1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//pre_fetch结构</span>    <span class="token comment" spellcheck="true">//valid_r1为0 代表下一级无数据</span>    <span class="token comment" spellcheck="true">//ready_r1   代表下一级准备好了读</span>    <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>         <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span><span class="token keyword">begin</span>            valid_r1    <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>valid_i <span class="token operator">&amp;</span> ready_o<span class="token punctuation">)</span><span class="token keyword">begin</span>            valid_r1    <span class="token operator">&lt;=</span> valid_i<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>        <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>ready_o <span class="token operator">&amp;</span> valid_i<span class="token punctuation">)</span><span class="token keyword">begin</span>            r1_ab       <span class="token operator">&lt;=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//数据信号不复位</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token keyword">assign</span> ready_r1 <span class="token operator">=</span> <span class="token operator">~</span>valid_r2 <span class="token operator">||</span> ready_r2<span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> r2_abcd<span class="token punctuation">;</span>    <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>         <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span><span class="token keyword">begin</span>            valid_r2    <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ready_r1 <span class="token operator">&amp;</span> valid_r1<span class="token punctuation">)</span><span class="token keyword">begin</span>            valid_r2    <span class="token operator">&lt;=</span> valid_r1<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>        <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>ready_r1 <span class="token operator">&amp;</span> valid_r1<span class="token punctuation">)</span><span class="token keyword">begin</span>            r2_abcd     <span class="token operator">&lt;=</span> r1_ab <span class="token operator">+</span> r1_cd<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token keyword">assign</span> ready_r2 <span class="token operator">=</span> <span class="token operator">~</span>valid_r3 <span class="token operator">||</span> ready_i<span class="token punctuation">;</span>        <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> r3<span class="token punctuation">;</span>    <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>         <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span><span class="token keyword">begin</span>            valid_r3    <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ready_r2 <span class="token operator">&amp;</span> valid_r2<span class="token punctuation">)</span><span class="token keyword">begin</span>            valid_r3    <span class="token operator">&lt;=</span> valid_r2<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>        <span class="token important">always_ff @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>ready_r2 <span class="token operator">&amp;</span> valid_r2<span class="token punctuation">)</span><span class="token keyword">begin</span>            r3          <span class="token operator">&lt;=</span> r2_ef <span class="token operator">+</span> r2_abcd<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token keyword">assign</span> dout     <span class="token operator">=</span> r3<span class="token punctuation">;</span>    <span class="token keyword">assign</span> valid_o  <span class="token operator">=</span> valid_r3<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre><ul><li><p>带存储体的反压</p><p>在握手模块中添加存储体，比如RAM和FIFO；将无法及时响应的数据缓冲到FIFO里，需要设置水线water line，也就是当waterline为多少时开始反压前一级模块。</p></li></ul><img src="/2024/02265961/image-20240227102838935.png" alt style="zoom:80%;"><p>​当FIFO数据个数达到阈值后，需要将ready_o拉低，告知上游模块，无法处理新的数据，完成反压。<strong>waterline计算：FIFO的深度 - 流水线的级数。</strong>上图水线为24</p><p>eg. 设计一个并行6输入32比特加法器，输出1个带截断的32比特加法结果，要求用三级流水设计，求带存储器FIFO，可以缓冲数据，带前后反压。</p><pre class=" language-markdown"><code class="language-markdown">输入：<span class="token code keyword">    1. 6个32bit数据 a，b，c，d，e，f</span><span class="token code keyword">    2. 上一级的valid_i</span><span class="token code keyword">    3. 下一级的ready_i</span>输出：<span class="token code keyword">    1. 1个32bit结果 dout</span><span class="token code keyword">    2. 给上一级的ready_o</span><span class="token code keyword">    3. 给下一级的valid_o</span></code></pre><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span> handshake_fifo #<span class="token punctuation">(</span>    <span class="token keyword">parameter</span>           FIFO_DATA_WIDTH <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">,</span>    <span class="token keyword">parameter</span>           FIFO_DEPTH <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>         clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>         rst<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>         valid_i<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>         ready_i<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> d<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> e<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> f<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">logic</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dout<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">logic</span>        ready_o<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">logic</span>        valid_o    <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">localparam</span>          WATERLINE <span class="token operator">=</span> FIFO_DEPTH <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//three levels' pipeline</span>    <span class="token keyword">logic</span>               handshake<span class="token punctuation">;</span>    <span class="token keyword">logic</span>               handshake_ff1<span class="token punctuation">;</span>    <span class="token keyword">logic</span>               handshake_ff2<span class="token punctuation">;</span>    <span class="token keyword">logic</span>               wr_en<span class="token punctuation">;</span>            <span class="token keyword">assign</span> handshake <span class="token operator">=</span> ready_o <span class="token operator">&amp;</span> valid_i<span class="token punctuation">;</span>    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>            handshake_ff1 <span class="token operator">&lt;=</span> '<span class="token number">0</span><span class="token punctuation">;</span>            handshake_ff2 <span class="token operator">&lt;=</span> '<span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token keyword">begin</span>            handshake_ff1 <span class="token operator">&lt;=</span> handshake<span class="token punctuation">;</span>            handshake_ff2 <span class="token operator">&lt;=</span> handshake_ff1<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>        <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> r1_ab<span class="token punctuation">;</span>    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>            r1_ab <span class="token operator">&lt;=</span> '<span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>handshake<span class="token punctuation">)</span><span class="token keyword">begin</span>            r1_ab <span class="token operator">&lt;=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>        <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> r1_cd<span class="token punctuation">;</span>    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>            r1_cd <span class="token operator">&lt;=</span> '<span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>handshake<span class="token punctuation">)</span><span class="token keyword">begin</span>            r1_cd <span class="token operator">&lt;=</span> c <span class="token operator">+</span> d<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>        <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> r1_ef<span class="token punctuation">;</span>    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>            r1_ef <span class="token operator">&lt;=</span> '<span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>handshake<span class="token punctuation">)</span><span class="token keyword">begin</span>            r1_ef <span class="token operator">&lt;=</span> e <span class="token operator">+</span> f<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>        <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> r2_abcd<span class="token punctuation">;</span>    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>            r2_abcd <span class="token operator">&lt;=</span> '<span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>handshake_ff1<span class="token punctuation">)</span> <span class="token keyword">begin</span>            r2_abcd <span class="token operator">&lt;=</span> r1_ab <span class="token operator">+</span> r1_cd<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>        <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> r2_ef<span class="token punctuation">;</span>    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>            r2_ef <span class="token operator">&lt;=</span> '<span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>handshake_ff1<span class="token punctuation">)</span> <span class="token keyword">begin</span>            r2_ef <span class="token operator">&lt;=</span> r1_ef<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>        <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> r3<span class="token punctuation">;</span>    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>            r3 <span class="token operator">&lt;=</span> '<span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>handshake_ff2<span class="token punctuation">)</span> <span class="token keyword">begin</span>            r3 <span class="token operator">&lt;=</span> r2_ef <span class="token operator">+</span> r2_abcd<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>        <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>            wr_en <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>handshake_ff2<span class="token punctuation">)</span> <span class="token keyword">begin</span>            wr_en <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token keyword">begin</span>            wr_en <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token important">always_ff @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span><span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token punctuation">)</span><span class="token keyword">begin</span>            ready_o <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>usedw <span class="token operator">></span> WATERLINE<span class="token punctuation">)</span><span class="token keyword">begin</span>            ready_o <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token keyword">begin</span>            ready_o <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token keyword">assign</span> valid_o <span class="token operator">=</span> <span class="token operator">~</span>empty<span class="token punctuation">;</span>     sync_fifo # <span class="token punctuation">(</span>        <span class="token punctuation">.</span>MEM_TYPE   <span class="token punctuation">(</span><span class="token string">"auto"</span>         <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>READ_MODE  <span class="token punctuation">(</span><span class="token string">"fwft"</span>         <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>WIDTH      <span class="token punctuation">(</span>FIFO_DATA_WIDTH<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>DEPTH      <span class="token punctuation">(</span>FIFO_DEPTH     <span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token function">fifo_inst</span><span class="token punctuation">(</span>        <span class="token punctuation">.</span>clk    <span class="token punctuation">(</span>clk                <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// input  wire</span>        <span class="token punctuation">.</span>rst_n  <span class="token punctuation">(</span>rst_n              <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// input  wire</span>        <span class="token punctuation">.</span>wren   <span class="token punctuation">(</span>wr_en              <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// input  wire</span>        <span class="token punctuation">.</span>din    <span class="token punctuation">(</span>r3                 <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// input  wire [WIDTH-1:0]</span>        <span class="token punctuation">.</span>rden   <span class="token punctuation">(</span>ready_i<span class="token operator">&amp;!</span>empty     <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// input  wire</span>        <span class="token punctuation">.</span>dout   <span class="token punctuation">(</span>dout               <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// output reg  [WIDTH-1:0]</span>        <span class="token punctuation">.</span>empty  <span class="token punctuation">(</span>empty              <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// output wire</span>        <span class="token punctuation">.</span>usedw  <span class="token punctuation">(</span>usedw              <span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre><ul><li>逐级反压与跨级反压</li></ul><p>​带多个存储体的反压分为两种：逐级反压和跨级反压；区别如下</p><img src="/2024/02265961/v2-b0b7c25408364e8805d98054f238b1e1_1440w.webp" alt style="zoom:50%;"><p>​逐级反压：module3达到水线反压module2；module2达到水线反压module1；module1达到水线反压上游接口；<strong>每级都有握手信号需要处理</strong></p><p>​跨级反压：module3的存储体深度 &#x3D; waterlie3 + 在途1 + waterline1 + 在途2 + waterline2 + 在途3；<strong>只需要处理上游模块和module3的握手信号</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-异常处理设计</title>
      <link href="/2024/022651980.html"/>
      <url>/2024/022651980.html</url>
      
        <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="ecall自陷指令"><a href="#ecall自陷指令" class="headerlink" title="ecall自陷指令"></a>ecall自陷指令</h3><p>发生异常ecall时，处理器需要完成的操作：</p><pre class=" language-verilog"><code class="language-verilog">PC <span class="token operator">>=</span> csr<span class="token punctuation">[</span>mepc<span class="token punctuation">]</span>causeid <span class="token operator">=></span> mcausecsr<span class="token punctuation">[</span>mtvec<span class="token punctuation">]</span> <span class="token operator">=></span> PC<span class="token comment" spellcheck="true">// 在WB阶段，硬件自动完成</span><span class="token comment" spellcheck="true">// 将当前PC写入mepc</span><span class="token comment" spellcheck="true">// 跳转到mtvec继续执行指令</span><span class="token comment" spellcheck="true">// 将id号保存在mcause</span></code></pre><h3 id="mret指令"><a href="#mret指令" class="headerlink" title="mret指令"></a>mret指令</h3><p>将mepc给PC，跳转到发生异常处，改变程序执行顺序。在WB阶段执行；</p><p><strong>在WB阶段执行mret和ecall指令时，都更改了pc的值，需要对流水线前四级的寄存器进行冲刷reflush</strong></p><p><img src="/2024/022651980/image-20240227164253113.png"></p><h3 id="csr相关指令"><a href="#csr相关指令" class="headerlink" title="csr相关指令"></a>csr相关指令</h3><p><strong>csrrw，csrrwi，csrrs，csrrsi，csrrc，csrrci；</strong></p><img src="/2024/022651980/image-20240227152225346.png" alt style="zoom:50%;"><img src="/2024/022651980/image-20240227152627604.png" alt style="zoom:50%;"><img src="/2024/022651980/image-20240227152651142.png" alt style="zoom:50%;"><img src="/2024/022651980/image-20240227152745330.png" alt style="zoom:50%;"><ul><li><p><strong>csrrw rd csr, rs1</strong>，<strong>csrrwi rd, csr, uimm[4:0]</strong><br>ID译码阶段，读取寄存器堆CSR[csr]，regfiles[rs1];<br>WB写回阶段，将读取的结果保存在寄存器堆中，CSR[csr] &#x3D;&gt; X[rd]，X[rs1] &#x3D;&gt; CSR[csr];<br><strong>如果rd&#x3D;0，不会向regfiles写入数据</strong></p></li><li><p><strong>csrrs rd, csr, rs1   csrrsi rd, csr, zimm[4:0]</strong><br>ID译码阶段，读取寄存器堆CSR[csr]，regfiles[rs1];<br>​EXE执行阶段， X[rs1] &#x2F; zimm | CSR[csr] &#x3D;&gt; exe_o;<br>​WB写回阶段，CSR[csr] &#x3D;&gt; X[rd]，exe_o  &#x3D;&gt; CSR[csr];</p></li><li><p><strong>csrrc rd, csr, rs1   csrrci rd, csr, zimm[4:0]</strong><br>  ID译码阶段，读取寄存器堆CSR[csr]，regfiles[rs1];<br>  EXE执行阶段， ~(X[rs1] &#x2F; zimm) &amp; CSR[csr] &#x3D;&gt; exe_o;<br>  WB写回阶段，CSR[csr] &#x3D;&gt; X[rd]，exe_o  &#x3D;&gt; CSR[csr];</p></li></ul><h3 id="数据通路和控制信号设计"><a href="#数据通路和控制信号设计" class="headerlink" title="数据通路和控制信号设计"></a>数据通路和控制信号设计</h3><p>​根据上文描述，设计数据通路。ID阶段csr1_o和csr2_o的选择如下所示</p><img src="/2024/022651980/image-20240227163318097.png" alt style="zoom: 50%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    csr1_sel <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span>    <span class="token function">if</span><span class="token punctuation">(</span>i_type <span class="token operator">&amp;</span> <span class="token punctuation">(</span>opcode <span class="token operator">==</span> <span class="token number">7'b1110011</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">case</span><span class="token punctuation">(</span>fun3<span class="token punctuation">)</span>            <span class="token number">3'b010</span><span class="token punctuation">:</span>csr1_sel <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrs</span>            <span class="token number">3'b110</span><span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b01</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrsi</span>            <span class="token number">3'b011</span><span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b11</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrc</span>            <span class="token number">3'b111</span><span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrci</span>            <span class="token number">3'b001</span><span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrw</span>            <span class="token number">3'b101</span><span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrwi</span>            <span class="token keyword">default</span> <span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span>        <span class="token keyword">endcase</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">if</span><span class="token punctuation">(</span>i_type <span class="token operator">&amp;</span> <span class="token punctuation">(</span>opcode <span class="token operator">==</span> <span class="token number">7'b1110011</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">case</span><span class="token punctuation">(</span>fun3<span class="token punctuation">)</span>            <span class="token number">3'b010</span><span class="token punctuation">:</span>csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrs</span>            <span class="token number">3'b110</span><span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrsi</span>            <span class="token number">3'b011</span><span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrc</span>            <span class="token number">3'b111</span><span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrci</span>            <span class="token number">3'b001</span><span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrw</span>            <span class="token number">3'b101</span><span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// csrrwi</span>            <span class="token keyword">default</span> <span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">endcase</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手撕代码</title>
      <link href="/2024/022637133.html"/>
      <url>/2024/022637133.html</url>
      
        <content type="html"><![CDATA[<h2 id="毛刺过滤电路"><a href="#毛刺过滤电路" class="headerlink" title="毛刺过滤电路"></a>毛刺过滤电路</h2><h3 id="同时过滤正毛刺和负毛刺"><a href="#同时过滤正毛刺和负毛刺" class="headerlink" title="同时过滤正毛刺和负毛刺"></a>同时过滤正毛刺和负毛刺</h3><p>用verilog设计一个功能模块，将不足两个时钟周期长度的毛刺过滤掉，时序图如下所示：</p><p>输入信号：clk，rst_n，Din</p><p>输出信号：Dout</p><p><img src="/2024/022637133/v2-92bfd62c33dd99594745ac2becfc5206_720w.webp" alt="img"></p><p>思路：如果两个周期输入信号保持不变，则输出。否则，保持不变；</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">filter</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       <span class="token number">17</span>clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>       din<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span>  dout <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">reg</span> din_r<span class="token punctuation">;</span> <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        din_r  <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        din_r  <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         dout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>din <span class="token operator">==</span> din_r<span class="token punctuation">)</span>        dout <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="仅过滤单向毛刺"><a href="#仅过滤单向毛刺" class="headerlink" title="仅过滤单向毛刺"></a>仅过滤单向毛刺</h3><ul><li><p>过滤负毛刺</p><p>过滤一个周期的负毛刺，当负电平持续两个周期，才可以输出低电平；</p><p>采用两拍的寄存器，两级输出做 “<strong>或</strong>”操作；</p><img src="/2024/022637133/image-20240226150251458.png" alt="image-20240226150251458" style="zoom: 67%;"></li><li><p>过滤正毛刺</p><p>过滤一个周期的正毛刺，当正电平持续两个周期，才可以输出正电平；</p><p>采用两拍的寄存器，两级输出做 “<strong>与</strong>”操作；</p><img src="/2024/022637133/image-20240226150436436.png" alt="image-20240226150436436" style="zoom:67%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">filter_pos</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>       din<span class="token punctuation">,</span>    <span class="token keyword">output</span>      dout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        din_r <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        din_r <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> dout <span class="token operator">=</span> din <span class="token operator">&amp;</span> din_r<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="消抖动电路"><a href="#消抖动电路" class="headerlink" title="消抖动电路"></a>消抖动电路</h2><p>题目：用verilog实现按键抖动消除电路，抖动小于15ms，输入时钟12MHz。</p><p>思路：添加计数器，如果15ms数据没有变化，将输入放在输出。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> de_jitter <span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>       din<span class="token punctuation">,</span>        <span class="token keyword">output</span>      dout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">localparam</span> jitter_factor <span class="token operator">=</span> <span class="token number">180000</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span><span class="token keyword">reg</span> din_r<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        din_r <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         din_r <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         flag <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>din_r <span class="token operator">==</span> din<span class="token punctuation">)</span>        flag <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         flag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         dout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> jitter_factor <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        dout <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="串并、并串转换"><a href="#串并、并串转换" class="headerlink" title="串并、并串转换"></a>串并、并串转换</h2><h3 id="串转并"><a href="#串转并" class="headerlink" title="串转并"></a>串转并</h3><p>​    用一个计数器count，每输入8个数，就输出一次，每周期dout_temp左移一位，然后再将输入的1bit串行据存入dout_temp的最低位。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Serial_Parallel</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>            clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>            nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>            data_in<span class="token punctuation">,</span>    <span class="token keyword">input</span>            data_valid<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_out<span class="token punctuation">,</span>    <span class="token keyword">output</span>           data_out_valid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_reg<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>data_valid<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span>            cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        data_reg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>data_valid<span class="token punctuation">)</span>        data_reg <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span>data_reg<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data_in<span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        data_valid <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        data_out <span class="token operator">&lt;=</span> data_reg<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        data_valid <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        data_out <span class="token operator">&lt;=</span> data_reg<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="并转串"><a href="#并转串" class="headerlink" title="并转串"></a>并转串</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Parallel_Serial</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>           clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>           nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>     data_in<span class="token punctuation">,</span>    <span class="token keyword">input</span>           data_in_valid<span class="token punctuation">,</span>    <span class="token keyword">output</span>          data_out_valid<span class="token punctuation">,</span>     <span class="token keyword">output</span>          data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in_reg<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         data_in_reg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>data_in_valid<span class="token punctuation">)</span>         data_in_reg <span class="token operator">&lt;=</span> data_in<span class="token punctuation">;</span>    <span class="token keyword">else</span>         data_in_reg <span class="token operator">&lt;=</span> data_in_reg <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>data_in_valid<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> data_out_valid <span class="token operator">=</span> <span class="token punctuation">(</span>cnt <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> data_out <span class="token operator">=</span> data_in_reg<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据位宽转换"><a href="#数据位宽转换" class="headerlink" title="数据位宽转换"></a>数据位宽转换</h2><h3 id="宽到窄传输"><a href="#宽到窄传输" class="headerlink" title="宽到窄传输"></a>宽到窄传输</h3><p>​    假设数据从模块A传入到模块B，模块A的<strong>输出数据为32位</strong>，模块B的<strong>输入数据位宽为16位</strong>，那么如何能把数据从A传入B<strong>而不损失数据</strong>呢。</p><p>思路：<strong>通过时钟分频和倍频</strong></p><p>宽数据是慢时钟，窄数据是快时钟；</p><p>Input：快时钟+宽数据</p><p>Output：窄数据（快时钟输出）</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Wide_Narror</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>           clk_2x<span class="token punctuation">,</span>    <span class="token keyword">input</span>           nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>    data_in<span class="token punctuation">,</span>        <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> clk_1x<span class="token punctuation">;</span><span class="token keyword">reg</span> flag<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_2x <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_1x <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_1x <span class="token operator">&lt;=</span> <span class="token operator">~</span>clk_1x<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_1x <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        data_in_reg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         data_in_reg <span class="token operator">&lt;=</span> data_in<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> data_out <span class="token operator">=</span> clk_1x <span class="token operator">?</span> data_in_reg<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> data_in_reg<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="窄到宽传输"><a href="#窄到宽传输" class="headerlink" title="窄到宽传输"></a>窄到宽传输</h3><p>宽数据是慢时钟，窄数据是快时钟；</p><p>Input：快时钟 + 窄数据</p><p>Output：宽数据（慢时钟输出）</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Narror_Wide</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>           clk_2x<span class="token punctuation">,</span>    <span class="token keyword">input</span>           nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>    data_in<span class="token punctuation">,</span>        <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> clk_1x<span class="token punctuation">;</span><span class="token keyword">reg</span> flag<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_2x <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_1x <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_1x <span class="token operator">&lt;=</span> <span class="token operator">~</span>clk_1x<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_1x <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        data_in_reg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         data_in_reg <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span>data_in_reg<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data_in<span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> data_out <span class="token operator">=</span> clk_1x <span class="token operator">?</span> data_in_reg <span class="token punctuation">:</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="握手解决流水线断流、反压问题"><a href="#握手解决流水线断流、反压问题" class="headerlink" title="握手解决流水线断流、反压问题"></a>握手解决流水线断流、反压问题</h2><p>通过三级流水线实现以下组合逻辑的计算；包含握手和反压的处理。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y <span class="token operator">=</span> <span class="token punctuation">(</span>c1<span class="token operator">+</span>c2<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>c3<span class="token operator">+</span>c4<span class="token punctuation">)</span> <span class="token operator">+</span> a2<span class="token operator">*</span>b2 <span class="token operator">+</span> a3<span class="token operator">*</span>b3 <span class="token operator">+</span> a4<span class="token operator">*</span>b4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>思路：第一级流水完成 (c1+c2)，(c3+c4)的计算<br>        第二级流水完成乘法运算<br>        第三级流水加法运算</p><p>每一级的上下游都要有握手和反压信号的处理；</p><p><img src="/2024/022637133/image-20240228153148536.png" alt="image-20240228153148536"></p><ul><li><p><strong>ready信号的处理</strong></p><p><strong>以ready_r1为例，当r1寄存器为空（valid_r1&#x3D;&#x3D;0）或者ready_2为1时，r1都有能力接收数据；</strong><br>如果ready_r2为1，valid_r1也为1，则将该结果保存在r2寄存器中；下一个周期r1可以接收新数据；<br>如果ready_r2为0，valid_r1为1，下级无法握手成功传输，所以r1无法接收新数据；</p></li><li><p><strong>valid信号的处理</strong></p><p><strong>对于r1来说，valid_r1可以作为握手的结果信号；当valid_i和ready_r1握手成功后，r1输出valid_r1为1和有效的data_a。</strong></p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">handshake_pipline</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>       valid_i<span class="token punctuation">,</span>           <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c1<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c2<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c3<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c4<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a2<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b2<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a3<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b3<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a4<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b4    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> result<span class="token punctuation">,</span>    <span class="token keyword">output</span>      valid_o<span class="token punctuation">,</span>    <span class="token keyword">input</span>       ready_i<span class="token punctuation">,</span>    <span class="token keyword">output</span>      ready_o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a1_r<span class="token punctuation">,</span> b1_r<span class="token punctuation">;</span><span class="token keyword">wire</span> ready_r1<span class="token punctuation">,</span> ready_r2<span class="token punctuation">,</span> ready_r3<span class="token punctuation">;</span><span class="token comment">// first stage</span><span class="token keyword">assign</span> ready_r1 <span class="token operator">=</span> ready_r2 <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_r1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        valid_r1 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>valid_i <span class="token operator">&amp;</span> ready_r1<span class="token punctuation">)</span>        valid_r1 <span class="token operator">&lt;=</span> valid_i<span class="token punctuation">;</span>    <span class="token keyword">else</span>         valid_r1 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>valid_i <span class="token operator">&amp;</span> ready_r1<span class="token punctuation">)</span> <span class="token keyword">begin</span>        a1_r <span class="token operator">&lt;=</span> c1 <span class="token operator">+</span> c2<span class="token punctuation">;</span>        b1_r <span class="token operator">&lt;=</span> c3 <span class="token operator">+</span> c4<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a2_r<span class="token punctuation">,</span> b2_r<span class="token punctuation">,</span> a3_r<span class="token punctuation">,</span> b3_r<span class="token punctuation">,</span> a4_r<span class="token punctuation">,</span> b4_r<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>valid_i <span class="token operator">&amp;</span> ready_r1<span class="token punctuation">)</span> <span class="token keyword">begin</span>        a2_r <span class="token operator">&lt;=</span> a2<span class="token punctuation">;</span>        b2_r <span class="token operator">&lt;=</span> b2<span class="token punctuation">;</span>        a3_r <span class="token operator">&lt;=</span> a3<span class="token punctuation">;</span>        b3_r <span class="token operator">&lt;=</span> b3<span class="token punctuation">;</span>        a4_r <span class="token operator">&lt;=</span> a4<span class="token punctuation">;</span>        b4_r <span class="token operator">&lt;=</span> b4<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// second stage</span><span class="token keyword">assign</span> ready_r2 <span class="token operator">=</span> ready_r3 <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_r2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        valid_r2 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>valid_r1 <span class="token operator">&amp;</span> ready_r2<span class="token punctuation">)</span>        valid_r2 <span class="token operator">&lt;=</span> valid_r1<span class="token punctuation">;</span>    <span class="token keyword">else</span>         valid_r2 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> mul_1<span class="token punctuation">,</span> mul_2<span class="token punctuation">,</span> mul_3<span class="token punctuation">,</span> mul_4<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>valid_r1 <span class="token operator">&amp;</span> ready_r2<span class="token punctuation">)</span> <span class="token keyword">begin</span>         mul_1 <span class="token operator">&lt;=</span> a1_r <span class="token operator">*</span> b1_r<span class="token punctuation">;</span>        mul_2 <span class="token operator">&lt;=</span> a2_r <span class="token operator">*</span> b2_r<span class="token punctuation">;</span>        mul_3 <span class="token operator">&lt;=</span> a3_r <span class="token operator">*</span> b3_r<span class="token punctuation">;</span>         mul_4 <span class="token operator">&lt;=</span> a4_r <span class="token operator">*</span> b4_r<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// third stage</span><span class="token keyword">assign</span> ready_r3 <span class="token operator">=</span> ready_i <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_r3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        valid_r3 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>valid_r2 <span class="token operator">&amp;</span> ready_r3<span class="token punctuation">)</span>        valid_r3 <span class="token operator">&lt;=</span> valid_r2<span class="token punctuation">;</span>    <span class="token keyword">else</span>         valid_r3 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>valid_r2 <span class="token operator">&amp;</span> ready_r3<span class="token punctuation">)</span> <span class="token keyword">begin</span>        result <span class="token operator">&lt;=</span> mul_1 <span class="token operator">+</span> mul_2 <span class="token operator">+</span> mul_3 <span class="token operator">+</span>mul_4<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">assign</span> valid_o <span class="token operator">=</span> valid_r3<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速计算one-hot码中“1”所对应的下标"><a href="#快速计算one-hot码中“1”所对应的下标" class="headerlink" title="快速计算one-hot码中“1”所对应的下标"></a>快速计算one-hot码中“1”所对应的下标</h2><p>题目：找一个多bit信号最高位的1或最低位的1所对应的下标</p><p>思路：根据独热码和对应坐标的真值表，写出逻辑表达式；</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">One_Hot_position</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span>    <span class="token keyword">output</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> position<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> data_in<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> position<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> data_in<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> position<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> data_in<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//    one_hotindex</span><span class="token comment">// 8'b0000_00013'b000</span><span class="token comment">// 8'b0000_00103'b001</span><span class="token comment">// 8'b0000_01003'b010</span><span class="token comment">// 8'b0000_10003'b011</span><span class="token comment">// 8'b0001_00003'b100</span><span class="token comment">// 8'b0010_00003'b101</span><span class="token comment">// 8'b0100_00003'b110</span><span class="token comment">// 8'b1000_00003'b111</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="找到序列第一个1和最后一个1"><a href="#找到序列第一个1和最后一个1" class="headerlink" title="找到序列第一个1和最后一个1"></a>找到序列第一个1和最后一个1</h2><p>思路：找出多bit数据中第一个1和最后一个1的位置，将其转换成独热码，根据独热码得到位置；</p><p>通过”按位”操作</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// MAX</span>pre<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pre<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>pre<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">~</span>pre <span class="token operator">&amp;</span> data_in <span class="token operator">=></span> One_Hot<span class="token comment">// MIN</span><span class="token comment">// 利用补码的特性，原码和补码”与“操作后，得到独热码，1的位置为原码最低位为1的位置</span>data_in <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>data_in <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=></span> One_Hot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Find_Max_1</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span>    <span class="token keyword">output</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pre<span class="token punctuation">;</span><span class="token keyword">assign</span> pre<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> pre<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">assign</span> data_out <span class="token operator">=</span> <span class="token operator">~</span>pre <span class="token operator">&amp;</span> data_in<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Find_Min_1</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span>    <span class="token keyword">output</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> data_out <span class="token operator">=</span> data_in <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>data_in <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-AXI总线及仲裁设计</title>
      <link href="/2024/022546524.html"/>
      <url>/2024/022546524.html</url>
      
        <content type="html"><![CDATA[<h2 id="AXI-Lite总线设计"><a href="#AXI-Lite总线设计" class="headerlink" title="AXI-Lite总线设计"></a>AXI-Lite总线设计</h2><p>采用AXI-Lite协议，只支持单次传输，不支持突发传输，接口信号简单。由于dcache既需要读操作，也需要写操作，以dcache为例进行说明；</p><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>读操作的依赖关系：先完成读地址通道的握手，再进行读数据的握手，得到读数据。</p><img src="/2024/022546524/image-20240226100402535.png" alt="image-20240226100402535" style="zoom:50%;"><ul><li><strong>master</strong></li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// AR</span><span class="token keyword">assign</span> axi_araddr <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> RADDR<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span>addr<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">3'b000</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span> <span class="token punctuation">:</span> <span class="token number">64'h0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> axi_arvalid <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> RADDR<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// R</span><span class="token keyword">assign</span> axi_rready <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> RDATA<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><ul><li>slave</li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// read operation</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>     rvalid <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>rvalid <span class="token operator">&amp;</span> rready<span class="token punctuation">)</span>    rvalid <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>arvalid <span class="token operator">&amp;</span> arready<span class="token punctuation">)</span>    rvalid <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">reg</span> flag<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    flag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>arvalid<span class="token punctuation">)</span>    flag <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    flag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    counter <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>    counter <span class="token operator">&lt;=</span> counter <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    counter <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>     arready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>arvalid <span class="token operator">&amp;</span> arready<span class="token punctuation">)</span>    arready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>counter <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span>    arready <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    data <span class="token operator">=</span> <span class="token number">64'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>arvalid<span class="token punctuation">)</span>    data <span class="token operator">=</span> <span class="token function">paddr_read</span><span class="token punctuation">(</span>araddr<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>     data <span class="token operator">=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> rdata <span class="token operator">=</span> rvalid <span class="token operator">?</span> data <span class="token punctuation">:</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// counter 用来模拟salve提供数据所需要的周期数，延迟握手。</span></code></pre><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a><strong>写操作</strong></h3><p>写操作中，写地址和写数据通道没有明确的握手依赖关系，但是写响应通道需要写地址和写数据握手后才可以握手，由于AXI-Lite只支持单次数据传输，所以没有wlast参与。本设计中，先进行写地址握手，再进行写数据握手，最后写响应通道握手，完成写操作。</p><ul><li>master</li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// AW</span><span class="token keyword">assign</span> axi_awaddr  <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WADDR<span class="token punctuation">)</span> <span class="token operator">?</span> addr <span class="token punctuation">:</span> <span class="token number">64'h0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> axi_awvalid <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WADDR<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// W</span><span class="token keyword">assign</span> axi_wdata  <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WDATA<span class="token punctuation">)</span> <span class="token operator">?</span> wdata <span class="token punctuation">:</span> <span class="token number">64'h0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> axi_wstrb  <span class="token operator">=</span> <span class="token punctuation">(</span>flash_flag<span class="token operator">&amp;</span>dirty<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b11111111</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>flash_flag<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b0000_0000</span> <span class="token punctuation">:</span> byte_enable<span class="token punctuation">;</span><span class="token keyword">assign</span> axi_wvalid <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WDATA<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// B</span><span class="token keyword">assign</span> axi_bready <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WRESP<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><ul><li>slave</li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// write operation</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> waddr<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>     waddr <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>awvalid<span class="token punctuation">)</span>    waddr <span class="token operator">&lt;=</span> awaddr<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> wdata_r<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>     wdata_r <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>wvalid<span class="token punctuation">)</span>    wdata_r <span class="token operator">&lt;=</span> wdata<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    awready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>awvalid <span class="token operator">&amp;&amp;</span> awready<span class="token punctuation">)</span>    awready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>awvalid<span class="token punctuation">)</span>    awready <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    wready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>wvalid <span class="token operator">&amp;&amp;</span> wready<span class="token punctuation">)</span>    wready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>wvalid<span class="token punctuation">)</span>    wready <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>wvalid <span class="token operator">&amp;&amp;</span> wready<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"write addr:%x, data:%x"</span><span class="token punctuation">,</span> waddr<span class="token punctuation">,</span> wdata_r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">case</span><span class="token punctuation">(</span>wstrb<span class="token punctuation">)</span>       <span class="token number">8'b00000001</span><span class="token punctuation">:</span> <span class="token function">paddr_write</span><span class="token punctuation">(</span>waddr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> wdata_r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token number">8'b00000011</span><span class="token punctuation">:</span> <span class="token function">paddr_write</span><span class="token punctuation">(</span>waddr<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> wdata_r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token number">8'b00001111</span><span class="token punctuation">:</span> <span class="token function">paddr_write</span><span class="token punctuation">(</span>waddr<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> wdata_r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token number">8'b11111111</span><span class="token punctuation">:</span> <span class="token function">paddr_write</span><span class="token punctuation">(</span>waddr<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> wdata_r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">endcase</span>  <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    bvalid <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>bvalid <span class="token operator">&amp;&amp;</span> bready<span class="token punctuation">)</span>    bvalid <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>wready <span class="token operator">&amp;</span> wvalid<span class="token punctuation">)</span>    bvalid <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> bresp <span class="token operator">=</span> bvalid <span class="token operator">?</span> <span class="token number">2'b00</span> <span class="token punctuation">:</span> <span class="token number">2'b00</span><span class="token punctuation">;</span></code></pre><h3 id="AXI仲裁器"><a href="#AXI仲裁器" class="headerlink" title="AXI仲裁器"></a>AXI仲裁器</h3><p>SRAM一般只有一个，Icache和Dcache可能出现同时访问SRAM的情况，产生了冲突，需要设计Arbiter来决定哪个master的优先级更高。当发生仲裁时，本设计中设计Dcache优先级更高。</p><img src="/2024/022546524/image-20240226102945089.png" alt="image-20240226102945089" style="zoom: 50%;"><p>Icache没有写操作的需要，不需要仲裁。只有Icache和Dcache同时发生读操作时才进行仲裁。</p><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>lsu_arvalid<span class="token punctuation">)</span> <span class="token keyword">begin</span>    arvalid <span class="token operator">=</span> lsu_arvalid<span class="token punctuation">;</span>    araddr  <span class="token operator">=</span> lsu_araddr<span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>    arvalid <span class="token operator">=</span> if_arvalid<span class="token punctuation">;</span>    araddr  <span class="token operator">=</span> if_araddr<span class="token punctuation">;</span>  <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>lsu_arvalid<span class="token punctuation">)</span>    if_arready <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>     if_arready <span class="token operator">=</span> arready<span class="token punctuation">;</span><span class="token keyword">end</span>  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>lsu_arvalid<span class="token punctuation">)</span>    if_rvalid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>     if_rvalid <span class="token operator">=</span> rvalid<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">// 当lsu_arvalid为1时，反压if_arready和if_rvalid，延迟Icache读地址通道和读数据通道的握手</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时钟切换设计</title>
      <link href="/2024/022513924.html"/>
      <url>/2024/022513924.html</url>
      
        <content type="html"><![CDATA[<h2 id="时钟切换"><a href="#时钟切换" class="headerlink" title="时钟切换"></a>时钟切换</h2><blockquote><p>某些时钟切换的场景下，需要选择信号来选择某一个时钟信号</p></blockquote><h3 id="组合逻辑选通"><a href="#组合逻辑选通" class="headerlink" title="组合逻辑选通"></a>组合逻辑选通</h3><p>电路对时钟信号非常敏感，如果采用组合逻辑选通时钟，很有可能在时钟上产生毛刺，导致功能错误，或者不满足时序要求，造成亚稳态。</p><img src="/2024/022513924/image-20240225231635368.png" alt="image-20240225231635368" style="zoom: 25%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> clk1_t <span class="token operator">=</span> clk1 <span class="token operator">&amp;</span> sel_clk1<span class="token punctuation">;</span><span class="token keyword">assign</span> clk2_t <span class="token operator">=</span> clk2 <span class="token operator">&amp;</span> <span class="token operator">!</span>sle_clk1<span class="token punctuation">;</span><span class="token keyword">assign</span> clk_out <span class="token operator">=</span> clk1_t <span class="token operator">|</span> clk2_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/022513924/8f134e7b11982eb43608e728782d78da.png" alt style="zoom: 33%;"><h3 id="时序逻辑选通"><a href="#时序逻辑选通" class="headerlink" title="时序逻辑选通"></a>时序逻辑选通</h3><p><strong>产生毛刺的本质原因是sel信号是异步的，无法保证输出的时钟在低电平时切换。</strong></p><p><strong>通过添加一级寄存器</strong>，使得sel选通信号在时钟切换在下降沿才发生变化，这样不会产生毛刺，因为是“相与”的关系。<br><strong>增加了反馈的好处</strong>：即使select信号改变了，时钟的切换需要等待切换前时钟为低电平时才可以 发生切换，保证了之前时钟信号的完整性（不会斩波）。<br>通过以上两种优化，就可以输出没有毛刺的时钟信号。这是一种非常安全的时钟切换方案。</p><img src="/2024/022513924/1bee2a8c32b64dd050b86e103ad3462d.jpeg" style="zoom:50%;"><p>此外，由于sel信号是异步输入，为了降低亚稳态，可以打两拍，再进行时钟切换。</p><img src="/2024/022513924/12ba42985f38e4091d39bc8bae8d191e.jpeg" style="zoom:50%;"><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">&#x2F;********************************************************************* * Author           : liu * Last modified    : 2023-05-30 15:25 * Filename         : switch_clock.v * Description      :  * ******************************************************************&#x2F;module switch_clock(  input clk1,  input rstn1,  input clk2,  input rstn2,  input select,  output clkout);  wire clk1_select;  wire clk2_select;  reg clk1_reg_r, clk1_reg_rr;  reg clk2_reg_r, clk2_reg_rr;  reg clk1_reg_rrr;  reg clk2_reg_rrr;    always @(posedge clk1 or negedge rstn1)beginif(!rstn1) begin  clk1_reg_r &lt;&#x3D; 0;  clk1_reg_rr &lt;&#x3D; 0;endelse begin  clk1_reg_r &lt;&#x3D; clk1_select;  clk1_reg_rr &lt;&#x3D; clk1_reg_r;end  end  always @(posedge clk2 or negedge rstn2)beginif(!rstn2) begin  clk2_reg_r &lt;&#x3D; 0;  clk2_reg_rr &lt;&#x3D; 0;endelse begin  clk2_reg_r &lt;&#x3D; clk2_select;  clk2_reg_rr &lt;&#x3D; clk2_reg_r;end  end  assign clk1_select &#x3D; select &amp; (~clk2_reg_rrr);  assign clk2_select &#x3D; ~select &amp; (~clk1_reg_rrr);  always @(negedge clk1 or negedge rstn1) beginif(!rstn1)  clk1_reg_rrr &lt;&#x3D; 0;else  clk1_reg_rrr &lt;&#x3D; clk1_reg_rr;  end  always @(negedge clk2 or negedge rstn2) beginif(!rstn2)  clk2_reg_rrr &lt;&#x3D; 0;else  clk2_reg_rrr &lt;&#x3D; clk2_reg_rr;  end  assign clkout &#x3D; (clk1 &amp; clk1_reg_rrr ) || (clk2 &amp; clk2_reg_rrr);endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/022513924/48bccb9764f34ae5948dd826d5dcb0f5.png" alt="测试结果"></p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2024/022548230.html"/>
      <url>/2024/022548230.html</url>
      
        <content type="html"><![CDATA[<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">压缩成.tar文件： <span class="token function">tar</span> <span class="token parameter variable">-cvf</span> file.tar files解压.tar文件： <span class="token function">tar</span> <span class="token parameter variable">-xvf</span> file.tar压缩成.tar.gz文件： <span class="token function">tar</span> <span class="token parameter variable">-czvf</span> file.tar.gz files解压.tar.gz文件： <span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> file.tar.gz压缩.tar.bz2文件： <span class="token function">tar</span> <span class="token parameter variable">-cjvf</span> file.tar.bz2 files解压.tar.bz2文件： <span class="token function">tar</span> <span class="token parameter variable">-xjvf</span> file.tar.bz2压缩成.gz 文件 <span class="token function">gzip</span> <span class="token function">file</span>解压 <span class="token function">gzip</span> <span class="token parameter variable">-d</span> file.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><p>​&#x2F; ——根目录<br>​&#x2F;bin ——存放必要的命令<br>​&#x2F;boot ——存放内核以及启动所需的文件<br>​&#x2F;dev ——存放设备文件<br>​&#x2F;etc ——存放系统配置文件<br>​&#x2F;home ——普通用户的宿主目录，用户数据存放在其主目录中<br>​&#x2F;lib ——存放必要的运行库<br>​&#x2F;mnt ——存放临时的映射文件系统，通常用来挂载使用。<br>​&#x2F;proc ——存放存储进程和系统信息<br>​&#x2F;root ——超级用户的主目录<br>​&#x2F;sbin ——存放系统管理程序<br>​&#x2F;tmp ——存放临时文件<br>​&#x2F;usr ——存放应用程序，命令程序文件、程序库、手册和其它文档。<br>​&#x2F;var ——-系统默认日志存放目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> <span class="token builtin class-name">:</span> 显示系统的hostname<span class="token function">ifconfig</span> <span class="token parameter variable">-a</span> <span class="token builtin class-name">:</span> 显示网络的配置信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查看文件内容情况："><a href="#查看文件内容情况：" class="headerlink" title="查看文件内容情况："></a>查看文件内容情况：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> <span class="token function">file</span> <span class="token builtin class-name">:</span> 计算文件的行数和字节数<span class="token function">wc</span> <span class="token parameter variable">-w</span> <span class="token function">file</span> <span class="token builtin class-name">:</span> 计算文件的字数<span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token function">file</span> <span class="token builtin class-name">:</span> 计算文件的行数<span class="token function">find</span> 查找文件或目录命令格式为: <span class="token function">find</span> 后接查找的目录，-name指定需要查找的文件名称，名称可以使用“* ”表示所有。<span class="token function">find</span> /home <span class="token parameter variable">-name</span> “test.txt”,<span class="token function">find</span> /home <span class="token parameter variable">-name</span> “*.txt” :查找/home目录下，所有以.txt结尾的文件或者目录。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><p>在&#x2F;home&#x2F;usr目录中查找文件名中包括”<strong>Montage</strong>“或者<strong>montage</strong>的文件名，并打印出来；</p><p>A：</p><pre class="line-numbers language-none"><code class="language-none">grep -rli &quot;Montage\|montage&quot; &#x2F;home&#x2F;usr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​<code>grep</code> 命令用于在文件中搜索指定的模式。 </p><ul><li><p><code>-r</code> 选项用于在指定的目录和其子目录中递归搜索。 </p></li><li><p><code>-l</code> <strong>选项用于只输出包含模式的文件名，而不是匹配的行。(字母L的小写，如果没有这个，则会输出所有含有字段的文件名及对应行)</strong></p></li><li><p><code>-i</code> 选项用于忽略大小写。 </p></li><li><p><code>&#39;montage&#39;</code> 是要搜索的模式。 </p></li><li><p><code>/home/user/</code> 是要搜索的目录。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-Cache设计(二)</title>
      <link href="/2024/022536323.html"/>
      <url>/2024/022536323.html</url>
      
        <content type="html"><![CDATA[<h2 id="Cache实现"><a href="#Cache实现" class="headerlink" title="Cache实现"></a>Cache实现</h2><p>根据上述的理论知识，确定cache的设计要求如下</p><ol><li><p><strong>采用直接映射缓存的方式，cache size为2KB，cache line为8Bytes，</strong></p></li><li><p><strong>当访问cache缺省时，采用读分配Read allocate和写分配Write allocate策略，</strong></p></li><li><p><strong>cache的更新策略为写回Write Back</strong></p></li></ol><h3 id="Icache实现"><a href="#Icache实现" class="headerlink" title="Icache实现"></a>Icache实现</h3><p>​icache在流水线中的位置以及接口信号如下</p><img src="/2024/022536323/image-20240225165626395.png" style="zoom: 33%;"><p>​包含两组握手信号，第一个是ifu和PC寄存器的握手，只有ifpc_valid &amp; ifpc_ready&#x3D;1握手后，才可以更新ifu阶段的取值地址pc_i。第二个是ifu和icache的握手，只有cache_rdy &amp;  cache_vld 握手成功后，ifu阶段才可以拿到pc对应的指令，并通过inst_valid信号指示，给到IF_ID寄存器。Icache和SRAM通过AXI协议完成读取指令。</p><p>​由于icache只有对内存读取数据的需求，所以AXI协议中的写地址、写数据和写响应通道可以忽略，icache的整个状态跳转如下</p><img src="/2024/022536323/image-20240225171812056.png" alt="image-20240225171812056" style="zoom:33%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> allocate <span class="token operator">=</span> state <span class="token operator">==</span> ALLOCATE<span class="token punctuation">;</span><span class="token keyword">assign</span> wstrb <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> ALLOCATE<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b11111111</span> <span class="token punctuation">:</span> <span class="token number">8'b00000000</span><span class="token punctuation">;</span><span class="token keyword">assign</span> wdata <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> ALLOCATE<span class="token punctuation">)</span> <span class="token operator">?</span> ram_data <span class="token punctuation">:</span> <span class="token number">64'h0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> ready <span class="token operator">=</span> hit <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> IDLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">case</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>        IDLE <span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>hit<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span>            next_state <span class="token operator">=</span> RADDR<span class="token punctuation">;</span>                <span class="token keyword">else</span>                          next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>        RADDR<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>axi_arvalid <span class="token operator">&amp;&amp;</span> axi_arready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>                <span class="token keyword">else</span>                          next_state <span class="token operator">=</span> RADDR<span class="token punctuation">;</span>        RDATA<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>axi_rvalid <span class="token operator">&amp;&amp;</span> axi_rready<span class="token punctuation">)</span>   next_state <span class="token operator">=</span> ALLOCATE<span class="token punctuation">;</span>                <span class="token keyword">else</span>                          next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>        ALLOCATE<span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>         <span class="token keyword">default</span> <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有在IDLE状态才会读取cache的数据，如果hit，直接输出有效的指令；如果miss，则通过AXI读取内存，首先跳转到RADDR状态，进行读地址通道的握手，然后跳转到读数据状态。读地址通道握手后，得到指令数据，然后跳转到读分配状态，将读出的指令加载到cachemem中。最终在IDLE状态，hit该cacheline，读出数据。</p><p>cachemem中对于hit的判断和cacheline的更新如下</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>flash<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token function">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>DATA_SIZE<span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>   v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  d<span class="token punctuation">[</span>i<span class="token punctuation">]</span>   <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  tag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>      mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>en <span class="token operator">&amp;</span> allocate<span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token function">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token function">if</span><span class="token punctuation">(</span>wen<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> wdata<span class="token punctuation">[</span><span class="token number">8</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    d<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    tag<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> addr_tag<span class="token punctuation">;</span>   <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">assign</span> addr_index <span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> addr_tag <span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> offset<span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">assign</span> hit <span class="token operator">=</span> en <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>addr_tag <span class="token operator">==</span> tag<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> rdata <span class="token operator">=</span> offset<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">?</span><span class="token operator">&#123;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">&#125;</span> <span class="token punctuation">:</span> <span class="token operator">&#123;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于inst指令是32bit的，cacheline是64bit，通过判断offset[2]确定读取命中cacheline的高32bit还是低32bit。</p><p><strong>在cache miss时，通过AXI访问内存时，通常需要多个周期。这个过程中，需要将流水线停顿下来，发出stall信号给PC寄存器，输出给IF_ID寄存器为nop指令。</strong></p><hr><h3 id="Dcache实现"><a href="#Dcache实现" class="headerlink" title="Dcache实现"></a>Dcache实现</h3><p>​dcache在流水线中的位置以及接口信号如下</p><img src="/2024/022536323/image-20240225202346217.png" alt style="zoom:33%;"><p>​只包含一组握手信号，lus和dcache之间；对dcache进行读操作的过程跟icache差不多。<br>​<strong>最大区别</strong>在于写操作，写缺省时，执行写分配，将写入地址的数据读取到cachemem中(这个过程和读分配差不多)，在IDLE状态将待更新的数据写入到cacheline中，并将对应的dirty位置1。在替换该cacheline时，判断dirty位为1，需要先将数据写入到内存中；因此，相比icache，多了很多状态。</p><img src="/2024/022536323/image-20240225205639538.png" alt="image-20240225205639538" style="zoom:33%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>IDLE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> dirty <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> WRITEBACK <span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> RADDR <span class="token punctuation">:</span> IDLE<span class="token punctuation">;</span>WRITEBACK <span class="token punctuation">:</span> next_state <span class="token operator">=</span> WADDR<span class="token punctuation">;</span>ALLOCATE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>RADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_arvalid <span class="token operator">&amp;&amp;</span> axi_arready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>RDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_rvalid  <span class="token operator">&amp;&amp;</span> axi_rready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> ALLOCATE<span class="token punctuation">;</span>WADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_awvalid <span class="token operator">&amp;&amp;</span> axi_awready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> WDATA<span class="token punctuation">;</span>WDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_wvalid  <span class="token operator">&amp;&amp;</span> axi_wready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> WRESP<span class="token punctuation">;</span>        WRESP <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_bvalid  <span class="token operator">&amp;&amp;</span> axi_bready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> RADDR<span class="token punctuation">;</span><span class="token keyword">default</span> <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span><span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>针对读写指令是字节&#x2F;半字&#x2F;字&#x2F;双字</p><p>在读写cacheline时需要根据地址的后三位使用offset来限制，保证读出的数据都是对齐的，写入数据对cacheline的数据更新也是对齐的。</p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> offset <span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// Read</span><span class="token important">always @</span><span class="token operator">*</span> <span class="token keyword">begin</span>  <span class="token function">case</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span> <span class="token number">3'b000</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">3'b001</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">8'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b010</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">16'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b011</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">24'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b100</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b101</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">40'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b110</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">48'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">48</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b111</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">56'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> we_offset<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">case</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token number">3'b000</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">3'b001</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">3'b010</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3'b011</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">3'b100</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token number">3'b101</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token number">3'b110</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token number">3'b111</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">default</span> <span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we<span class="token punctuation">;</span>  <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> wdata_offset<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">case</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token number">3'b000</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">3'b001</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">3'b010</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3'b011</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token number">3'b100</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token number">3'b101</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token number">3'b110</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">6</span><span class="token punctuation">;</span><span class="token number">3'b111</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">default</span> <span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata<span class="token punctuation">;</span>  <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> tag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>en <span class="token operator">&amp;&amp;</span> hit<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span>we_offset<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> wdata_offset<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">end</span>  <span class="token keyword">end</span>  d<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>en <span class="token operator">&amp;&amp;</span> allocate<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span>we<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> wdata<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">end</span>  <span class="token keyword">end</span>  d<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  v<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  tag<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> addr_tag<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// lsu.v</span><span class="token comment">// 针对不同的指令，将输出的结果进行符号位扩展。</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>lden_i<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token function">case</span><span class="token punctuation">(</span>lsfunc3_i<span class="token punctuation">)</span>  <span class="token number">3'b000</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;&#123;</span><span class="token number">56</span><span class="token operator">&#123;</span>temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b001</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;&#123;</span><span class="token number">48</span><span class="token operator">&#123;</span>temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b010</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;&#123;</span><span class="token number">32</span><span class="token operator">&#123;</span>temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b100</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">56'b0</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b101</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">48'b0</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b110</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b011</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token keyword">default</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">endcase</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> lsres <span class="token operator">=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在dcache读写内存时，需要多个周期，这时流水线需要停顿下来，发出stall信号，将前面各个阶段寄存器的数据保持不变。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-Cache设计（一）</title>
      <link href="/2024/022542394.html"/>
      <url>/2024/022542394.html</url>
      
        <content type="html"><![CDATA[<h2 id="Cache基础知识"><a href="#Cache基础知识" class="headerlink" title="Cache基础知识"></a>Cache基础知识</h2><blockquote><p>部分参考网上的学习资料，侵删。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>时间局部性：在程序中，某个数据在短时间内会被频繁用到。<br>空间局部性：访问某个数据时，通过附近数据的概率也很大，比如循环访问数组数据。</p><p>Cache：用一块小而块的存储设备（采用SRAM实现），作为大而慢的存储设备的缓冲区，提高访存的速度，并降低功耗。考虑到时间、空间局部性原理，cache的作用就显而易见了。</p><p>cache的大小: cache size，cache平分成很多块称为cacheline，大小是 cache line size。比如，一个64Bytes的cache，平分成8个cache line，每个cache line大小是8Bytes</p><h4 id="分配策略-针对cacheline，读写缺省"><a href="#分配策略-针对cacheline，读写缺省" class="headerlink" title="分配策略(针对cacheline，读写缺省)"></a>分配策略(针对cacheline，读写缺省)</h4><ul><li><p>读分配：读取cache时，发生cache缺省，分配一个cache line缓存，用于读取数据。(天然满足)</p></li><li><p>写分配：写cache时，发生缺省时，从主存中加载数据到cacheline，更新该cacheline数据，将dirty位置1，等到替换时，再写入主存。</p></li></ul><h4 id="Cache更新策略（写cache命中）"><a href="#Cache更新策略（写cache命中）" class="headerlink" title="Cache更新策略（写cache命中）"></a>Cache更新策略（写cache命中）</h4><ul><li>写直通</li></ul><p>​当CPU执行store指令，在cache中命中时，既更新cache中数据也更新主存中的数据，保证数据一致性。</p><ul><li>写回</li></ul><p>​当CPU执行store指令并在cache命中时，我们只更新cache中的数据。并且每个cache line中会有一个bit位记录数据是否被修改过，称之为dirty bit。我们会将dirty bit置1。主存中的数据只会在cache line被替换或者显示的clean操作时更新。因此，主存中的数据可能是未修改的数据，而修改的数据躺在cache中。cache和主存的数据可能不一致。更新cacheline时，要根据dirty位，决定是否将数据写回内存。然后再进行其他操作</p><ul><li><h5 id="dirty-bit"><a href="#dirty-bit" class="headerlink" title="dirty bit"></a>dirty bit</h5></li></ul><p>​在写回的更新策略中，cache命中，首先会更新cacheline的数据，导致内存和cache中数据不一致，当该cache line被替代时，将替换的数据写到内存中。dirty bit是标记要写回到内存的cache line。</p><p><strong>通常写分配和写回策略一起使用</strong></p><hr><h4 id="两路组相连"><a href="#两路组相连" class="headerlink" title="两路组相连"></a>两路组相连</h4><p>将cache平均分成多份，每一份就是一路，两路组相连缓存就是将cache分为2份，每份32Bytes。</p><img src="/2024/022542394/image-20240225153918193.png" alt style="zoom: 33%;"><p>直接映射缓存每个地址只有一个cacheline的tag进行比较。</p><p>index也称为 组索引，相比于直接映射缓存，两路组相连映射缓存的index要少1bit，因为cache的个数少了一半，相当于一个addr地址对应于两个cacheline，然后通过tag比对两次，命中一个即cache命中。</p><p>优点：降低cache的颠簸可能性；<br>缺点：硬件成本高；</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>CPU读cache时</strong></li></ul><p>​若hit，CPU直接从cache读取数据即可<br>​若miss，<br>​Read allocate读分配：先从内存中读取数据到cache，再从cache中读数据。</p><ul><li><strong>CPU写cache时</strong></li></ul><p>​若hit，有两种处理方式<br>​Write thorough：把数据同时更新cache和内存中<br>​Write back ：先更新cacheline数据，被替换时再通过flush方式写入内存</p><p>​若miss，有两种方式<br>​Write allocate：先把数据读取到cache中，更新该cacheline，被替换时再通过flush方式写入内存<br>​No Write allocate：只更新主存数据</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA2.0</title>
      <link href="/2024/022437262.html"/>
      <url>/2024/022437262.html</url>
      
        <content type="html"><![CDATA[<h2 id="AMBA协议"><a href="#AMBA协议" class="headerlink" title="AMBA协议"></a>AMBA协议</h2><p>AHB协议：高性能总线，支持多主机，数据位宽可到32,64,128bit<br>APB协议：接口简单，适合低功耗。</p><ul><li><p>AHB信号说明</p><p>HADDR：地址总线<br>HTRANS[1:0]：传输类型，00：IDLE，01：BUSY，10：NONSEQ，11：SEQ<br>HWRITE：读写使能，高写低读<br>HSIZE[2:0]：描述数据的位宽，协议允许最大1024bit<br>HBURST[2:0]：突发类型，支持单拍传输，4,8,16拍增量、回环传输，以及不定义长度增量传输。（比axi多了不定长传输，少了fixed传输）</p><p>HWDATA：写数据总线</p><p>HSELx：slave选择信号</p><p>HRDATA：读数据总线</p><p>HREADY：传输完成信号，表示总线上的传输已经完成。</p><p>HRESEP：传输响应信号</p></li><li><p>仲裁信号</p><p>HBUSREQx：总线请求信号，master发出，最多16个master<br>HGRANTx：仲裁器发出，目前优先级最高的主机拉高。需要等待当前占用总线的slave传输完成，hready拉高且优先级最高的hgrantx拉高时，才会真正的切换总线 <strong>地址和控制信号</strong> 的所有权。<br>HMASTER[3:0]：仲裁器发出，表示当前哪个master正在占用总线；</p></li><li><p>APB信号</p><p>PADDR：APB地址总线<br>PSELx：从机选择信号<br>PENABLE：APB选通信号<br>PWRITE：读写使能信号，高写低读<br>PRDATA：读数据总线<br>PWDATA：写数据总线</p></li></ul><p><strong>等待状态的传输</strong></p><p>第一个地址周期，必须是从机的HREADY拉高，从机才可以采样到相应的地址和控制信息。后面的数据周期，同样需要从机HREADY拉高时才可以进行下面的操作。</p><img src="/2024/022437262/image-20240224173637302.png" alt="image-20240224173637302" style="zoom: 33%;"><p><strong>多重操作</strong></p><p>整个传输类似两级流水线，第一拍地址，第二拍数据。</p><img src="/2024/022437262/image-20240224174126020.png" alt="image-20240224174126020" style="zoom: 33%;"><ul><li><p><strong>AHB协议中最重要的两个信号：hreadyout和htrans</strong></p><p>隐含握手信号，htrans表示master输出数据的有效性，hreadyout表示slave准备好接收数据。类似axi4的valid和ready。</p><p>htrans：Busy是由于master没准备好，又想要占用总线而插在一个burst中的状态，如果采用了Idle，总线会重新仲裁，master对总线的占用权发生了变化（CPU中可能会出现）；Idle是插在两个burst之间，用来区分两次不同传输。</p></li><li><p>窄传输和宽传输</p><p>窄传输：从机的数据总线位宽 小于 主机的数据总线位宽，需要一定的外部逻辑就可以实现。比如64-&gt;32，通过地址的倒数第3bit选择高32bit还是低32bit给从机数据端口。</p><img src="/2024/022437262/image-20240224185833222.png" alt="image-20240224185833222" style="zoom: 33%;"><p>宽传输：从机的数据总线位宽 大于 主机的数据总线位宽。</p></li></ul><img src="/2024/022437262/image-20240224185855431.png" alt="image-20240224185855431" style="zoom:33%;"><ul><li><p>APB传输协议</p><img src="/2024/022437262/image-20240224191638563.png" alt style="zoom: 33%;"><img src="/2024/022437262/image-20240224192445131.png" style="zoom: 33%;"><img src="/2024/022437262/image-20240224192637732.png" alt="image-20240224192637732" style="zoom:33%;"><p>向apb的slave写数据，过程：首先向bridge写入地址和数据，需要两拍，然后继续向apb的从机写入数据，经过SetUp和Enable状态写入。</p><p>2.0协议中规定apb的slave没有响应信号。</p><p>为什么bridge的第一个写操作后需要等待一个周期，是因为ahb是pipline的，wdata的数据不能和setup同时到达，需要等待一个周期才可，如果是连续的写操作，则不需要这个等待状态。连续写操作不需要等待状态，是因为中间的缓存reg状态已经充满地址了，不需要等待一个周期了。</p></li><li><p>Retry和Split的区别</p><p>Retry和split都是ahb的slave在不能及时响应时发起的，retry后，不会影响此次master的优先级，并且会从头传输上次未传输完成的数据，split后，会影响master的优先级，并且会降低master的优先级，等待split的slave向arbiter发起准备好继续传输后，恢复master的优先级，重要的是恢复后的传输会从的split发生的位置继续传输，而不是从头传输。（在常见的soc系统中，slave的这两种传输一般不会发生）</p></li><li><p>数据和地址对齐</p><p>在APB中，地址和数据位宽是对齐的，如果PRDATA位宽是32bit，则PADDR[1:0]&#x3D;0，AHB中也有此要求，例如HSIZE&#x3D;1时，HADDR[0]&#x3D;0，HSIZE&#x3D;2时，HADDR[1:0] &#x3D; 0；HSIZE&#x3D;3时，HADDR[2:0] &#x3D; 0，以此类推。</p><p>AHB数据位宽最大多少 1024位，APB是32位最大位宽</p></li><li><p>地址越界</p><p>AXI系统中，slave地址空间一般为4KB的整数倍，如果burst传输地址范围超过了4kB就会传输错误。0x01000&#x3D;4KB<br>AHB系统中，salve地址空间一般为1KB的整数倍，如果burst传输地址范围超过了1kB就会传输错误。0x0400 &#x3D; 1KB<br>如果burst超过了4&#x2F;1KB边界，就要重新发起burst传输或者采用其他方式，取决于master行为。</p></li><li><p>AHB总线传输过程中的ERROR分析：</p><img src="/2024/022437262/image-20240224234749434.png" style="zoom: 67%;"><p>在error的倒数第二个周期hready需要拉低，表示不能再接收新的传输了（因为数据A传输过程中出现错误了），最后一个error周期，hready拉高了，（为什么拉高，因为IDLE状态下，不进行数据传输，hready就应该拉高，这是为了和复位时的状态保持一致吧），但是这个时候恢复到了IDLE状态，B的地址还是不能进行传输的，因为只有NONSEQ和SEQ才能进行地址的传输。进而保证了地址B不能进行有效传输。</p></li><li><p>还有一个原因是因为流水线的缘故，T3时刻的地址B已经传到总线上了，这也是为了防止在T3-T4周期，进行无效的数据B传输，所以需要设置为IDLE，而且一定要延迟这一拍，允许主机****有足够的的时间来取消地址B的传输****。（也就是说把地址B从总线上撤下来，或者说起到一个流水线冲刷的作用）</p></li></ul><p><img src="/2024/022437262/wps8.jpg" alt="img"> </p><p>​ERROR传输的两个周期中，第一个周期的hready是拉低的。</p><p>​ERROR的第二个周期，htrans是IDLE的，这种打断在AHB协议上是可以的，但是axi不支持</p><p>​ERROR传输的应用场景：译码错误，当master访问slave不存在的地址时。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总线协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C基础</title>
      <link href="/2024/02248418.html"/>
      <url>/2024/02248418.html</url>
      
        <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>堆栈</li></ul><p>stack堆是操作系统在编译时分配的，有一定的限制，是个定值；<br>heap栈是动态内存，由编程者自行决定；</p><img src="/2024/02248418/wps3.jpg" style="zoom:50%;"><p>eg. 存在函数返回值为指针时，由于返回的是地址，当stack内存被覆盖时，会引起读取数据错误，所以在返回值的地方要申请一块heap内存.</p><img src="/2024/02248418/wps4.jpg" style="zoom:50%;"><p>函数返回值为局部变量时，需要将变量设置为static静态变量，因为执行玩该函数,就会释放内存。如果返回值的是一个地址，那么后面再使用到该地址可能就不对了，因为他已经释放掉了。（static int *Add(int*a, int*b) ）</p><ul><li><p>内存泄露</p><p>内存泄漏指的是申请的动态内存heap，使用结束后没有释放，导致内存不足。</p></li></ul><h3 id="变量指针"><a href="#变量指针" class="headerlink" title="变量指针"></a>变量指针</h3><img src="/2024/02248418/wps1.jpg" style="zoom:50%;"><img src="/2024/02248418/wps2.jpg" alt="img" style="zoom:50%;"><pre class=" language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>c<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只允许读，不允许写</span></code></pre><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">*</span>a <span class="token operator">+</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> sum<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token operator">&amp;</span>add<span class="token punctuation">;</span>    sum <span class="token operator">=</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="static-extern关键字"><a href="#static-extern关键字" class="headerlink" title="static&#x2F;extern关键字"></a>static&#x2F;extern关键字</h2><p>Static可以用来修饰局部变量，保证在规定范围内，变量一直有效；</p><pre class=" language-C"><code class="language-C">#include<stdio.h>void test()&#123;    Static int a = 1;    a++;    printf("%d ", a);&#125;int main(void)&#123;    int i = 0;    while (i <= 10)    &#123;        test();        i++;    &#125;    return 0;&#125;// a的值只在函数内有效// Static修饰局部变量，修改了变量的生命周期，本质上改变了变量的存储范围，变成了静态存储区</code></pre><img src="/2024/02248418/wps6.png" alt="img" style="zoom:50%;"><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>Static修饰全局变量时，其他文件不可以访问该变量。<br>Extern声明的函数和变量，可以被其他文件访问。</p><img src="/2024/02248418/wps7.jpg" alt style="zoom: 67%;"><h2 id="全局结构体变量定义"><a href="#全局结构体变量定义" class="headerlink" title="全局结构体变量定义"></a>全局结构体变量定义</h2><p>​结构体是一种变量类型，最好方式是在.h文件定义，其他地方想用这个结构体，只需包含此.h文件即可，但是定义结构体变量的话，最好在.c文件定义，然后.h里面extern声明，其他.c文件想用只需包含.h文件即可。（为了防止重复定义，所以不建议在.h文件中直接定义变量）</p><pre class=" language-C"><code class="language-C">// a.ctemptype temp1,temp2,temp3;// 必须在函数里面使用才可以// a.htypedef struct &#123;    u8 disp_int;        //整数部分    u8 disp_flo;        //小数部分    u8 disp_flag;       //符号部分&#125;temptype; extern temptype temp1,temp2,temp3;// extern是一种“外部声明”的关键字，字面意思就是在此处声明某种变量或函数，在外部定义。// b.c#include “a.h”u8 data;data = temp1.disp_int;</code></pre><p>函数 extern &#x2F;&#x2F;不使用include</p><pre class=" language-C"><code class="language-C">a.c //定义extern int fun(int a, int b)&#123;    return a + b;&#125;b.c //声明#include<stdio.h>extern int fun(int a, int b);int main()&#123;    int result = fun(1, 3);    return 0;&#125;</code></pre><h2 id="ELF文件解析"><a href="#ELF文件解析" class="headerlink" title="ELF文件解析"></a>ELF文件解析</h2><p>程序中的段和节是真正的程序体，段包括代码段和数据段，多个节经过链接合并成一个段</p><p>段和节的信息都是通过header描述的，程序头是program header， 节头是section header；<br>段和节的大小都是不固定的，需要专门的数据结构来描述，即程序头表（program header table）和节头表（section header table）<br>这是两个数组，程序头表的元素全是程序头，节头表的元素全是节头。<br>程序头表是描述段的。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">get_syscall_name</span><span class="token punctuation">(</span>uintptr_t type<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> SYS_exit  <span class="token punctuation">:</span> <span class="token function">strcpy</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"SYS_exit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> SYS_gettimeofday<span class="token punctuation">:</span><span class="token function">strcpy</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"SYS_gettimeofday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Unhandled syscall"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> name<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>program break 是用户程序的数据段data segment结束的位置，链接的时候ld会默认添加一个名为_end的符号，指示程序的数据段结束位置。用户程序开始运行的时候, program break会位于_end所指示的位置, 意味着此时堆区的大小为0<br>通过访问end的地址即可得到program break，用户程序申请内存时，需要将递增后的program break作为地址传给系统调用，然后返回原来的program地址，供程序使用。</p><h3 id="C语言语法"><a href="#C语言语法" class="headerlink" title="C语言语法"></a>C语言语法</h3><h4 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h4><p><code>##(预处理器粘合剂)</code>：表示连接作用，比如，#define CON(x,y) x##y，表示 x和y接在一起<br><code>变参宏</code> ：比如 #define PR(…)  printf(_<em>VA_ARGS</em>_)</p><h4 id="位结构体"><a href="#位结构体" class="headerlink" title="位结构体"></a>位结构体</h4><p>​实现C中变量长度截断+符号位扩展，code如下</p><pre class=" language-C"><code class="language-C">#define SEXT(x, len) (&#123; struct &#123; int64_t n : len; &#125; __x = &#123; .n = x &#125;; (uint64_t)__x.n; &#125;)#define SEXT(x, len) (&#123;   struct &#123;     int64_t n : len;   &#125; __x = &#123;     .n = x   &#125;;   (uint64_t)__x.n; &#125;)</code></pre><p>可以整理成下面的形式进行分析，首先采用宏定义的形式，#define 关键一句在于‘int64_t n : len 表示只取n的后len位，对应于verilog变量的[len-1:0]位.<br>通过‘(uint64_t)__x.n; ，将len位的数据进行符号位扩展，符号位为n[len-1]的数据。</p><blockquote><p> 如果不采用这种方式进行符号位扩展的话，就会按照最高位为1的进行扩展，得到所有高位都是1，这种并不是我们想要的，比如一个10为的二进制数据：0010010101，扩展成16位，就会得到1111111110010101。这种不是我们要的结果。<br>如果按照上文提供的位结构体实现，就会得到0000000010010101，这才是我们想要的结果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-乘除法器设计</title>
      <link href="/2024/022240394.html"/>
      <url>/2024/022240394.html</url>
      
        <content type="html"><![CDATA[<h2 id="乘法器设计"><a href="#乘法器设计" class="headerlink" title="乘法器设计"></a>乘法器设计</h2><p>本设计采用基于4 Booth和华莱士树乘法器相结合的方式实现乘法；<br>一般乘法运算采用移位累加的方式实现，当乘法位数较大时，组合逻辑很大，且中间结果不易插入寄存器。在本设计的乘法中，<strong>Booth算法减小了部分积的个数，华莱士树算法提高了计算累加和的速度，且可以在中间插入寄存器，进一步提高主频和数据吞吐量</strong></p><h4 id="Booth算法"><a href="#Booth算法" class="headerlink" title="Booth算法"></a>Booth算法</h4><h5 id="booth乘法算法的条件"><a href="#booth乘法算法的条件" class="headerlink" title="booth乘法算法的条件"></a>booth乘法算法的条件</h5><ol><li>乘数和被乘数都是偶数，如果不是需要扩展符号位</li><li>补码运算，如果想要实现无符号数运算，需要在乘数和被乘数前面扩展两个0，然后按照补码运算</li></ol><p>编码的计算需要将乘数后面补0，一次完整的乘法共有N&#x2F;2个码元</p><img src="/2024/022240394/Booth_multiplication with shifter.png" alt="使用移位加实现Booth乘法" style="zoom: 33%;"><h5 id="key-point"><a href="#key-point" class="headerlink" title="key point"></a>key point</h5><ul><li><p>扩展符号位成偶数时，需要根据有无符号位进行扩展，如果是无符号，扩展0，如果有符号位，扩展符号位</p></li><li><p>在进行部分积累加中，每个cycle需要将累加寄存器右移两位，为的是对齐，得到真实的部分和，在下次加法时，保证是对齐的</p></li><li><p>在累加器右移过程中，需要扩展两位符号位，因为右移了2位，在下次操作时就要用到这两位符号位</p></li><li><p>booth两位运算规则</p></li></ul><table><thead><tr><th>yi+1</th><th>yi</th><th>yi-1</th><th>操作</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>+0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>+X补</td></tr><tr><td>0</td><td>1</td><td>0</td><td>+X补</td></tr><tr><td>0</td><td>1</td><td>1</td><td>+2X补</td></tr><tr><td>1</td><td>0</td><td>0</td><td>-2X补</td></tr><tr><td>1</td><td>0</td><td>1</td><td>-X补</td></tr><tr><td>1</td><td>1</td><td>0</td><td>-X补</td></tr><tr><td>1</td><td>1</td><td>1</td><td>+0</td></tr></tbody></table><p>本设计中乘法运算为 64bit * 64bit，booth算法本身是带符号的补码运算，如果要兼容无符号运算，需要在符号位前面扩展1bit，但是算法又规定乘数和被乘数都是偶数，所以还需要扩展1bit 符号位0，总共扩展2bit，exp_B为(66+1)bit，代码如下</p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">assign</span> exp_B <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">1'b0</span><span class="token punctuation">,</span> unsigned_flag<span class="token punctuation">,</span> B<span class="token punctuation">,</span> <span class="token number">1'b0</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最后补0是必须的，unsigned_flag = 1 => 表示无符号运算</span></code></pre><p>按照有符号补码运算，64bit的乘数，产生32个部分积；考虑无符号运算，还需要产生一个部分积，该部分积的产生规则如下：</p><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token keyword">case</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token number">3'b000</span><span class="token punctuation">,</span> <span class="token number">3'b111</span><span class="token punctuation">,</span> <span class="token number">3'b001</span> <span class="token punctuation">:</span>   P <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token number">3'b010</span> <span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>unsigned_flag<span class="token punctuation">)</span> P <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>   P <span class="token operator">=</span> X<span class="token punctuation">;</span>    <span class="token number">3'b110</span><span class="token punctuation">,</span> <span class="token number">3'b101</span> <span class="token punctuation">:</span> P <span class="token operator">=</span> <span class="token operator">~</span>X <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>                                 <span class="token number">3'b011</span> <span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>unsigned_flag<span class="token punctuation">)</span> P <span class="token operator">=</span> X<span class="token punctuation">;</span>            <span class="token keyword">else</span> P <span class="token operator">=</span> X <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token number">3'b100</span> <span class="token punctuation">:</span> P <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>X <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>                                               <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">// 无符号数运算，如果乘数的最高位为0，部分积为0；如果乘数的最高位为1，部分积为被乘数</span></code></pre><p><strong>最后，将部分积进行移位累加即可（每次累加和 移位2bit）</strong></p><h3 id="华莱士树算法"><a href="#华莱士树算法" class="headerlink" title="华莱士树算法"></a>华莱士树算法</h3><p><strong>本质是</strong> <strong>对累加的各个部分积进行压缩，最终压缩到单个C和S，通过加法器计算得到结果</strong></p><h4 id="进位保存加法器"><a href="#进位保存加法器" class="headerlink" title="进位保存加法器"></a><strong>进位保存加法器</strong></h4><ul><li>CAS （carry save adder）</li></ul><p>基本思想：将3个加数和减少为2个加数的和，将进位C和结果S分别计算保存，每个比特可以独立计算C和S，速度极快，一位的全加器相当于进位保留加法器 &#x3D;&gt; 3:2 压缩器。</p><p>比如一个算式如：Sum &#x3D; A + B + C + D，可以设计N bit的CAS结构，将多个数合并，经过两级CSA，最后将进位C[N-1:0]和Sum[N-1:0]通过一个加法器相加（<strong>注意将进位传给下面的CAS计算时，需要将C左移一位</strong>），得到最终结果。</p><img src="/2024/022240394/2.8_walloc_tree.4b50192e.png" alt style="zoom: 67%;"><p>上图是17bit的华莱士树，因为进位和输出结果都是同一个方向的，所以可以在每层之间插入寄存器打拍，提高主频。</p><p>相同bit的华莱士树有多种实现方式，如下图所示</p><img src="/2024/022240394/WORONG_exaxple of walllace tree.png" alt="两种错误的8个数相加的一位华莱士树" style="zoom: 33%;"><p>完成的功能相同，但是两者之间存在区别。<strong>关键点在于延迟</strong>，假设每个CSA部件的延迟为1，左面结构的结果延迟为5，右面为4。左面结构插入寄存器时，就会导致结果错误。</p><img src="/2024/022240394/image-20230811215003860.png" alt style="zoom: 33%;"><p>在设计华莱士树时，<strong>保证华莱士树的数据流是单向的，不会在该层之前进行操作，比如左图的进位C3，导致整个数据流发生了交叠</strong>。</p><h3 id="Booth算法×华莱士树算法"><a href="#Booth算法×华莱士树算法" class="headerlink" title="Booth算法×华莱士树算法"></a>Booth算法×华莱士树算法</h3><p>32位的乘法器结构如下，其中Switch模块完成将booth模块输出的结果打一拍，避免组合逻辑的延迟较长。</p><img src="/2024/022240394/image-20240222231842246.png" alt style="zoom: 33%;"><p>其中，booth输出的部分积，需要进行移位加才能进入到CSA模块中。代码如下</p><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// phase 1</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_1<span class="token punctuation">,</span> S1_1<span class="token punctuation">,</span> S2_1<span class="token punctuation">,</span> S3_1<span class="token punctuation">,</span> S4_1<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> C0_1<span class="token punctuation">,</span> C1_1<span class="token punctuation">,</span> C2_1<span class="token punctuation">,</span> C3_1<span class="token punctuation">,</span> C4_1<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa1</span><span class="token punctuation">(</span>in0<span class="token punctuation">,</span> in1<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">,</span> in2<span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">,</span> S0_1<span class="token punctuation">,</span> C0_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa2</span><span class="token punctuation">(</span>in3<span class="token operator">&lt;&lt;</span><span class="token number">6</span><span class="token punctuation">,</span> in4<span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">,</span> in5<span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">,</span> S1_1<span class="token punctuation">,</span> C1_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa3</span><span class="token punctuation">(</span>in6<span class="token operator">&lt;&lt;</span><span class="token number">12</span><span class="token punctuation">,</span> in7<span class="token operator">&lt;&lt;</span><span class="token number">14</span><span class="token punctuation">,</span> in8<span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">,</span> S2_1<span class="token punctuation">,</span> C2_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa4</span><span class="token punctuation">(</span>in9<span class="token operator">&lt;&lt;</span><span class="token number">18</span><span class="token punctuation">,</span> in10<span class="token operator">&lt;&lt;</span><span class="token number">20</span><span class="token punctuation">,</span> in11<span class="token operator">&lt;&lt;</span><span class="token number">22</span><span class="token punctuation">,</span> S3_1<span class="token punctuation">,</span> C3_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa5</span><span class="token punctuation">(</span>in12<span class="token operator">&lt;&lt;</span><span class="token number">24</span><span class="token punctuation">,</span> in13<span class="token operator">&lt;&lt;</span><span class="token number">26</span><span class="token punctuation">,</span> in14<span class="token operator">&lt;&lt;</span><span class="token number">28</span><span class="token punctuation">,</span> S4_1<span class="token punctuation">,</span> C4_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// phase 2</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> C0_2<span class="token punctuation">,</span> C1_2<span class="token punctuation">,</span> C2_2<span class="token punctuation">,</span> C3_2<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_2<span class="token punctuation">,</span> S1_2<span class="token punctuation">,</span> S2_2<span class="token punctuation">,</span> S3_2<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa6</span><span class="token punctuation">(</span>S0_1<span class="token punctuation">,</span> S1_1<span class="token punctuation">,</span> S2_1<span class="token punctuation">,</span> S0_2<span class="token punctuation">,</span> C0_2<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa7</span><span class="token punctuation">(</span>S3_1<span class="token punctuation">,</span> S4_1<span class="token punctuation">,</span> in15<span class="token operator">&lt;&lt;</span><span class="token number">30</span><span class="token punctuation">,</span> S1_2<span class="token punctuation">,</span> C1_2<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa8</span><span class="token punctuation">(</span><span class="token punctuation">(</span>C0_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C2_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S2_2<span class="token punctuation">,</span> C2_2<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa9</span><span class="token punctuation">(</span><span class="token punctuation">(</span>C3_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C4_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> in16<span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">,</span> S3_2<span class="token punctuation">,</span> C3_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// phase 3</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_3<span class="token punctuation">,</span> C0_3<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S1_3<span class="token punctuation">,</span> C1_3<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa10</span><span class="token punctuation">(</span>S0_2<span class="token punctuation">,</span> S1_2<span class="token punctuation">,</span> S2_2<span class="token punctuation">,</span> S0_3<span class="token punctuation">,</span> C0_3<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa11</span><span class="token punctuation">(</span>S3_2<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S1_3<span class="token punctuation">,</span> C1_3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// phase 4</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_4<span class="token punctuation">,</span> C0_4<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S1_4<span class="token punctuation">,</span> C1_4<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa12</span><span class="token punctuation">(</span>S0_3<span class="token punctuation">,</span> S1_3<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_3 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S0_4<span class="token punctuation">,</span> C0_4<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa13</span><span class="token punctuation">(</span><span class="token punctuation">(</span>C2_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C3_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_3 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S1_4<span class="token punctuation">,</span> C1_4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// phase 5</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_5<span class="token punctuation">,</span> C0_5<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa14</span><span class="token punctuation">(</span>S0_4<span class="token punctuation">,</span> S1_4<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_4 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S0_5<span class="token punctuation">,</span> C0_5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// phase 6</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa15</span><span class="token punctuation">(</span>S0_5<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_5 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_4 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> OUT <span class="token operator">=</span> S <span class="token operator">+</span> <span class="token punctuation">(</span>C <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="除法器设计"><a href="#除法器设计" class="headerlink" title="除法器设计"></a>除法器设计</h2><p>被除数Dividend &#x2F; 除数Divisor &#x3D; 商Quotient ······ 余数Remainder</p><p>简单的迭代除法是 <strong>试商法</strong>，迭代过程中，如果不够减，商0，根据是否恢复余数，分为恢复余数法（循环减法）、不恢复余数法（加减交替）。</p><p><strong>区别</strong>：逐位计算商的时候，不够减商0；如果是恢复余数算法，需要将余数加上除数；如果是不恢复余数算法，不需要加上余数，在下个周期时加上除数。</p><h3 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h3><p>64bit 绝对值 恢复余数除法运算结构如下</p><img src="/2024/022240394/image-20240223154401784.png" alt style="zoom:50%;"><p>优点：面积小，节省资源。缺点：速度慢</p><p>计算过程：被除数前面补64个0，记为A，除数为B，每个周期执行减法运算，判断ALU输出的符号，如果为负，寄存器A左移1bit且右面补0，不需要将ALU结果写入寄存器A；如果为正，寄存器A左移1bit，右面补1，将ALU计算结果写入寄存器A的高64位；以此类推，经过64个周期，从寄存器A中得到商和余数。最终，根据是否是 有符号计算，对输出结果进行处理。</p><p>其中，ALU采用补码进行减法运算。**[X - Y]补 &#x3D; [X]补 + [-Y]补**，  <strong>[-Y]补 &#x3D; [Y]补码 取反 + 1</strong></p><p>如果要同时支持无符号和有符号除法运算，需要对输入的数据进行预处理。根据被除数和除数的符号，决定 <strong>商和余数的符号</strong>；将有符号除法转换成无符号除法。</p><table><thead><tr><th align="center">被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td align="center">正</td><td>正</td><td>正</td><td>正</td></tr><tr><td align="center">正</td><td>负</td><td>负</td><td>正</td></tr><tr><td align="center">负</td><td>正</td><td>负</td><td>负</td></tr><tr><td align="center">负</td><td>负</td><td>正</td><td>负</td></tr></tbody></table><pre class=" language-verilog"><code class="language-verilog">    <span class="token keyword">assign</span> dividend_unsigned <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                                dividend<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">?</span>                               <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">1'b0</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">~</span>dividend<span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span> <span class="token punctuation">:</span> dividend                                <span class="token punctuation">:</span> dividend<span class="token punctuation">;</span>    <span class="token keyword">assign</span> divisor_unsigned <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                               divisor<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">?</span>                              <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">1'b0</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">~</span>divisor<span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span> <span class="token punctuation">:</span> divisor                              <span class="token punctuation">:</span> divisor<span class="token punctuation">;</span>    <span class="token keyword">assign</span> merchant   <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                         <span class="token punctuation">(</span>dividend<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">^</span> divisor<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span>                        <span class="token operator">-</span>merchant_t <span class="token punctuation">:</span> merchant_t                        <span class="token punctuation">:</span> merchant_t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最后一次商结果作为最终的商</span>    <span class="token keyword">assign</span> remainder  <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                         dividend<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">?</span>                         <span class="token operator">-</span>remainder_t <span class="token punctuation">:</span> remainder_t                        <span class="token punctuation">:</span> remainder_t<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最后一次余数作为最终的余数</span></code></pre><h2 id="乘除法器-接入流水线CPU"><a href="#乘除法器-接入流水线CPU" class="headerlink" title="乘除法器 接入流水线CPU"></a>乘除法器 接入流水线CPU</h2><p>乘除法器都是多个周期才出结果，因此，需要握手信号。当乘除法指令到执行阶段时，Div&#x2F;Mul模块发出stall信号，等待valid和ready信号握手，输出计算结果，撤销stall信号，继续执行后续指令。</p><img src="/2024/022240394/image-20240222232209980.png" alt style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-Cache设计（三）</title>
      <link href="/2024/022113792.html"/>
      <url>/2024/022113792.html</url>
      
        <content type="html"><![CDATA[<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><h4 id="Fence指令"><a href="#Fence指令" class="headerlink" title="Fence指令"></a>Fence指令</h4><p>在前续集合predecessor执行到FENCE指令前的任何操作前，处于FENCE指令后的后续集合（successor）中的任何操作，都不能被其他任何RISC-V线程或者外部设备看到。即FENCE就像一个栅栏，FENCE之前所有的存储器操作、IO操作必须完成后，在FENCE指令之后的指令才能看到结果。 </p><h4 id="fence-i"><a href="#fence-i" class="headerlink" title="fence.i"></a>fence.i</h4><p>原因：store指令可能会对内存中的程序区进行修改，而icache可能看不到程序的修改，而读取错误的指令，导致程序运行错误。<br>目的：为了解决数据与指令的一致性问题，即icache和dcache的一致性。当执行fence.i指令时，fence之前的所有存储操作，io操作必须完成后，fence指令后面的指令才能访问内存。</p><h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><p>译码阶段遇到fence.i指令，icache和dcache的具体操作：</p><ol><li>对icache中的cachemem进行刷新，完成初始化，保证后面的所有取指令操作都是从内存中获取。</li><li>对dcache中cachemem的所有dirty置1的cacheline写到内存中，保证内存中代码区和数据区的一致性。</li></ol><h3 id="icache"><a href="#icache" class="headerlink" title="icache"></a>icache</h3><p>fence模块发出flash，stall和nop使能信号，将取指令的pc地址保持不变，将进入if阶段的fence指令通过nop冲刷掉，也就是说icache的cachemem一个周期就要完成冲刷。</p><img src="/2024/022113792/image-20240222105149731.png" alt style="zoom:50%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    flash <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>fence_i<span class="token punctuation">)</span>    flash <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>flash_done<span class="token punctuation">)</span>    flash <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> stall <span class="token operator">=</span> flash <span class="token operator">|</span> fence_i<span class="token punctuation">;</span><span class="token keyword">assign</span> nop <span class="token operator">=</span> stall<span class="token punctuation">;</span></code></pre><h3 id="dcache"><a href="#dcache" class="headerlink" title="dcache"></a>dcache</h3><p>设置FLASH和FLASH_DONE状态，等待到fence.i指令流水到访存阶段，进入FLASH状态，遍历所有cacheline，将所有脏（dirty）块写到内存中；cachesize为4k，cacheline为8byte，共需要进行512次写数据传输，判断dirty位是否为1，并通过wstrb确定有效字节，将wdata写入内存。</p><p>遍历结束后，flash_finish拉高，进入FLASH_DONE状态，拉高flash_done，pc重新从内存中取指令，流水线继续执行，完成了指令和数据的一致性。</p><img src="/2024/022113792/image-20240222112053777.png" alt style="zoom: 50%;"><img src="/2024/022113792/image-20240226100157943.png" alt style="zoom:50%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        IDLE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> flash <span class="token operator">?</span> FLASH <span class="token punctuation">:</span>                            <span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> dirty <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> WRITEBACK <span class="token punctuation">:</span>                            <span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> RADDR <span class="token punctuation">:</span> IDLE<span class="token punctuation">;</span>        WRITEBACK <span class="token punctuation">:</span> next_state <span class="token operator">=</span> WADDR<span class="token punctuation">;</span>        ALLOCATE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>        RADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_arvalid <span class="token operator">&amp;&amp;</span> axi_arready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>        RDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_rvalid  <span class="token operator">&amp;&amp;</span> axi_rready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> ALLOCATE<span class="token punctuation">;</span>        WADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_awvalid <span class="token operator">&amp;&amp;</span> axi_awready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> WDATA<span class="token punctuation">;</span>        WDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_wvalid  <span class="token operator">&amp;&amp;</span> axi_wready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> WRESP<span class="token punctuation">;</span>        WRESP <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_bvalid  <span class="token operator">&amp;&amp;</span> axi_bready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> <span class="token punctuation">(</span>flash_flag <span class="token operator">&amp;&amp;</span> flash_finish<span class="token punctuation">)</span> <span class="token operator">?</span> FLASH_DONE                                                 <span class="token punctuation">:</span> flash_flag <span class="token operator">?</span> WADDR                                                 <span class="token punctuation">:</span> RADDR<span class="token punctuation">;</span>        FLASH <span class="token punctuation">:</span> next_state <span class="token operator">=</span> WADDR<span class="token punctuation">;</span>        FLASH_DONE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    flash_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>state <span class="token operator">==</span> WDATA<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>axi_wready<span class="token operator">&amp;&amp;</span>axi_wready<span class="token operator">&amp;&amp;</span>flash_flag<span class="token punctuation">)</span>    flash_cnt <span class="token operator">&lt;=</span> flash_cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>     flash_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    flash_finish <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>flash_flag <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>flash_cnt <span class="token operator">==</span> CACHE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>    flash_finish <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>     flash_finish <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    flash_flag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>state <span class="token operator">==</span> FLASH_DONE<span class="token punctuation">)</span>    flash_flag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>state <span class="token operator">==</span> FLASH<span class="token punctuation">)</span>    flash_flag <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> axi_wstrb  <span class="token operator">=</span> <span class="token punctuation">(</span>flash_flag<span class="token operator">&amp;</span>dirty<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b11111111</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>flash_flag<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b0000_0000</span> <span class="token punctuation">:</span> byte_enable<span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分频器设计</title>
      <link href="/2024/022118538.html"/>
      <url>/2024/022118538.html</url>
      
        <content type="html"><![CDATA[<p>分频器主要有以下几种设计</p><ol><li>偶分频（50%占空比）</li><li>奇分频（非50%占空比）</li><li>奇分频（50%占空比）</li><li>半整数（x.5）分频（非50%占空比）</li><li>任意小数分频（非50%占空比）</li></ol><h3 id="1-偶分频（50-占空比）"><a href="#1-偶分频（50-占空比）" class="headerlink" title="1. 偶分频（50%占空比）"></a>1. 偶分频（50%占空比）</h3><p>假设偶分频系数为N， 共有两种方式实现50%的偶分频。<br>方式1：计数到 N&#x2F;2-1，将clk_out翻转。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span>posedeg clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;=</span> N<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        clkout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> N<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        clkout <span class="token operator">&lt;=</span> <span class="token operator">~</span>clkout<span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方式2：计数到N-1，小于 N&#x2F;2 - 1，clkout输出0，否则输出1；(可实现不同占空比)</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        clk_out <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;=</span> N<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        clk_out <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_out <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-奇分频（非50-占空比）"><a href="#2-奇分频（非50-占空比）" class="headerlink" title="2. 奇分频（非50%占空比）"></a>2. 奇分频（非50%占空比）</h3><p>不需要使用双边沿逻辑，和偶分频的第二种方式类似。</p><h3 id="3-奇分频（50-占空比）"><a href="#3-奇分频（50-占空比）" class="headerlink" title="3. 奇分频（50%占空比）"></a>3. 奇分频（50%占空比）</h3><p>假设实现7分频时钟，需要3个完整周期+半个周期的电平翻转，可以通过两个3分频时钟 or 在一起得到，两个时钟相差半个周期，通过上升沿和下降沿触发得到。</p><p>需要双边沿逻辑；假设实现占空比50%的5分频，实现方法：</p><ol><li>采用正沿和负沿分别实现5分频</li><li>占空比为（5-1）&#x2F;2个源时钟周期</li><li>正沿和负沿产生的时钟信号做 <strong>或</strong></li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> Odd_div_50p #<span class="token punctuation">(</span>    <span class="token keyword">parameter</span> N <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk_in<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>        <span class="token keyword">output</span>      clk_out <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> clk_pos<span class="token punctuation">,</span> clk_neg<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt_pos<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt_neg<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        cnt_pos <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_pos <span class="token operator">==</span> N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cnt_pos <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        cnt_pos <span class="token operator">&lt;=</span> cnt_pos <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        cnt_neg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_neg <span class="token operator">==</span> N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cnt_neg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        cnt_neg <span class="token operator">&lt;=</span> cnt_neg <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment">// clk_pos clk_neg</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_pos <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_neg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> clk_out <span class="token operator">=</span> clk_pos <span class="token operator">|</span> clk_neg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-半整数（x-5）分频（非50-占空比）"><a href="#4-半整数（x-5）分频（非50-占空比）" class="headerlink" title="4. 半整数（x.5）分频（非50%占空比）"></a>4. 半整数（x.5）分频（非50%占空比）</h3><p>假设实现3.5分频，正沿计数器循环计数到7，分别交替产生分频比为4和3的时钟信号，平均下来得到的时钟信号为（4+3）&#x2F; 2 &#x3D; 3.5分频。但是每个分频时钟不是严格的3.5分频。<strong>因此，需要对不均匀的分频比进行调整，采用负沿计数器计数到7，分别交替产生分频比为3和4的时钟信号</strong>，将正沿和负沿产的时钟信号做 <strong>与</strong>操作，得到均匀的3.5分频的时钟信号。</p><img src="/2024/022118538/image-20240221164423487.png" alt style="zoom:67%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> Half_Int_div #<span class="token punctuation">(</span>    <span class="token keyword">parameter</span> N <span class="token operator">=</span> <span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>           clk_in<span class="token punctuation">,</span>    <span class="token keyword">input</span>           nrst<span class="token punctuation">,</span>    <span class="token keyword">output</span>          clk_out                      <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">localparam</span> Naddp5 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> Nsubp5 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pos_vth<span class="token punctuation">,</span> neg_vth<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pos_cnt<span class="token punctuation">,</span> neg_cnt<span class="token punctuation">;</span><span class="token keyword">reg</span> clk_pos<span class="token punctuation">,</span> clk_neg<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        pos_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>pos_cnt <span class="token operator">&lt;=</span> pos_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        pos_cnt <span class="token operator">&lt;=</span> pos_cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         pos_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         pos_vth <span class="token operator">&lt;=</span> Naddp5<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>pos_cnt <span class="token operator">==</span> pos_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>pos_vth <span class="token operator">==</span> Naddp5<span class="token punctuation">)</span>            pos_vth <span class="token operator">&lt;=</span> Nsubp5<span class="token punctuation">;</span>        <span class="token keyword">else</span>            pos_vth <span class="token operator">&lt;=</span> Naddp5<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>pos_cnt <span class="token operator">==</span> <span class="token number">'h0</span><span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        neg_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>neg_cnt <span class="token operator">&lt;=</span> neg_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        neg_cnt <span class="token operator">&lt;=</span> neg_cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         neg_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         neg_vth <span class="token operator">&lt;=</span> Nsubp5<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>neg_cnt <span class="token operator">==</span> neg_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>neg_vth <span class="token operator">==</span> Nsubp5<span class="token punctuation">)</span>            neg_vth <span class="token operator">&lt;=</span> Naddp5<span class="token punctuation">;</span>        <span class="token keyword">else</span>            neg_vth <span class="token operator">&lt;=</span> Nsubp5<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>neg_cnt <span class="token operator">==</span> <span class="token number">'h0</span><span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> clk_out <span class="token operator">=</span> clk_pos <span class="token operator">|</span> clk_neg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-任意小数分频（非50-占空比）"><a href="#5-任意小数分频（非50-占空比）" class="headerlink" title="5. 任意小数分频（非50%占空比）"></a>5. 任意小数分频（非50%占空比）</h3><p>同样不能做到50%的占空比。基于可变分频和平均分频得到，在长时间内，得到小数分频比。<br>比如7.6分频，保证76个源时钟周期时间内，目的时钟经过10个周期的时间。即对源时钟进行 <strong>6次8分频，4次7分频（6*8+4*7&#x3D;76）。</strong>5.76分频，对源时钟进行 <strong>76次6分频，24次5分频</strong></p><p>以 7.6 倍分频为例，7 分频和 8 分频的实现顺序一般有以下 4 种：</p><p>(1) 先进行 4 次 7 分频，再进行 6 次 8 分频；<br>(2) 先进行 6 次 8 分频，再进行 4 次 7 分频；<br>(3) 将 4 次 7 分频平均的插入到 6 次 8 分频中；<br>(4) 将 6 次 8 分频平均的插入到 4 次 7 分频中。</p><p>前两种方法时钟频率不均匀，相位抖动较大，所以一般会采用后两种平均插入的方法进行小数分频操作。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC_FLOW(一)</title>
      <link href="/2024/02206923.html"/>
      <url>/2024/02206923.html</url>
      
        <content type="html"><![CDATA[<h2 id="工艺库文件解读"><a href="#工艺库文件解读" class="headerlink" title="工艺库文件解读"></a>工艺库文件解读</h2><p>以90nm为例，常见的文件夹如下</p><img src="/2024/02206923/image-20240309145119997.png" alt="image-20240309145119997" style="zoom: 33%;"><p>cel：存放spice网表<br>    <img src="/2024/02206923/image-20240309145242615.png" alt="image-20240309145242615" style="zoom: 15%;"></p><p>打开其中一个，找到INV的网表如下，可以看出是spice格式的，l&#x3D;0.1u，表示的是90nm的工艺(特征尺寸）</p><p><img src="/2024/02206923/image-20240309145339988.png" alt="image-20240309145339988"></p><p>INVX1,2,4,8,16,32  X后面的数据表示驱动能力，描述的是signal上升和下降速度。不同的数字电路结构是有区别的，m表示并联管子的个数，w l相同，m越大，驱动能力越强。或者通过调整w的大小，描述不同的驱动能力。</p><p>ULVT: 极低阈值电压</p><p>LVT: 低阈值电压</p><p>SVT(RVT): 常规的阈值电压</p><p>HVT：高阈值电压</p><p>EHVT：极高阈值电压</p><p>阈值电压高，leakage功耗小，速度慢。</p><p>40G 40LP 40ULP 描述的不同的功耗</p><ul><li>db</li></ul><p>db文件夹的东西是给DC读，不给人读。由lib可转换而来</p><img src="/2024/02206923/image-20240309145449601.png" alt="image-20240309145449601" style="zoom: 25%;"><p>其中，ff，ss，tt表示不同工艺角 (p是point)  PVT对应不同条件</p><p>可以看书有2个ff工艺角，工作环境：1.32v，125度；1.32v，-40度</p><p>2个ss工艺角，工作环境：1.08v，125度；1.08v，-40度</p><p>1个tt工艺角，工作环境：1.20v，25度</p><p>1P3M_8K表示1层ploy，3层金属，最高层金属的厚度是8K</p><p>ffg_cbest_min 描述工艺参数，min表示快的逻辑，hold time；c电容最好；</p><p>Lib中包含了工艺库中标准单元的时序、面积、功耗信息，通过查找表的方式实现的，即通过输入转换时间和输出负载电容找的对应的信息，</p><img src="/2024/02206923/image-20240309145628255.png" alt="image-20240309145628255" style="zoom: 25%;"><p>INVX1的时序信息</p><img src="/2024/02206923/image-20240309145659989.png" alt="image-20240309145659989" style="zoom: 25%;"><p>如何定义电路中一个反向器的延迟？是通过查表实现，由输入转换时间和输出负载电容决定。</p><p>这里有一个DRC的概念，即max_transition, max_capacitance, max_fanout, 限制了查找表的两个维度，transition_time和最大load_cap。如果电路中出现了非查找表上的数据，通过内插或者外插的方式得到，为什么要设置DRC呢，是因为超过这个限制，得到的PPA就会失真，与实际得到的结果相差很大。</p><ul><li>GDS</li></ul><p>gds    保存着标准单元库的详细版图文件</p><img src="/2024/02206923/image-20240309145822475.png" alt="image-20240309145822475" style="zoom: 50%;"><img src="/2024/02206923/image-20240309145834084.png" alt="image-20240309145834084" style="zoom:50%;"><p>上面是VCC电源电压，下面是地VSS</p><p>所有的标准单元有一个共同特点是height相同，在芯片同一个track中，只能采用相同height的SC，可以划定不同区域采用不同height的SC，比如有SC7,SC9，height高的唯一好处是速度快，但是功耗大，面积大。</p><p>Lef   描述SC的简略信息，是GDS的子集，简化版本</p><p>GDS记录了芯片制造过程中的每一层尺寸信息和规则，在pr中不需要这么多信息，所以进行了简化，LEF文件主要记录的是金属层的信息。定义了SC的尺寸，位置等。</p><img src="/2024/02206923/wps2.jpg" alt="img" style="zoom: 50%;"><p>​<img src="/2024/02206923/wps3.jpg" alt="img" style="zoom: 67%;"> </p><p>Verilog       描述了SC的rtl模型，里面包含了各种原语（UDP）操作</p><p><img src="/2024/02206923/wps6.jpg" alt="img"></p><p><img src="/2024/02206923/wps7.jpg" alt="img"> </p><img src="/2024/02206923/wps8.jpg" alt="img" style="zoom: 80%;"> <p>需要注意的是 specify的概念，定义延迟路径的延迟大小，这里有两个延迟时间，一个快，一个慢。在延迟反标做后仿时需要注意这点。</p><img src="/2024/02206923/image-20240309150126225.png" alt="image-20240309150126225" style="zoom:67%;"><h2 id="dc-topo模式"><a href="#dc-topo模式" class="headerlink" title="dc_topo模式"></a>dc_topo模式</h2><p>dc_topo模式 指 在综合时考虑物理约束，需要ICC阶段生成的def文件，milkway和工艺文件tf。DEF文件只有物理信息，没有timing信息，流程如下：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> dct生成一版网表netlist，给ICC，导出floorplan的DEF文件<span class="token list punctuation">2.</span> 根据icc导出的def文件，作为DC的物理约束，在dct模式下综合，得到的网表更准确<span class="token list punctuation">3.</span> compile_ultra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">dc_shell <span class="token operator">-</span>topo <span class="token operator">-</span>f run.tcl <span class="token operator">|</span> tee <span class="token operator">-</span>i run.log  <span class="token comment">#   | tee -i dc.log, 将dc运行结果写入指定日志文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2024/02206923/image-20240220161903358.png" alt style="zoom: 50%;"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; icc 写def 命令write_def -output name.def&#x2F;&#x2F; dct 读def命令extract_physical_constraints name.def<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项：第一次时，topo模式需要创建milkway，第二次进入dct模式时，已经有def文件，但是不需要创建milkway库，直接打开就可以</strong></p><h2 id="DC前期环境配置"><a href="#DC前期环境配置" class="headerlink" title="DC前期环境配置"></a>DC前期环境配置</h2><p>ddc是专用的二进制设计数据库格式，可以被ICC、PT读取；<br>工艺库中的db库给dc读的，lib是给人看的。</p><p>synthetic_library是DC软件提供的库；design ware library中有一些优化的ip核，在优化时被调用。</p><p>link library 中， * 代表DC Memory 内存空间；<br>在link前需要指明当前current_design<br>link后要check_design 检查是否有丢失的pins和没有添加进来的实例。</p><ul><li><p>读取设计文件<br>analyze elaborate，elaborate 是唯一一种可以指明代码中参数的方式。-parameter “ xxx”<br>read_verilog命令会生成“GETCH”库中unmapped的ddc格式的文件</p></li><li><p>工艺库</p></li></ul><img src="/2024/02206923/image-20240305004108655.png" alt="image-20240305004108655" style="zoom:50%;"><p>Reference library：包括cell的尺寸和管脚的位置，就是milkway 库。milkway物理库中有不同的view：</p><ol><li>cel：整个版图视图，布局布线完成后被使用，生成最后的GDSII文件</li><li>fram：对于ICC和DC-topo使用的抽象视图，仅用于布局布线的最小数据。</li><li>lm（逻辑库）：具有时序和功耗相关的逻辑库，被icc和dc_topo使用。</li></ol><p>designware library是synopsys库，综合库，默认的标准 Designware 由 DC 软件商提供，无需指定。里面</p><p>GDS可以产生CEL，LEF可以产生FRAM，不能产生CEL，用LEF做的FRAM出gds后，需要到virtuoso中或者calibre中merge gds得到完整的gds再去做DRC&#x2F;LVS</p><p>Technology file：定义了布线层，过孔，DRC的规则，金属和过孔的电学特性参数</p><p>TLUPlus file：寄生参数rc模型，rc参数查找表</p><p>Layer Mapping File：匹配不同名称的相同图层，匹配tf和tluplus文件</p><img src="/2024/02206923/image-20240305004609790.png" alt="image-20240305004609790" style="zoom: 67%;"><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><ol><li><p>标准单元输出信号的延迟取决于 输入转换时间input_transition和输出负载output load；</p></li><li><p>如果设计中只有一个路径，如果关键路径无法优化，dc give up it，会导致其他less critical path也无法优化。</p></li><li><p>做静态时序分析时，路径的起点可以是input port，clock pin，存储器的输出，路径的终点可以是寄存器D，output port，存储器的输入port。</p></li><li><p>在工艺库的查找表中，如果输入的约束在范围内，做内插；如果超过范围做外插（表破了），影响仿真结果。</p></li><li><p>在先进制程工艺的工艺库中，存在INV和CLKINV两种不同的反相器，CLKINV的N管的W要小一些，是因为保证时钟信号上升和下降的时间均衡（tphl&#x3D;tplh），便于静态时序分析,PMOS的w大概是NMOS的2.7倍左右。</p></li><li><p>在DC综合后，会生成sdf文件（带有实际电路门级网表路径延迟的信息），将sdc文件反标在上述的verilog模型中，得到具有延迟信息的电路，利用verilog和sdf文件可以在Vcs&#x2F;Verdi仿真结果可以看出延迟信息。一个sdf文件对应一个corner。</p></li><li><p>DC是如何计算三个反相器串联的总延迟？第一个反相器的延迟，是第二个反相器的transition，电容由电路结构确定，根据查表依次进行，得到三个反相器串联的总延迟。</p></li></ol><img src="/2024/02206923/image-20240309144041702.png" alt="image-20240309144041702" style="zoom:50%;"><img src="/2024/02206923/image-20240309144202884.png" alt="image-20240309144202884" style="zoom:50%;"><p>​那么串联的电路DC又如何计算延迟呢？<br>​第一个反相器的A输入到最后输出，会有很多种可能的时间，DC会把所有的延迟计算出来，最长的时间用于setup时间的检查，最短的路径时间用于hold时间检查。这里就引申出静态时序分析STA的概念。在电路没有工作的时候，把所有的情况计算出来，进行setup&#x2F;hold time检查。</p><img src="/2024/02206923/image-20240309144231306.png" alt="image-20240309144231306" style="zoom:50%;"><ol start="8"><li><p>setup time &#x2F; hold time计算</p><img src="/2024/02206923/wps1.jpg" alt="img" style="zoom:50%;"><p>1 2 3 max  4 5 min &#x3D;&gt; 检查setup time  1+2+3 -（4+5）&lt; Tcycle</p><p>1 2 3 min  4 5 max &#x3D;&gt; 检查hold time   1+2+3 &gt; 4+5</p><p>6属于common path，如果两个寄存器是同沿触发，则6不起作用，被抵消，如果是不同沿触发，要看沿的指向（不同沿的延迟是不一样的，需要分开算）</p><p>在ICC&#x2F;PT中，有相关命令考虑common path。当做STA时，common path会导致发射路径和捕获路径的计算cell的delay不一样，为了消除这种悲观情况，引入CRPR，也叫cppr，依次抹平common path的差异。</p></li><li><p>Verilog RTL代码读入后，生成的gtech文件，是未映射到具体工艺的，GTECH.db是DC软件自带的库，不是dw。</p></li><li><p>DC综合过程</p></li></ol><p>   ①翻译（转换）：将RTL转换成门级网表</p><p>   ②逻辑优化</p><p>   ③映射：映射到具体的工艺库</p><ol start="11"><li>level shifter作为stdcel，在lib中，同样具有相同的track，L2H level shifter需要两个电压，另外一个电压端口作为输入端口接到stdcel上。</li><li>降低功耗可以从以下角度考虑</li></ol><ul><li>降低时钟翻转带来的动态功耗</li><li>门级电路优化</li><li>静态多电压技术、多阈值标准单元</li></ul><h2 id="环境约束"><a href="#环境约束" class="headerlink" title="环境约束"></a>环境约束</h2><h3 id="工作条件"><a href="#工作条件" class="headerlink" title="工作条件"></a>工作条件</h3><p>设置工作条件：<code>set_operating_conditions</code>，用来描述设计的工艺、电压、温度。PVT</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl"><span class="token punctuation">[</span><span class="token operator">-</span>library lib_name<span class="token punctuation">]</span>     <span class="token comment">#指定工艺库</span><span class="token punctuation">[</span><span class="token operator">-</span>analysis_type<span class="token punctuation">]</span>    <span class="token comment">#应执行的分析类型，最慢，最快，基于芯片变异性的延迟</span><span class="token punctuation">[</span><span class="token operator">-</span>max max_condition<span class="token punctuation">]</span><span class="token comment">#该工作点应考虑执行最慢的分析，如-max WCMIL</span><span class="token punctuation">[</span><span class="token operator">-</span>min min_condition<span class="token punctuation">]</span><span class="token comment">#该工作点应考虑执行最快的分析，如-min BCIND</span><span class="token punctuation">[</span><span class="token operator">-</span>max_library max_lib<span class="token punctuation">]</span><span class="token comment">#指定最慢的库</span><span class="token punctuation">[</span><span class="token operator">-</span>min_library min_lib<span class="token punctuation">]</span><span class="token comment">#指定最快的库</span><span class="token punctuation">[</span><span class="token operator">-</span>object_list objects<span class="token punctuation">]</span><span class="token comment">#设计对象，通常为整个设计，故很少使用</span><span class="token punctuation">[</span>condition<span class="token punctuation">]</span><span class="token comment">#工作条件 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线负载模型"><a href="#线负载模型" class="headerlink" title="线负载模型"></a>线负载模型</h3><p>标准单元库中提供了stdcel的延迟信息、功耗、面积等信息，但是没有提供连线的延迟。在dc阶段使用线负载模型估计net delay，在icc阶段根据版图抽取寄生得到较为准确的延迟。线负载模型的计算方式：根据扇出和连线长度，预估电容，电阻和面积等参数，通过计算得到。越先进的工艺，连线延迟占比越大，而且集成度的提高，造成了布线的复杂，这也是物理综合走向前端的原因。</p><img src="/2024/02206923/image-20240309142358349.png" alt="image-20240309142358349" style="zoom:60%;"><h3 id="线负载模式"><a href="#线负载模式" class="headerlink" title="线负载模式"></a>线负载模式</h3><p><code>set_wire_load_mode</code></p><p>top模式定义层次中的所有连线将继承和顶层模块同样的线载模型。exclosed指定所有连线（属于子模块的）将继承完全包含该子模块的模块线载模型。例如设计者综合完全被模块A包含的子模块B和C，则子模块B和C会继承为模块A定义的线载模型。segmented用于跨越层次边界的连线。在上例中，子模块B和C继承特定于他们的线载模型，而子模块B和C间的连线（在模块A）会继承为模块A指定的线载模型。</p><ul><li>top：所有的线模型都是top层的</li><li>exclosed：线的延时使用mid的来计算</li><li>segmented：分开算</li></ul><img src="/2024/02206923/image-20240309142504896.png" alt="image-20240309142504896" style="zoom: 67%;"><h2 id="时序约束"><a href="#时序约束" class="headerlink" title="时序约束"></a>时序约束</h2><h4 id="时钟相关clock"><a href="#时钟相关clock" class="headerlink" title="时钟相关clock"></a>时钟相关clock</h4><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl"><span class="token comment"># clock latency = 内部延迟+外部延迟</span>set_clock_latency <span class="token operator">-</span>source <span class="token operator">-</span>max 4 <span class="token punctuation">[</span>get_clock clk<span class="token punctuation">]</span> <span class="token comment">#时钟源到clock外部端口的延迟</span>set_clock_latency <span class="token operator">-</span>max 4 <span class="token punctuation">[</span>get_clock clk<span class="token punctuation">]</span>  <span class="token comment">#内部时钟网络延迟</span>set_clock_uncertainty <span class="token operator">-</span>setup 0.5 $<span class="token variable">CLOCK</span> <span class="token comment">#包括jitter、skew、margin</span>set_clock_transition <span class="token operator">-</span>max 0.08 $<span class="token variable">CLOCK</span><span class="token comment">#指明时钟的名字和占空比</span>create_clock <span class="token operator">-</span>name clk <span class="token operator">-</span>period 5 <span class="token operator">-</span>wareform <span class="token punctuation">&#123;</span>0 3<span class="token punctuation">&#125;</span> <span class="token punctuation">[</span>get_ports Clk<span class="token punctuation">]</span><span class="token comment">#CTS综合后的时序约束</span><span class="token comment">#CTS后，时钟clock的transition上升、下降时间，内部延迟时间和skew时钟偏斜时间都已经确定</span>set_clock_latency <span class="token operator">-</span>source <span class="token operator">-</span>max 4 $<span class="token variable">CLOCK</span> set_propagated__clock $<span class="token variable">CLOCK</span> set_clock_uncertainty <span class="token operator">-</span>setup 0.2 $ CLOCK <span class="token operator">/</span><span class="token operator">/</span> jitter<span class="token operator">+</span>margin report_clock <span class="token comment"># -skew检查时钟约束</span>report_port <span class="token operator">-</span>verbose  <span class="token comment"># verbose 详细的输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输入输出约束"><a href="#输入输出约束" class="headerlink" title="输入输出约束"></a>输入输出约束</h4><h5 id="约束输入-输出延迟"><a href="#约束输入-输出延迟" class="headerlink" title="约束输入&#x2F;输出延迟"></a>约束输入&#x2F;输出延迟</h5><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl"><span class="token comment"># 一般设置外部延迟值占周期的60%</span><span class="token comment">#设置输入延迟</span>set_input_delay <span class="token operator">-</span>max 0.5 <span class="token operator">-</span>clock clk <span class="token punctuation">[</span>remove_from_collection <span class="token punctuation">[</span>all_inputs<span class="token punctuation">]</span> <span class="token punctuation">[</span>get_ports clk<span class="token punctuation">]</span><span class="token punctuation">]</span>remove_input_delay <span class="token punctuation">[</span>get_ports clk<span class="token punctuation">]</span><span class="token comment"># 设置的input_delay 和 output_delay 都是基于clock的,也可以指定基于clock的上升沿还是下降沿。</span>set_input_delay <span class="token operator">/</span>set_output_delay <span class="token operator">-</span>max 2 <span class="token operator">-</span>clock clk <span class="token punctuation">[</span>get_ports A<span class="token punctuation">]</span>set_input_delay <span class="token operator">/</span>set_output_delay <span class="token operator">-</span>max 2 <span class="token operator">-</span>clock clk <span class="token operator">-</span>clock_fall <span class="token operator">-</span>add_delay <span class="token punctuation">[</span>get_ports A<span class="token punctuation">]</span><span class="token comment">#-add_delay 指明还有另外一个寄存器与该端口相连</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/02206923/image-20240309212251864.png" alt="image-20240309212251864" style="zoom:50%;"><h5 id="约束输入转换时间"><a href="#约束输入转换时间" class="headerlink" title="约束输入转换时间"></a>约束输入转换时间</h5><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_input_transition <span class="token operator">-</span>max 0.2 <span class="token punctuation">[</span>get_ports A<span class="token punctuation">]</span> set_driving_cell <span class="token operator">-</span>libcell OR3B <span class="token punctuation">[</span>get_ports A<span class="token punctuation">]</span>set_driving_cell <span class="token operator">-</span>no_design_rule <span class="token operator">-</span>lib_cell invlal $<span class="token variable">ALL_INP_EXC_CLK</span><span class="token comment"># 两种方式都可以约束输入转换时间，</span><span class="token comment">#当静态时序分析时，当出现违例时，优先修复input transition time的违例，因为他影响下级延迟的计算。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="设计规则约束"><a href="#设计规则约束" class="headerlink" title="设计规则约束"></a>设计规则约束</h5><h5 id="路径分组"><a href="#路径分组" class="headerlink" title="路径分组"></a>路径分组</h5><p>由于综合工具发现同一组路径中最差的路径没办法优化到slack大于0，就会放弃优化退出综合。通过路径分组，可以将其他clock group路径的关键路径也会得到优化。</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">group_path <span class="token operator">-</span>name INPUT <span class="token operator">-</span>from <span class="token punctuation">[</span>all_inputs<span class="token punctuation">]</span>group_path <span class="token operator">-</span>name OUTPUT <span class="token operator">-</span>to <span class="token punctuation">[</span>all_outputs<span class="token punctuation">]</span>group_path <span class="token operator">-</span>name INOUT <span class="token operator">-</span>from <span class="token punctuation">[</span>all_inputs<span class="token punctuation">]</span> <span class="token operator">-</span>to <span class="token punctuation">[</span>all_outputs<span class="token punctuation">]</span>group_path <span class="token operator">-</span>name CLK <span class="token operator">-</span>critical_range 0.2 <span class="token operator">-</span>weight ：权重设置，建议值为5、2、1三个档。如果设置太高，可能会顾头不顾尾。<span class="token operator">-</span>critical_range：设置优化过程中的余裕边界，靠近关键路径的违例路径也会被优化。<span class="token comment">#reg-reg的路径设置5，less path 路径设置2，</span><span class="token comment">#默认设置1，设置权重 默认值为 1 权重越高工具就会越集中力量优化该 group_path。</span><span class="token comment">#这样设定group_path将会把这些不同种类的路径区分对待，优化时给予同等代价比重去进行优化，不会因为某一部分（如input逻辑）时序违反最大而不去优化其他路径。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/02206923/image-20240307010436686.png" alt="image-20240307010436686" style="zoom:50%;"><h4 id="报告命令"><a href="#报告命令" class="headerlink" title="报告命令"></a>报告命令</h4><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">Check_timing  <span class="token comment">#约束加好后，检查约束的一致性 检查是否有路径没有加入约束。</span>get_libs <span class="token comment">#获取当前设计的库</span>report_path_group <span class="token comment">#输出当前设计的路径分组</span>report_costraint <span class="token operator">-</span>all_violators <span class="token comment">#得到设计中所有的违例</span>report_timing <span class="token comment">#独立的输出每一条路径的时序</span><span class="token operator">-</span>delay max<span class="token operator">/</span>min <span class="token punctuation">(</span>max <span class="token operator">-</span><span class="token operator">></span> setup time, min <span class="token operator">-</span><span class="token operator">></span> hold time<span class="token punctuation">)</span><span class="token operator">-</span>from 起点<span class="token operator">-</span>to 终点<span class="token operator">-</span>through 经过哪些 pin port<span class="token operator">-</span>group 只输出该 group 的信息<span class="token operator">-</span>input_pins 只输出输入引脚相关的信息<span class="token operator">-</span>max_paths 指定只输出多少条最坏的时序路径信息<span class="token operator">-</span>nworst 输出该端点上的最坏的几条时序路径信息<span class="token operator">-</span>nets 输出fanout信息set_host_options <span class="token operator">-</span>max_cores 4  <span class="token comment">#最大四个核处理</span>report_congestion <span class="token comment">#输出当前设计的阻塞情况</span>report_design <span class="token comment"># 得到最大最小的工作条件和线负载模型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修复违例"><a href="#修复违例" class="headerlink" title="修复违例"></a>修复违例</h2><p>如果电路中的最大WNS违例的时间占clock period的15%以上，认为电路中存在较大的时序违例。需要做的：</p><p>1.检查约束 是不是出现问题<br>2.检查模块划分，组合逻辑是不是穿过多个模块<br>3.重新编译优化后的网表<br>4.修改rtl代码</p><p>如果电路中负的最大裕量是比较小的，认为约束和模块划分都是正确的，不需要将网表返回到GTECH结构，也不需要做逻辑级的优化，可以使用compile -incremental_mapping 增量优化，DC所要作的是进行门级单元的替换，即在不违反设计规则的情况下用延时小的单元替换延时较大的单元。也可以根据违例情况，添加选项进行单独修复。</p><h3 id="修复hold违例"><a href="#修复hold违例" class="headerlink" title="修复hold违例"></a>修复hold违例</h3><p>通常作法是插入buffer，但是可能会带来建立时间的违例；<br>hold的检查一般到cts后才可以得到准确值。<strong>DC 不修正保持时间的违例</strong></p><p>由于反相器具有再生特性，可以在长连线中插入多级buffer，目的就是降低rc延迟。</p><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="Synopsis-Tcl"><a href="#Synopsis-Tcl" class="headerlink" title="Synopsis Tcl"></a><strong>Synopsis Tcl</strong></h3><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">get_<span class="token operator">*</span> 和all_<span class="token operator">*</span>返回的都是collection类型的句柄，而不是list。<span class="token keyword">set</span> <span class="token variable">foo</span> <span class="token punctuation">[</span>get_ports <span class="token operator">*</span><span class="token punctuation">]</span> <span class="token comment">#得到的foo只是个集合“collection”的句柄，不是列表，用echo和puts无效，用query_objects $foo输出</span>get_object_name $<span class="token variable">foo</span>比query_object更有collection是DC<span class="token operator">-</span>Tcl特有的数据类型，描述多个属性元素的集合，为了描述硬件而设计的。<span class="token comment">#Filter collection</span>Filter_collection <span class="token punctuation">[</span>get_cells <span class="token operator">*</span><span class="token punctuation">]</span> “ref_name = <span class="token operator">~</span>AN<span class="token operator">*</span>”Set fastclk <span class="token punctuation">[</span>get_cells <span class="token operator">*</span> <span class="token operator">-</span>filter “period <span class="token operator">&lt;</span> 10”<span class="token punctuation">]</span>  <span class="token comment">#更有效</span>collection用于访问数据库数据，list是用户定义的用来存储数据的。<span class="token builtin">foreach</span>遍历list列表，而foreach_in_collection用来遍历collection，foreach_in_collection cell <span class="token punctuation">[</span>get_cells <span class="token operator">-</span>filter “is_hierarchical <span class="token operator">==</span> true”<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>echo “instance <span class="token punctuation">[</span>get_object_name $<span class="token variable">cell</span><span class="token punctuation">]</span> is hierarchical <span class="token punctuation">&#125;</span>get_lib <span class="token comment">#获取工艺库</span>get_attribute slow time_unit_name <span class="token comment">#获取dc中的时间单位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="link"><a href="#link" class="headerlink" title="link"></a><strong>link</strong></h3><ol><li><p>将设计与工艺库中stdcel进行对应。</p></li><li><p>将设计连接到这些库单元上。</p><p>link后，生成没有工艺库对应的getch库文件，以ddc的格式保存。</p><p>link后，进行uniquify，创建同一个reference的不同instance，以便根据不同的物理环境做优化。<br>Link 命令不会去读取verilog rtl，而是去DC memory中寻找模块的getch库名称，与工艺库做一个匹配，read命令完成的是在DC memory中创建模块</p></li></ol><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a><strong>compile</strong></h3><p>compile_ultra会对违例的关键路径进行重组优化，high effort 代价较高，其自动调用high map effort </p><p>compile 需要显式调用 -map_effort high</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">compile_ultra <span class="token operator">-</span>timing<span class="token comment"># 通过在关键路径使用 寄存器复制 用于优化综合的时序问题，使用compile_ultra会自动调用，可以人为的设定寄存器组的数目限制， </span>compile <span class="token operator">-</span>retime<span class="token comment"># 移动、复制、合并寄存器以满足时序的要求，如果设计需要固定的寄存器位置和名字，不建议使用 -retime</span><span class="token comment"># 设置set_dont_retime &lt;cell or design> true</span><span class="token comment"># Dc默认只优化最关键的路径，通过crtical_range可以指定优化范围</span>set_critical_range <span class="token comment"># 同时优化多条路径，可能会优化关键路径。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="uniquify"><a href="#uniquify" class="headerlink" title="uniquify"></a>uniquify</h3><p>Uniquify 将多次引用的模块的个数拷贝需要的数目,然后对他们分别命名而得到不同的模块名，DC默认储存器的模块都只是引用一次的，如果使用uniquify，可以使得模块的各个引用针对不用环境分别优化得到更好效果。（因为在物理上是独立的模块）DC可以把他们当做两个不同的模块，根据不同的周围环境做优化。</p><h3 id="for-formality"><a href="#for-formality" class="headerlink" title="for formality"></a>for formality</h3><p>DC在综合过程中，会生成svf文件，记录了设计的boundary改变，寄存器的重新定位和路径分组信息，这些信息可以被formality形式验证工具读取，默认是&lt;default.svf&gt;，可以通过set_svf &lt;name.svf&gt; 修改，一定要在read RTL之前进行。</p><h3 id="report-芯片面积"><a href="#report-芯片面积" class="headerlink" title="report 芯片面积"></a>report 芯片面积</h3><p>三种方式描述面积：1. 晶体管级 transitor 2. 2输入与非门的个数 3. 实际的面积</p><p>report_area 输出实际的面积,也会显示综合后的标准单元个数。如果想要转换到与非门的个数，将报出的面积除以与非门的面积，得到2输入与非门个数。</p><p>查看综合后的网表有多少门</p><pre class="line-numbers language-none"><code class="language-none">sizeof_collection [get_cells * h]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看2输入与非门的面积：</p><ol><li>打开logic 库，查看NA2的面积，<strong>tsmc65大概是2.16平方微米</strong>。</li><li>tcl查询，NAND2的属性 attribution <code>get_attribute[get_lib_cell */nand2]</code> </li><li>单独综合一个与非门，查看面积。</li></ol><h2 id="针对课题组项目"><a href="#针对课题组项目" class="headerlink" title="针对课题组项目"></a>针对课题组项目</h2><p>1、由于数字校准模块的数字时钟为经过DTC延迟后的时钟，所有有 <strong>100ps左右的jitter</strong>，在约束setup的clock_uncertainly时需要加上该值；</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_clock_uncertainly <span class="token operator">-</span>setup 0.25 <span class="token punctuation">[</span>get_clock clk<span class="token punctuation">]</span><span class="token comment"># 0.25 = jitter（0.1+0.05ns） + skew + margin    </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、dc的跨时钟域约束<br>     由于SPI模块是课题组原有的，不需要对内部逻辑进行修改；SPI按照10M约束，数字校准模块按照125M约束，定义两个时钟为异步的。针对异步时钟，作如下约束  </p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_clock_group <span class="token operator">-</span>asynchronous <span class="token operator">-</span>group clk_100 <span class="token operator">-</span>group <span class="token operator">-</span>clk_1 set_max_delay 7 <span class="token operator">-</span>from <span class="token punctuation">[</span>get_pins xx<span class="token operator">/</span>Q<span class="token punctuation">]</span> <span class="token operator">-</span>to <span class="token punctuation">[</span>get_pins xx<span class="token operator">/</span>D<span class="token punctuation">]</span> <span class="token operator">-</span>datapath_onlyset_max_delay 3 <span class="token operator">-</span>from <span class="token punctuation">[</span>get_pins xx<span class="token operator">/</span>Q<span class="token punctuation">]</span> <span class="token operator">-</span>to <span class="token punctuation">[</span>get_pins xx<span class="token operator">/</span>D<span class="token punctuation">]</span> <span class="token operator">-</span>datapath_onlyset_input_delay  <span class="token operator">-</span>clock clk_1   <span class="token operator">&lt;</span>输入延迟<span class="token operator">></span> <span class="token punctuation">[</span>get_pins <span class="token operator">&lt;</span>输入信号<span class="token operator">></span><span class="token punctuation">]</span>set_output_delay <span class="token operator">-</span>clock clk_100 <span class="token operator">&lt;</span>输出延迟<span class="token operator">></span> <span class="token punctuation">[</span>get_pins <span class="token operator">&lt;</span>输出信号<span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>基础：set_max&#x2F;min_delay这两种约束，一般用于异步时钟的数据约束上。set clock group -asynchronous或者set false path设置 对这两个时钟域数据不进行时序检查，但是一般需要保证跨时钟传递的数据要满足最大最小延迟，而不会高的离谱。比如异步fifo读写指针的格雷码，如果延迟时间太长，目的时钟域周期太短，会导致传输路径延迟超过两个周期。</p></blockquote><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h4 id="dc-shell中执行bash命令"><a href="#dc-shell中执行bash命令" class="headerlink" title="dc_shell中执行bash命令"></a>dc_shell中执行bash命令</h4><p>​前面加shell &#x2F; sh，比如 <code>shell gvim</code></p><p>​-tee 读取标准输入数据到文件    -i 忽略中断信号</p><p>​| 管道命令</p><p>​cat file1 | file2 #将file1的输出作为输入保存在file2中 </p><h4 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h4><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">help <span class="token string">"set_input_delay"</span>set_input_delay <span class="token operator">-</span>helpman set_input_delaysynoff <span class="token comment">#取消 工艺库lib文件中显示的底色</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-CPU流水线设计（一）</title>
      <link href="/2024/021950375.html"/>
      <url>/2024/021950375.html</url>
      
        <content type="html"><![CDATA[<p>将整个结构划分为五级，相比于单周期的CPU，在流水线设计过程中主要解决数据冒险和结构冒险。</p><h2 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h2><p>将数据旁路模块bypass放在译码阶段（id），与教材中放在执行阶段不同，原因是可以减少寄存器堆的一个读端口。（译码to执行阶段 写寄存器的时候，Write back阶段已经将数据写入到寄存器堆中，所以要单独设置一个读端口读取写入寄存器堆的数据）。</p><p>数据旁路的数据来源有四个：</p><ol><li>id译码阶段的寄存器堆输出 </li><li>exe执行阶段的结果 </li><li>ls访存阶段的结果 </li><li>wb写回阶段的结果。</li></ol><img src="/2024/021950375/image-20240220111048796.png" alt style="zoom: 33%;"><p>​判断条件:  </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>rs1_id <span class="token operator">==</span> xx_rdid<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>xx_rdwen<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs1_id <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>发生数据旁路<span class="token keyword">else</span>     不发生数据旁路<span class="token comment">// 如果源寄存器的id为0时，不能进行数据旁路，因为默认寄存器堆的0号寄存器值常0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>特别：如果在exe阶段的指令是load指令，且发生了数据冒险，需要将流水线停顿一拍，等待进入访问阶段才能得到真正的数据</strong>。 这种情况称为” load use”型指令，需要发出stall和nop使能。</p><p><img src="/2024/021950375/image-20240220134957838.png"></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> stall <span class="token operator">=</span> <span class="token punctuation">(</span>rs1id <span class="token operator">==</span> ex_rdid<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>rs2id <span class="token operator">==</span> ex_rdid<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ex_rdwen <span class="token operator">&amp;&amp;</span> ex_lden<span class="token keyword">assign</span> nop <span class="token operator">=</span> stall<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h2><p>控制冒险的处理放在译码阶段，而不是执行阶段，这样做可以提前决定指令执行顺序；</p><p>采用静态分支预测方式，当预测失败时，PC地址发生跳转，跳转地址在bru中计算得到；否则，执行PC+4。</p><img src="/2024/021950375/image-20240220144307189.png" alt style="zoom: 50%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> nop <span class="token operator">=</span> jalr <span class="token operator">||</span> jal <span class="token operator">||</span> brch<span class="token punctuation">;</span><span class="token keyword">assign</span> jump_en <span class="token operator">=</span> nop<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2024/021950375/image-20240220150606788.png" alt style="zoom: 50%;"><p>针对跳转指令后的冲刷，如果没有取指令单元是组合逻辑，IF_ID寄存器直接冲刷即可。 如果取指令是时序逻辑，在冲刷IF_ID时，有可能指令还没得到，导致无法及时冲刷，在下个周期写入到IF_ID寄存器中，导致错误。所以在写入到IF_ID时需要判断PC出来的addr和写入IF_ID的地址是不是一致的，如果是一致的，就可以写入。</p><p>对于带cache的方案，当时hit没有命中时，会进行读分配操作，在IDLE时进行hit判断，即使发生了跳转，addr发生了变化，也不会hit，所以无需担心，不能彻底冲刷流水线的问题。</p><p>对于只有axi的方案，需要在写入IF_ID时，判断来自pc的地址和 ifu模块锁存的地址是否一致，只有一致才写入。</p><h2 id="数据冒险-控制冒险-冲突"><a href="#数据冒险-控制冒险-冲突" class="headerlink" title="数据冒险+控制冒险 冲突"></a>数据冒险+控制冒险 冲突</h2><p>当译码阶段的指令是jalr时，rs1发生了数据冒险，且是load-use类型，bypass模块发出stall和nop信号；bru模块发出jump和nop信号。对于IF_ID寄存器，同时收到了bypass的stall和bru的nop信号。<strong>此时，产生了冒险冲突</strong></p><p>解决办法：<strong>先stall处理完数据冒险，再nop处理控制冒险保证处理控制冒险时，跳转地址的计算是正确的。</strong></p><pre class="line-numbers language-systemverilog" data-language="systemverilog"><code class="language-systemverilog">&#x2F;&#x2F; exauipc a5 0x0ld   a5 595(a5)jalr  a5 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/021950375/image-20240220152550379.png"></p><h2 id="流水线-思考"><a href="#流水线-思考" class="headerlink" title="流水线-思考"></a>流水线-思考</h2><p>发出反压信号stall时，会让整个流水线停顿下来；<br>原因是每级流水的上下游没有握手和反压，当需要反压时，只能跨级反压，并且让所有的寄存器保持不变；</p><p><strong>如果每级流水都有响应的握手信号，就可以进行逐级反压，上面流水线不一定全部停顿下来，可以进一步提高效率</strong></p><h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>实现srlw指令出现的问题：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> srlw<span class="token punctuation">;</span> <span class="token important">always</span> srlw <span class="token operator">=</span> <span class="token operator">&#123;&#123;</span><span class="token number">32</span><span class="token operator">&#123;</span>data_A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span> <span class="token operator">&#123;</span>data_A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>></span> data_B<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span> <span class="token comment">// right</span><span class="token important">always</span> srlw <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> <span class="token operator">&#123;</span>data_A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>></span> data_B<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span>  <span class="token comment">// wrong</span><span class="token comment">// 存在特殊情况，如果data_A[31]为1，且data_B为0，srlw的高32位应该全为1.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果srlw指令中的data_B &gt;&#x3D; 1，srlw结果高32bit都为0，两种方式的结果一致；<br>如果srlw指令中的data_B &#x3D; 0，data_A的第32bit为0，两种方式结果一致；<br>如果srlw指令中的data_B &#x3D; 0，data_A的第32bit为1，两种方式结果不一致；第一种是正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk用法</title>
      <link href="/2024/021721611.html"/>
      <url>/2024/021721611.html</url>
      
        <content type="html"><![CDATA[<h3 id="Awk处理文本数据"><a href="#Awk处理文本数据" class="headerlink" title="Awk处理文本数据"></a><strong>Awk处理文本数据</strong></h3><p>格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> ‘匹配规则和处理规则’  <span class="token punctuation">[</span>处理文本路径<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>处理规则：</p><p>BEGIN{}: BEGIN是在awk处理文本之前运行</p><p><strong>&#x2F; &#x2F; ： 使用的匹配原则</strong></p><p>{}：循环（每次处理一行）</p><p>END{}: 当所有行执行完毕后，执行END的操作</p></li></ul><p>原理：</p><ol><li><p>awk会接收一行作为输入，将这一行赋给awk的内部变量$0，行的边界是以换行符作为结束的。</p></li><li><p>刚刚读入的行被以:为分隔符分解成若干字段（或域），每个字段存储在已编号的变量中，编号从$1开始，最多达100个字段，-F 指定分隔符，默认是空格。</p></li><li><p>使用print打印，如果$1$3之间没有逗号，输出时贴在一起，如果添加”,”，$1和$3之间默认用空格分开，通过OFS修改输出的间隔符   ‘BEGIN{OFS&#x3D;”-“}{print $1,$3}’</p></li><li><p>输出后，获取下一行，执行上述操作</p></li></ol><h5 id="awk变量"><a href="#awk变量" class="headerlink" title="awk变量"></a><strong>awk变量</strong></h5><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">$<span class="token variable">0</span>:当前行的内容NR：行号NF: 总字段数FS：输入字段分隔符，默认空格OFS：输出字段分隔符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'&#123;if(NR > 7)&#123;print NR,$0&#125;&#125;'</span> /etc/passwd<span class="token operator">==</span> <span class="token function">awk</span> -F: <span class="token string">'NR > 7 &#123;print NR,$0&#125;'</span> /etc/passwd// 输出第7行之后的内容指定<span class="token string">','</span>作为分隔符，-F<span class="token string">','</span>-F:  ：表示以<span class="token string">':'</span>作为分隔符<span class="token function">awk</span> -F<span class="token string">':'</span> <span class="token string">'BEGIN&#123;FS=","&#125;&#123;print $1,$2&#125;'</span> FS的优先级大于-F指定的输出指定分隔符<span class="token function">awk</span> -F<span class="token string">':'</span> <span class="token string">'BEGIN&#123;OFS=" >>> "&#125;&#123;print $1,$2&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>正则表达式</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'/^xxx/'</span> /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>条件模式</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'NR > 7'</span> /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>算数运算</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'&#123;print $1,$2+1&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>if判断</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">单分支：<span class="token function-name function">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>双分支：<span class="token function-name function">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>多分支：<span class="token function-name function">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token function-name function">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk文本处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AXI协议</title>
      <link href="/2024/02077053.html"/>
      <url>/2024/02077053.html</url>
      
        <content type="html"><![CDATA[<h3 id="AXI协议"><a href="#AXI协议" class="headerlink" title="AXI协议"></a>AXI协议</h3><h4 id="AXI3和AXI4的区别"><a href="#AXI3和AXI4的区别" class="headerlink" title="AXI3和AXI4的区别"></a>AXI3和AXI4的区别</h4><h5 id="1-Burst"><a href="#1-Burst" class="headerlink" title="1. Burst"></a>1. Burst</h5><p>AXI4对burst length进行了扩展<br>AXI4支持最大256 beats，AxLEN位宽为8；AXI3最大支持burst 16 beats，AxLEN位宽为4；</p><p>只有INCR burst类型，才支持burst 超过16 beats</p><p><img src="/2024/02077053/image-20240207000854573.png"></p><p>实际使用中，很少使用burst超过16 beats的操作，因为长时间占用总线会影响系统性能。而且burst 一旦开始，无法停止。</p><p>axi4协议规定 一次burst，最多传输256笔数据。</p><h5 id="2-Write-interleaving"><a href="#2-Write-interleaving" class="headerlink" title="2. Write interleaving"></a>2. Write interleaving</h5><p>AXI4去掉了WID，不再支持写交织（write interleaving）。<br>这就限制了写入的数据必须和写入的地址顺序相同且连续。不同write burst的beat不可以相互交织。</p><p>原因：发送端必须要缓存多个ID的wdata，不管是maser还是总线interconnection都必须要增加大量的缓存，所以增加了面积；另外，Write interleaving增加了系统总线设计的复杂度，而且很容易造成死锁，</p><h5 id="3-Write-response-dependencies"><a href="#3-Write-response-dependencies" class="headerlink" title="3. Write response dependencies"></a>3. Write response dependencies</h5><p>修改了BVALID拉高的要求</p><p>AXI3握手依赖</p><p><img src="/2024/02077053/v2-0160a446a10236e56609b0bc7fcc541e_1440w.png"></p><p>AXI3必须等到了WVALID和WREADY后才能把BVALID置高来响应，也就是说只要收到了所有数据，SLAVE就可以发写响应。</p><p>AXI4握手依赖</p><p><img src="/2024/02077053/v2-12a2457485825157ceaaa25f358b7ae7_1440w.png"></p><p>​AXI4规定，必须等到AWVALID,AWREADY,WVALID, WREADY, and WLAST 都为高(不是同一时刻都为高)后，SLAVE才能发BVALID进行写响应。也就是不仅仅要等数据通道握手，而且要等地址通道握手，并且明确了要等WLAST。这样能保证响应的时候Transaction是真正完成的</p><h5 id="4-Locked-transactions"><a href="#4-Locked-transactions" class="headerlink" title="4. Locked transactions"></a>4. Locked transactions</h5><p>​AXI4去掉了locked 传输。AxLOCK缩为2bit</p><img src="/2024/02077053/v2-52896f5fa4a0dfe4c2c6a4a4645664a9_1440w.png" alt style="zoom:67%;"><p>​Locked access作用的对象是总线，一旦发生Locked access，那么其他的master都不能使用总线了，在一个复杂的SOC系统中，Locked access对系统的影响就太大了，万一发生Locked access的master出点啥问题，整个系统就挂死了</p><p>​Exclusive access 作用的对象是对应的Slave，支持Exclusive access的Slave会在slave中实现一个Exclusive access monitor，如果monitor记录了能够访问的master，那么对应的master就能通过Exclusive access来访问，其他的未记录的Exclusive access就都不能访问。Exclusive access对总线系统是没有要求的，只是对slave做了特殊要求，即使出错也不会影响系统其他部分，最多访问失败而已。</p><h4 id="窄传输"><a href="#窄传输" class="headerlink" title="窄传输"></a>窄传输</h4><p>当数据传输的位宽小于数据总线的位宽时，称为窄位宽传输。通常通过wstrb来控制哪些字节有效。<br>当从机自身限制或者其他客观条件时，比如从机每次只能接收1个字节数据，且不能缓冲多字节数据，<strong>主机就要进行窄传输。</strong>可以将传输数据都放在数据总线上，每次传输只需要改变wstrb即可。</p><p>32位数据总线，wstrb为4bit；64位数据总线，wstrb是8bit。</p><p>AXI-Lite协议<br>    不支持突发传输，且每次传输一个数据，没有last信号；<br>    支持多master，多slave</p><ul><li><p>AXI和AHB传输对比：</p><p>AHB突发传输的 每次传输都需要发送地址；并且每次传输都是先发地址，再传输数据；<br>AXI突发传输，只要第一次传输地址即可，后续的地址都是计算出来的；地址和数据可以乱序，提供总线效率</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总线协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低功耗设计</title>
      <link href="/2024/020534087.html"/>
      <url>/2024/020534087.html</url>
      
        <content type="html"><![CDATA[<h1 id="低功耗设计"><a href="#低功耗设计" class="headerlink" title="低功耗设计"></a>低功耗设计</h1><p>时钟频率的增加导致功耗的增加，温度升高带来大规模集成电路的散热问题，导致性能下降。</p><p>功耗和能量是两个不同的概念。能量是一段时间内的消耗，而功率是瞬时的能量。</p><img src="/2024/020534087/v2-ea250d565bf82da5061f7cb7687b5252_1440w.webp" alt style="zoom:67%;"><p>SOC芯片的功耗分为：动态功耗和静态功耗</p><p>动态功耗又分为：翻转功耗（开关功耗，电容充放电功耗，switching power）和短路功耗（内部功耗，internal power）</p><ol><li><p>翻转功耗表达式：<img src="/2024/020534087/v2-e2be66370380c970f5e36e3aff3f8720_1440w.png"><br>得出降低功耗，可以通过降低电源电压，降低翻转概率，减小负载</p></li><li><p>内部功耗：在信号翻转时，存在NMOS和PMOS同时导通的情形，产生了VDD到GND的通路，形成了短路电流。</p></li></ol><p>静态功耗：在没有信号变化时，由于漏电流所引起的功耗。</p><img src="/2024/020534087/v2-30817fdf230a2209d3e42a37f4abbcf7_1440w.webp" alt style="zoom: 67%;">静态功耗的计算方式：<img src="/2024/020534087/v2-bf118d5d1de06f0f9110d057f1910cdf_1440w.png" alt="img" style="zoom:50%;"><p>SOC中，不同结构的功耗贡献是不一样的</p><ol><li>时钟树功耗：通常占整个功耗的40%；(门控时钟技术很重要)</li><li>CPU：时钟频率越来越高，功耗越来越大。（采用大小核，不同场景使用不同的处理器核）</li><li>GPU：CPU的并行处理单元，多个模块同时工作，功耗较大。很多SOC不带GPU或者默认关闭</li><li>存储器：DDR作为SOC的主存，时刻需要调用。</li></ol><p>从上面的公式看出，降低功耗最有效的办法是<strong>降低电源电压</strong></p><h2 id="多电压技术"><a href="#多电压技术" class="headerlink" title="多电压技术"></a>多电压技术</h2><p>思想：1. 针对不同的模块，采用不同的电压。2. 同一个模块，做不同的事情，采用不同的电压</p><ul><li><p>静态多电压技术 MSV：Multi Supply Vdd</p><p>将设计中不同的功能模块划分为不同的电压域(Power domain, PD). 每个电压域对应于设计中的一个或多个子模块。</p><p>原则：<strong>在满足系统性能(频率)要求的基础上，采用最低电压</strong></p><p>缺点：需要不同的电源电压供电，以及不同电压域的level shifter，增加了设计的复杂度</p></li><li><p>动态电压频率缩放技术 DVFS：Dynamic Voltage and Frequency Scaling</p><p>根据芯片所运行的应用程序对计算能力的不同需要，监控芯片的工作负载，动态调节芯片的运行频率和电压。在保证性能的同时，降低电压，实现减少功耗的目的。</p><p><img src="/2024/020534087/v2-013caae8290aa4e7e666a3366f4924b2_1440w.webp"></p><p>​管理单元监控工作状态，根据运行状态控制电压生成单元和频率生成单元调整工作模块的电压VDD和频率f。一般采样软件算法进行判决来控制管理单元生成需要的电压和频率。（开环调节）</p></li><li><p>自适应电压频率调节技术 AVFS ：Adaptive Voltage and Frequency Scaling</p><p>软件根据不同的应用场景，选择不同的电压和频率。对不同的模块能够自适应的调节电压和频率。</p><p>AVFS是一个闭环方案，在运行过程中自动完成调节，不需要外部干预。换句话说，它不固定电压和频率的一一对应关系，而是将对温度，传播延时等因素在运行时予以补偿。（闭环调节，复杂度很高）</p></li><li><p>电压关断技术 PSO：Power Shut Off</p><p>不使用的模块，关断其电压。断电后，设计进入睡眠模式，其漏电功率很小。唤醒时，为了使模块尽快恢复工作模式，需要保持关电前的状态。保持寄存器(retention register)可用于记忆状态。</p><p>为了在电源关断时不影响其他部分的逻辑，电源门控模块的输出端需要使用隔离单元(Isolation Cell)，因为在睡眠模式时，模块的输出为不确定值。为了保证在睡眠模式时，下一级的输入不会悬空，插入隔离单元，保持一个”1”或”0”的输出。</p></li></ul><h4 id="ASIC-低功耗中常使用的特殊单元"><a href="#ASIC-低功耗中常使用的特殊单元" class="headerlink" title="ASIC 低功耗中常使用的特殊单元"></a>ASIC 低功耗中常使用的特殊单元</h4><ol><li><p>Isolation cell</p><p>隔离单元，某个电压域关闭时，可以保持输出或者输入为常数。</p><p>两个原因：1. 防止虚假信号传播到未关闭电压的域，导致逻辑错误。2. 防止产生瞬态电路，带来功耗。</p><img src="/2024/020534087/v2-1f2eefb144af1ca428447621fa7e8812_1440w.webp" alt style="zoom:67%;"></li></ol><p>​典型的Shutdown PD的ISO，AND和OR门都可以构成一个isolation cell。AND类型，输出常0，OR类型，输出常1。控制信号power_ctrl必须在AON域。</p><p>​考虑到power-on rail的走线，isolation cell自身的功耗，一般还是放在input端比较好，因为放在input端不需要always-on的power。</p><img src="/2024/020534087/v2-483302cba227a51c6ab093adc887f513_1440w.png" alt style="zoom:50%;"><ol start="2"><li><p>isolation cell</p><p>将信号从一个电压域切换到另一个电压域，如果不进行电压转换，器件就无法正常工作。</p></li></ol><img src="/2024/020534087/v2-554cee9ed18ce8e73c597e165d274a39_1440w.webp" alt style="zoom:50%;"><p>​通常LS和ISO会一起用，所以会把两个cell合成一个，叫做enable level shifter (ELS)</p><img src="/2024/020534087/v2-59fb4635fb7452017136fd232fb5efa2_1440w.webp" alt style="zoom:50%;"><ol start="3"><li>Power Switches</li></ol><p>​电源开关单元提供了关闭逻辑域的电源的能力</p><ol start="4"><li>Always-on Cells</li></ol><p>​电源管理单元需要保持激活，即使这些单元周围的逻辑已经被关闭，这就行需要用到Always-on cells，它的供电来自于不会被关断的电源域(always-on domain), 但是被摆放在可以被关断的电源域。</p><ol start="5"><li>Retention Cells</li></ol><p>​Retention cell: 保留单元，一种能够在电源关闭的情况下，能保持内部状态的特殊单元。</p><h4 id="在各设计抽象层次降低功耗"><a href="#在各设计抽象层次降低功耗" class="headerlink" title="在各设计抽象层次降低功耗"></a>在各设计抽象层次降低功耗</h4><p>层次越高对功耗降低越有效。</p><img src="/2024/020534087/image-20240223093647968.png" alt style="zoom:50%;"><ul><li><p>系统级</p><p>通过合理划分软硬件的功能，可以有效降低功耗。<br>编写C程序时，可以考虑优化指令条数来编写C程序。<br>处理器的选择会对整体功耗产生明显的影响。对于特定的应用，可以使用协处理器或者专门的DSP处理数据。</p></li><li><p>体系结构级</p><ol><li><p>门控时钟技术</p><p>常用的门控时钟单元 <strong>锁存器+与门</strong> （时序门控时钟）</p><p>组合门控时钟如下所示</p><img src="/2024/020534087/image-20240223111132118.png" alt style="zoom: 50%;"><p>对于输入的时钟信号是组合逻辑产生的，所以称为组合门控时钟，缺点是容易产生毛刺。</p><p>时序门控时钟如下所示</p><img src="/2024/020534087/image-20240223111242133.png" alt style="zoom:50%;"><p>时钟使能信号经过寄存器或者锁存器，再与时钟信号做 <strong>与</strong>，称为时序门控时钟，没有毛刺产生。</p></li><li><p>动态电压频率调节 DVFS</p><p>本质：牺牲性能，降低功耗。<br>P&#x3D;V^2 * CL*f，电压与功耗成平方关系，根据特定情况选择电压和频率，可以大大降低功耗。</p></li><li><p>基于缓存的系统体系架构</p><p>缓存的意义：某些场景需要频繁访问存储器，可以设置缓存，提高访问速度。同时，也大大降低了功耗。（牺牲了硬件成本和面积）</p></li><li><p>多阈值电压</p><p>需要工艺库提供相同电压，不同阈值的cell。在满足时序要求下，提高Vt，降低功耗，但是面积也会相应增加。</p></li><li><p>多电压域</p><p>不同模块根据不同需求，采用不同电压。需要工艺库中提供特殊的电压转化cell。</p></li></ol></li><li><p>寄存器传输级 （RTL实现）</p><ol><li><p>状态机编码和解码</p><p>格雷码最合适低功耗设计，相邻状态跳变，只有1bit信号发生翻转，并且降低了产生毛刺的概率。降低功耗。</p></li><li><p>多路选择器采用独热码</p><p>如果mux的输入是多位总线，会产生明显的开关过程，产生功耗。如果按照独热码方式，在初始的时候就可以mask一些未选中的总线，起到了降低功耗作用。</p></li><li><p>资源共享</p><p>优化组合逻辑，共用相同的逻辑，减小不必要的计算，降低功耗。</p></li></ol></li><li><p>寄存器级</p><p>通过优化物理版图、MOS管结构降低功耗。</p></li></ul><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ol><li><p>动态功耗和静态功耗分别指的是什么？可以通过什么方式降低？</p><p>动态功耗与电压、负载电容以及信号翻转频率有关；静态功耗与漏电功耗有关；</p><p>措施：降低电源电压、从后端角度降低负载电容、减小信号翻转频率（门控时钟技术）</p><p>​使用高阈值的管子、后端使用多电压域设计技术</p></li></ol><p>​（可以按照上面不同层次来回答如何降低功耗）</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机体系结构</title>
      <link href="/2024/012760393.html"/>
      <url>/2024/012760393.html</url>
      
        <content type="html"><![CDATA[<p>超流水线：<br>    通过增加流水线级数来缩短指令执行速度。细化流水，提高主频。用时间换空间。超流水线技术对芯片的工作速度要求比较高，同时硬件系统比较复杂，需要占用较大的芯片的面积，因此超流水线结构在嵌入式RISC处理器中很少采用。</p><p>超标量：<br>    一个时钟周期可以发射多条指令，CPU中有一条以上的流水线，每个周期可以完成一条以上的指令。用硬件来换速度。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路设计（RTL）</title>
      <link href="/2024/012448005.html"/>
      <url>/2024/012448005.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>课题组项目 后端指导前端 log</p><p>在做pt eco的时候，有个模块lms_delay的路径修复好几次都不成功。report_timing发现组合逻辑的路径太长造成的。检查RTL代码确实是先进行了减法 又进行了乘法，中间没有打拍。</p><p>采取的方式：在减法和乘法之间，打一拍，而且没有影响功能。</p></li><li><p>对齐</p><p>用空格将等号对齐，提高代码的可读性和美观性。</p></li><li><p>布线太密的原因</p><ul><li>第一个原因：寄存器位宽太大，如果对该数据进行了很多逻辑操作，就会出现布线密集的情况。</li><li>第二个原因：负载太大，1对多，一个信号在很多地方使用，也会导致布线密集。解决办法：使用寄存器复制的方式。</li></ul></li></ul><img src="/2024/012448005/640.png" alt style="zoom:50%;"><img src="/2024/012448005/640-1706455914012-3.png" alt style="zoom:50%;"><ul><li><p>面积优化策略</p><p>面积：加法器 &gt; 比较器 &gt; 选择器.<br>乘法器本质也是加法器。<br>策略：<strong>先选后加，先选后比，先选后乘</strong></p></li><li><p>表达式位宽</p><p>利用中间值，使得结果没有歧义，比如乘法的结果是a+b的位宽之和，$unsigned(a*b)的位宽是a&#x2F;b中最大的一个，与z的定义不同。</p><p><img src="/2024/012448005/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxODQyMDk3,size_16,color_FFFFFF,t_70.png"></p></li><li><p>有符号数的部分选择</p></li></ul><p>​部分选择有符号数，得到的切片仍然是无符号数。哪怕选择了整个向量也是无符号的，如 input signed[7:0] a 中 a[7:0] 也会被认为是无符号的。</p><p>​若表达式中有一个数为无符号数，Verilog会把整个表述为无符号的，导致功能失常。</p><ul><li><p>有符号数运算</p><p>如果是有符号数的运算，在定义时使用signed声明比较好，而不是用无符号数模拟有符号数，这样综合得到的电路更好。但是如果运算中既有无符号数，又有有符号数，结果就是无符号数的计算。</p><p><img src="/2024/012448005/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxODQyMDk3,size_16,color_FFFFFF,t_70-1706971897728-3.png"></p></li><li><p>条件完备的case是没有优先级的，条件不完备是有优先级的。</p></li></ul><h3 id="大小端对齐"><a href="#大小端对齐" class="headerlink" title="大小端对齐"></a>大小端对齐</h3><p>大端对齐：MSB最高有效字节在内存中对应低地址；（高地址对应高位数据）<br>小端对齐：MSB最高有效字节在内存中对应高地址；地址偏移量和字节数是一一对应的关系；（低地址对应低位数据）</p><p>eg. 对于16进制数据0x12345678在内存中的保存方式</p><p><img src="/2024/012448005/image-20240221225921219.png"></p><p>优点：大端模式，很容易通过访问最低位地址，判断数值的正负。</p><h3 id="亚稳态问题"><a href="#亚稳态问题" class="headerlink" title="亚稳态问题"></a>亚稳态问题</h3><p>当数据不满足建立setup和保持hold时间时，会出现亚稳态问题。<br>解决办法（单bit）：1. 多级同步器 2. 时钟倍频电路的多级同步器<br>方法1需要较长时间去响应异步输入，解决办法：使用倍频时钟作为两个同步器的时钟输入。（Altera的FPGA中具有这项称为时钟倍频的技术，减小异步信号输入的延迟）</p><img src="/2024/012448005/image-20240219205135401.png" alt="时钟倍频电路的多级同步器" style="zoom:50%;"><ul><li><p>寄存器的输出 驱动 另一个寄存器的异步复位端</p><p>第二级寄存器的时钟和复位之间存在潜在的竞争关系。</p></li></ul><img src="/2024/012448005/image-20240219223205525.png" alt="异步复位" style="zoom: 33%;"><ul><li><p>锁存器生成对应的电路</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span>clk<span class="token punctuation">)</span>   <span class="token function">if</span><span class="token punctuation">(</span>clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>  b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>  b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><img src="/2024/012448005/image-20240219225204769.png" alt style="zoom:50%;"><p>​某些FPGA架构不支持锁存器，在综合时会将锁存器综合成 带有反馈的组合逻辑实现。</p><img src="/2024/012448005/image-20240219225414951.png" alt style="zoom: 50%;"><p>​<strong>虽然该结构有锁存数据的能力，但是可能会违背建立时间和保持时间的要求，跟带电平触发的锁存器是不一样的。在设计中不应包含任何组合逻辑环路</strong>。<br>​锁存器并不是不能存在的，可以用来挪用周期或借用时间来满足关键路径的要求。（time borrowing)</p><ul><li>内部时钟产生</li></ul><p>​毛刺出现在数据上，不会有太大影响，因为是边沿采样；如果毛刺出现在时钟上，会产生明显的影响。比如，由于时钟毛刺，使得计数器的值多增加1。因此，寄存器的输入时钟最好不是经过组合逻辑处理得到的。<br>​解决办法：将组合逻辑输出的时钟，打拍寄存器输出。</p><ul><li><p>门控时钟和时钟使能技术</p><p>门控时钟：当门控关闭后，时钟网络和内部的组合逻辑停止翻转，减小功耗。</p><img src="/2024/012448005/image-20240220103515514.png" alt style="zoom:67%;"></li></ul><p>​同步时钟使能：以同步的方式，将输出拉死，并没有关闭时钟，而是将寄存器的输出保持不变，无法降低功耗。</p><img src="/2024/012448005/image-20240220103631732.png" alt style="zoom:67%;"><ul><li><p>门控时钟电路</p><p><strong>不带锁存器的门控时钟</strong>，使用“与”门 或者 “或”门实现。</p><img src="/2024/012448005/image-20240220104808503.png" alt style="zoom:50%;"></li></ul><p>​存在问题：en和clk是完全异步的，使得时钟输出畸形；</p><img src="/2024/012448005/image-20240220104905125.png" alt style="zoom:50%;"><p>​<strong>带锁存器的门控时钟</strong></p><p>​为了防止高电平被意外截断，需要使用锁存器保证 在CLK为1时，即使EN拉低，GATED_CLK输出保持不变。所以需要负锁存器，在CLK拉低时，对EN进行采样，CLK拉高时锁存器的输出不变。这样可以得到完整的时钟波形</p><img src="/2024/012448005/image-20240220105432984.png" alt style="zoom: 50%;"><p><strong>使用锁存器而不使用寄存器的原因：节省面积，一个DFF需要两个锁存器，而且还能降低功耗</strong></p><ul><li><p><strong>并不是所有的寄存器都要复位信号，一般情况下，控制和使能信号需要复位，数据信号不需要复位。这样可以节省面积和功耗</strong></p></li><li><p>常值的乘除法都可以进行优化；</p><p>除以一个数等于乘这个数的倒数；<br>一个数乘480，&#x3D;》 x*(512-32)</p></li><li><p>锁存器容易产生毛刺glitch</p></li><li><p>摩尔状态机输出只与当前状态有关，米利状态机不仅与当前状态有关，还取决于输入；<br>因为输入的组合逻辑，所以米利状态机要比摩尔状态机输出快一个周期。</p></li></ul><h5 id="计算bit的位宽"><a href="#计算bit的位宽" class="headerlink" title="计算bit的位宽"></a>计算bit的位宽</h5><p>​两个unsigned 8bit数相加&#x2F;乘，需要设置相应的位宽为：9bit&#x2F;16bit<br>​两个signed 8bti数相加&#x2F;乘，需要设置结果位宽为：9bit&#x2F;15bit</p><h3 id="乒乓操作"><a href="#乒乓操作" class="headerlink" title="乒乓操作"></a>乒乓操作</h3><img src="/2024/012448005/image-20240303220028047.png" alt="image-20240303220028047" style="zoom: 33%;"><p>输入数据通过输入选择单元和输出选择单元，有节拍的切换数据流，形成流水线的操作。</p><p>最大的特点：站在乒乓操作模块两侧，输入和输出数据的连续不断的，没有停顿。</p><ul><li><p>节省缓冲区的长度</p><p>前提是所有的数据并不是同时使用的，这样速度就会慢一些。</p></li><li><p>用低速模块处理高速数据流</p><p>使用DPRAM，读写是可以同时进行的。假设时钟为10ms，前5ms向DPRAM1写入数据，后5ms就可以读出前5ms写入的低地址数据，第一个10ms就多出5ms。第二个10ms，DPRAM1的数据完全可以读出数据。第三个10ms，前5ms继续向DPRAM1的低地址写入数据，但是这5ms可以读出高地址的数据，相当于又多出来5ms。因此，对于DPRAM1中的数据，最多有 <strong>20ms</strong>时间可以给下级处理，对应两个时钟周期，数据吞吐量为50Mbps。</p><img src="/2024/012448005/image-20240303230150945.png" alt="image-20240303230150945" style="zoom:40%;"></li></ul><p><strong>静态多电压技术</strong>，可以有效降低动态功耗。但是会使得静态功耗恶化，因为低电压的缺点带来的是低阈值电压，管子更容易开启，漏电流变大。</p><h2 id="设计方法学"><a href="#设计方法学" class="headerlink" title="设计方法学"></a>设计方法学</h2><h3 id="解耦合"><a href="#解耦合" class="headerlink" title="解耦合"></a>解耦合</h3><p>​降低模块间的依赖关系，提高可移植性。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>icc_flow</title>
      <link href="/2024/012139355.html"/>
      <url>/2024/012139355.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>decap cell的插入</p><p>解决IR drop的，为逻辑单元提供稳定的电压。去耦电容，提供稳定的电源和地，降低电源噪声和提高电噪声免疫性的特殊电路元件。<br>Decap cell是小电容器，位于整个布局的VDD和GND之间。当逻辑电路汲取大量电流时，该电容器为该电路提供额外的电荷当逻辑电路不吸收任何电流时，decap cell被充电至最大电容利用decap cell来降低动态IR drop。<br>decap cell是带金属层的，建议routing结束后再加，否则影响route走线。</p></li></ul><img src="/2024/012139355/image-20240121233331816.png" alt style="zoom:50%;"><ul><li><p>filler cell</p><p>为确保所有VDD和VSS rail连接正常，我们需要使用filler cell填充标准单元row中的空白区域。filler cell没有逻辑连接，同时还包含衬底nwell连接以改善衬底偏置。</p></li></ul><p>​在routing后进行的，先插入decap cell，再插入filler cell</p><p>​插完decap cell和filler cell之后，我们可以发现整个设计都被cell给填充了，可以把芯片的表面做平，<strong>在stdcell区域是不允许有间隙的存在的</strong>，也可以用命令checkFiller来检查。</p><p>​<strong>作用：</strong></p><ol><li><p><strong>平整表面</strong>：在后续的工艺步骤中，便于后续工艺的抛光。</p></li><li><p><strong>获得连续的VDD和VSS</strong></p></li><li><p>保证版图连续性和均匀性，保证掺杂均匀性，减小工艺变异，增强结构稳健性。</p></li><li><p><strong>优化功耗和性能</strong>：通过在空白区域添加 Filler Cells，电流路径可能会更均匀，有助于减少电磁干扰和功耗。</p></li></ol><ul><li><p>dummy</p><p>主要有以下几种用途：</p><ol><li>保证可制造性，DFM。tapeout时会检查芯片的密度，插入dummy mental，dummy poly，dummy diff</li><li>在关键器件旁边加入dummy 器件，比如cap，res，mos等</li><li>避免芯片中的noise对关键信号的影响，在关键信号的周围加上dummy routing layer或者dummy元器件，shielding。</li></ol></li><li><p>获取整个design的instance个数和面积</p><p>report_qor</p><img src="/2024/012139355/image-20240123212321424.png" alt style="zoom:67%;"><img src="/2024/012139355/abc207bf21bdcaa65b8339f664292df.jpg" alt style="zoom: 33%;"></li></ul><p>​gate count计算：等效的门数，只是一个粗略的计算，不是精确值。将两输入与非门的面积作为等效参考，即一个gate的面积。用所有std cell的面积除以2输入与非门的面积，得到是数值为用到的总门数。总门数*4得到的是晶体管数目。</p><blockquote><p>DC综合两输入与非门的面积为1.44，所有cell的总面积为41.2w平方微米。等效门数为41.2&#x2F;1.44 &#x3D; 28.61w逻辑门。</p></blockquote><ul><li><p>查看clock skew的值</p><ol><li><p>通过report_timing</p><p>得到的skew会偏大一些，因为skew经过derate。</p></li><li><p>通过report clcok tree</p></li></ol></li><li><p>clock skew的设置</p><p>在长时钟树时，要设置targe skew，告诉工具clock skew期望值多少，一般设置为50-80ps，100ps以内都正常。</p></li></ul><p>ICC cts的相关设置</p><p><a href="https://www.cnblogs.com/IClearner/p/6606360.html">https://www.cnblogs.com/IClearner/p/6606360.html</a></p><ul><li><p>wire spreading（连线扩展）</p><p>也成为critical area analysis关键区域分析的地方</p><p>bg：制造过程中可能会出现随机的颗粒缺陷导致短路或者开路<br>最小间距的连线最容易造成短路，最小宽度的连线最容易造成开路。</p><p>解决办法：容易短路的地方，增加间距。容易断路的地方，增加线宽。</p><img src="/2024/012139355/20200729093453667.png" alt style="zoom: 67%;">icc_tcl:  spread_zrt_wires / widen_zrt_wires</li><li><p>检查placement是否合法</p></li></ul><p>​placement后，执行<code>check_legality</code></p><ul><li>ICC 在导入网表后，没有tie cell是正常的，因为是在placement才加入tie cell；High Fanout Net也是正常的，还没有插入buffer进行优化。</li></ul><img src="/2024/012139355/image-20231224214002120.png" style="zoom: 67%;"><ul><li>后端流程</li></ul><img src="/2024/012139355/image-20231224215828226.png" alt style="zoom:67%;"><ul><li>时序库 （*.lib， *db）表征的2个模型</li></ul><p>​.NLDM (non linear delay model)，65nm 之前工艺 </p><p>​.CCS （composite current source）, 更精确，同时能描述crosstalk （信号干扰）的信息 </p><ul><li>max_transition &#x2F; input_transition</li></ul><p>​一般来说，sdc中关于max_transition的值参考lib库中给定的transition值，尽量取中间范围。transition设置的过小也不好，会导致工具插入很多cell，增大了芯片的面积。</p><p>​解决措施：在DC和ICC时设置max_transition为0.4，在PT时设置0.6</p><p><img src="/2024/012139355/3158545f6cb70988f94b0214218380a.jpg"></p><p>出现上述问题的原因是因为在做lvs时，网表与版图不匹配，可以将icc生成的网表导入到calibre里面做lvs。在icc pr后的网表中，在module里面并没有上述的Q端口，而是使用的Qn，接一个反相器输出的，这个是和版图对应的。</p><p>CCS的lib中有 crosstalk的信息；</p><p>物理信息库<br>     1. LEF(library exchange format): cadence 的物理信息库，只有布局布线要用到信息，pins…<br>     2. milkway：synopsys的物理库<br>     3. GDS：流片用的信息，所有的层次都有<br>     4. CDL：器件级spice网表，lvs和仿真</p><p><img src="/2024/012139355/wps2.jpg">（LEF GDS)</p><p>DC在做综合的时候，把DRC的约束优先级设置为最高，依次是：max_capacitance,max_transition, max_fanout</p><p>DC中报告的漏电功耗是准的，动态功耗不准。</p><ul><li><h4 id="Formality"><a href="#Formality" class="headerlink" title="Formality"></a><strong>Formality</strong></h4><p>只验证逻辑，不验证功能。比较的原理：formality将设计分为多个logic cone和compare point</p><img src="/2024/012139355/image-20240102224954497.png" alt style="zoom: 80%;"></li></ul><p><img src="/2024/012139355/image-20240102225055027.png"></p><ul><li><p>DC和PT分析时序路径的不同</p><p>DC</p><ol><li>过约束，留出一定的裕量给后续的步骤</li><li>时钟网络的延迟的不准确的，一定设置为ideal clock network</li><li>线延迟也是基于库中的wire load model估计出来的</li><li>通常在单一PVT的corner进行的，比如wc</li></ol><p>ICC</p><ol><li>不需要过约束，根据实际的电路计算</li><li>所有网络 clock，wire network均为实际的</li><li>可以从版图中抽取RC寄生参数，计算net delay</li><li>需要在多个PVT corner下验证</li></ol></li><li><p>修复setup违例</p><p>满足 Tskew + Tclk &gt; Tlogic + Tsetup + Tclk2q</p><ol><li>提高Tclk，降低频率</li><li>减小Tlogic，优化组合逻辑，划分流水线</li><li>减小Tclk2q，将HVT管换成LVT管子，速度变快</li></ol></li><li><p>修复hold违例</p><p>满足Tclk2q + Tlogic(min) &gt; Thold + Tskew</p><ol><li>增加组合逻辑延迟，插入buffer</li><li>降低Tskew，甚至用负的skew</li></ol></li></ul><p>SDF：标准延迟格式的文件，描述了设计中的时序信息，包括net delay和cell delay，sdf文件可以直接用于后仿</p><p>SPEF：标准寄生格式交换文件，提供具体的R和C参数，延时计算相对准确。</p><p><img src="/2024/012139355/image-20240103100523201.png"></p><p>在PT中设置clock约束时和DC的区别</p><p><img src="/2024/012139355/image-20240103100716030.png"></p><p><img src="/2024/012139355/image-20240103101023594.png"></p><p>ECO是在post layout上进行的。</p><p>PT自动进行ECO，PT工具主要通过resizing cells和插入buffer来完成ECO</p><ul><li><p>OCV</p><p><strong>只在post layout进行分析。</strong></p></li><li><p>约束输入端口</p><pre class="line-numbers language-none"><code class="language-none">set_drive_cellset_driveset_input_transition<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这三条语句都是约束输入端口的，但是适用场景不同。</p><ol><li><p>set_drive_cell</p><p>应用场景：Block level<br>从库中找一个cell来驱动这个模块的输入端口port，更贴近实际的情况。这种应用于模块级别的。</p></li><li><p>set_drive</p><p>应用场景：Chip level<br>通过为输入端口指定电阻值的方法来为其定义外部驱动强度，典型的值是0.05，单位取工艺库中电阻的单位，一般为kΩ；该值越小表示驱动能力越大</p></li><li><p>set_input_transition</p><p>应用场景：Chip level<br>为输入端口指定一个固定的transition时间，transition时间相对独立于当前设计中的电容。transition time越大，导致短路电流越大，功耗也越大。</p></li></ol></li><li><p><strong>课题组项目后端的细节处理</strong></p><ol><li>在版图布局中，由于SPI模块与数字芯片core的位置距离较远，需要对数字芯片CORE的输入端口进行约束，设置input_transition_time为0.5；并在SPI的输入端口添加模拟的buffer，提高驱动能力。</li><li>在之前的芯片测试时，发现控制字的输入有问题，有时候需要SPI写入两次才能起作用。后来怀疑是SPI模块给到数字core的时钟信号走线太长，到core时候，clk的驱动就比较弱了。再后面的流片时，在数字core的clk输入端口加了buffer，解决了这个问题。</li></ol></li><li><p>IR drop</p><p>电阻对电流有阻碍作用，而导致电压下降；<br>大电流或者长导线会带来IR drop，通常在芯片的电源和地中出现。</p></li></ul><p>ICC在global routing绕线期间，以GRC为为最小单位安排走线。</p><p>report_congestion报告会计算每个GRC的 # of available routing tracks（#1）和 # of nets crossing GRC edge（#2），如果#2大于#1，就存在overflow，即走线资源不足。而congestion报告会给出每个方向以及每一层存在overflow问题的GRC数量（及百分比），overflow总数和单个GRC max的overflow数量，根据这些数据可以判断congestion的情况。如果有GRC的overflow大于10，则可能走线走不通，如果有2%或者更多的GRC存在overflow，那么可能会出现SI和timing的问题。</p><h3 id="修复违例"><a href="#修复违例" class="headerlink" title="修复违例"></a>修复违例</h3><p>place_opt之后，如果有小的setup违例，可以使用<code>psynopt</code>命令修复</p>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StarRC_flow</title>
      <link href="/2024/012044084.html"/>
      <url>/2024/012044084.html</url>
      
        <content type="html"><![CDATA[<p>根据TSMC signoff的标准</p><p><img src="/2024/012044084/image-20240120174002288.png"></p><p>整理如下：</p><table><thead><tr><th><strong>setup</strong></th><th>process</th><th>voltage</th><th>tempature</th><th>library db</th><th>spef</th></tr></thead><tbody><tr><td>wc+Cworst</td><td>ss</td><td>1.08v</td><td>125</td><td>tcbn65lpwc1d081d08_ccs</td><td>Cworst125</td></tr><tr><td>wcl+Cworst</td><td>ss</td><td>1.08v</td><td>-40</td><td>tcbn65lpwcl1d081d08_ccs</td><td>Cworstm40</td></tr><tr><td><strong>tc+Ctypical</strong></td><td><strong>tt</strong></td><td><strong>1.2v</strong></td><td><strong>-40</strong></td><td><strong>tcbn65lplt1d21d2_ccs</strong></td><td><strong>Ctypical25</strong></td></tr><tr><td><strong>hold</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>wc+Cworst</td><td>ss</td><td>1.08v</td><td>125</td><td>tcbn65lpwc1d081d08_ccs</td><td>Cworst125</td></tr><tr><td>wcl+Cworst</td><td>ss</td><td>1.08v</td><td>-40</td><td>tcbn65lpwcl1d081d08_ccs</td><td>Cworstm40</td></tr><tr><td><del>bc+Cworst</del></td><td><del>ff</del></td><td><del>1.32v</del></td><td><del>0</del></td><td><del>tcbn65lpbc1d321d32_ccs</del></td><td><del>Cworst0</del></td></tr><tr><td><del>bc+Cbest</del></td><td><del>ff</del></td><td><del>1.32v</del></td><td><del>0</del></td><td><del>tcbn65lpbc1d321d32_ccs</del></td><td><del>Cbest0</del></td></tr><tr><td>lt+Cworst</td><td>ff</td><td>1.32v</td><td>-40</td><td>tcbn65lplt1d321d32_ccs</td><td>Cworstm40</td></tr><tr><td><strong>lt+Cbest</strong></td><td>ff</td><td>1.32v</td><td>-40</td><td>tcbn65lplt1d321d32_ccs</td><td>Cbestm40</td></tr><tr><td><strong>tc+Ctypical</strong></td><td><strong>tt</strong></td><td><strong>1.2v</strong></td><td><strong>-40</strong></td><td><strong>tcbn65lplt1d21d2_ccs</strong></td><td><strong>Ctypical25</strong></td></tr></tbody></table><blockquote><p>删除的bc+Cbest&#x2F;Cworst，原因是这两种case位于wc和lt之间，没必须再去分析。</p></blockquote><p>Q：在检查hold违例时，lt+Cbest下已经保证了组合逻辑是最短的，为什么要进行Cworst的组合？</p><p>因此，lt仅仅是满足了路径上组合逻辑的延迟，而时钟网络的延迟带来的skew对hold检查也非常重要，所以要进行Cworst检查。</p>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StarRC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcl脚本</title>
      <link href="/2024/011824060.html"/>
      <url>/2024/011824060.html</url>
      
        <content type="html"><![CDATA[<p>set endp xxx&#x2F;D</p><p>set path [get_timing_path -to $endp -group reg2reg]</p><p>set points [get_attri $path points]</p><p>point有很多属性</p><img src="/2024/011824060/image-20240118232406988.png" alt style="zoom:50%;"><pre class=" language-tcl"><code class="language-tcl">foreach_in_coll point $<span class="token variable">points</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token keyword">set</span> <span class="token variable">obj</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">point</span> object<span class="token punctuation">]</span>     <span class="token keyword">set</span> <span class="token variable">objn</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">obj</span> full_name<span class="token punctuation">]</span>    <span class="token keyword">set</span> <span class="token variable">dir</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">obj</span> dir<span class="token punctuation">]</span>    <span class="token builtin">if</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;dir=="in"&amp;#125; &amp;#123;continue&amp;#125;</span>    <span class="token keyword">set</span> <span class="token variable">inst</span> <span class="token punctuation">[</span><span class="token keyword">file</span> dir $<span class="token variable">objn</span><span class="token punctuation">]</span>    <span class="token keyword">set</span> <span class="token variable">cell</span> <span class="token punctuation">[</span>get_cell $<span class="token variable">inst</span><span class="token punctuation">]</span>    <span class="token keyword">set</span> <span class="token variable">ref</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">cell</span> ref_name<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token builtin">proc</span> <span class="token function">is_hvt</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;ref&amp;#125; &amp;#123;</span>    <span class="token builtin">if</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;string match "*_HVT" $ref&amp;#125; &amp;#123;</span>        retrun 1    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125; else &amp;#123;retrun 0&amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token comment" spellcheck="true"># if &amp;#123;![is_hvt $ref] || ![is_lvt $ref]&amp;#125; &amp;#123;&amp;#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tcl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PT flow</title>
      <link href="/2024/011821871.html"/>
      <url>/2024/011821871.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>检查反标率</p><p>跑PT时，需要保证每个corner使用的lib和spef是对应的。读入设计的spef和网表netlist后，需要report_annotated_parasitics命令报出反标情况。</p></li></ul><p>​反标问题我们是看Pin to pin nets的反标，如果这一行的Not Annotated非0，那么就一定存在RC反标问题。常见反标问题原因：</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">spef正确，但netlist错误Netlist正确，spef错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2024/011821871/image-20240118192337980.png" alt style="zoom: 50%;"><p>手修timing</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">size_cell U324 INVD8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>setup </p><p>替换大驱动的cell。 x4 &#x3D;&gt; x16<br>(有时候替换了大cell，delay会增加，因为驱动能力的增加不足以抵消input transition和output load的增加)</p></li><li><p>max_capacitance </p><p>方法1：替换大的cell，提高阈值。<br>方法2：减小实际的capacitance，通过在ICC中插入buffer实现</p></li><li><p>max_transition</p><p>方法1：替换大的cell，提高阈值。<br>方法2：减小实际的transition，通过在ICC中插入buffer实现</p></li><li><p>hold</p><ul><li>get_lib_cell  *&#x2F;*BUF*</li><li>insert_buffer [通过report_timing -delay_type min 得到的] *BUF*</li></ul></li></ul><p> report_constraint  -all_violators：可以看出违例的endpoint  summary</p><p>syn off :关闭高亮显示</p><p>查看某个net连接的cell：all_fanout -from U503&#x2F;E -flat -endpoints_only</p><p>report_timing -transition -from U399 -delay_type max:可以查看具体的cell</p><h3 id="timing-eco"><a href="#timing-eco" class="headerlink" title="timing eco"></a>timing eco</h3><p>修违例的顺序：1. drc的错误 2. 再修setup hold</p><p>尽可能使用size_cell来修违例，而不用insert_buffer，因为RC是准确的，保证net delay是对的。</p><p>如果想运行dmsa，那么在启动pt的时候，必须加上-mul选项启动多线程，不然是无法进行dmsa优化的。</p><p>在icc中，摆放eco 的cell</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl"><span class="token keyword">source</span> iccpt.tcllegalize_placement <span class="token operator">-</span>eco <span class="token operator">-</span>incremental route_zrt_eco <span class="token operator">-</span>utilize_dangling_wires true <span class="token operator">-</span>reuse_existing_global_route true <span class="token operator">-</span>open_net_driven true save_mv_cel <span class="token operator">-</span>as eco_routed <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在ICC中打开mw_lib中的cell</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl"><span class="token keyword">source</span> xxx.setupopen_mw_lib ..<span class="token operator">/</span>..<span class="token operator">/</span>XXX.libopen_mw_cell FMCW_DCORE_TOP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>max_transition设置</strong></p><p>signoff的标准是0.6，在pr阶段一般会过约束，可以将data_path设置为0.5，clock上设置为0.45，而clock path的max transition在cts之前再约束sdc里面就不再单独设置。</p></li></ul><p>ICC中修复hold time</p><ol><li><p>cts之前</p><p>psynopt -only_hold_time</p></li><li><p>routing阶段<br>指定布线优化选项来修复<br>route_opt -incr -only_hold_time</p></li><li><p>chipfinish</p><p>3.1 可以用CCD来修复：</p><p>&gt;focal_opt -concurrent_clock_and_data -hold_endpoints all</p><p>3.2可以让软件自动对所有hold endpoints来修复：</p><p>&gt;focal_opt -hold_endpoints all -effort high</p><p>其实可以指定某些hold endpoints来单独对它们进行优化，但是自己尝试发现没有什么用，没有PT效果那么好。</p><p>3.3 指定REG2REG路径进行修复</p><p>如果违规都集中在REG2REG的路径上，那么用下面的命令更好：</p><p>&gt;focal_opt -hold_endpoints all -register_to_register</p></li></ol><p>​3.4 手工ECO修复</p><p>​如果上述方法都不行的话，就需要手动插入buffer或者delay cell来解决了，即采用ECO的方法来手工解决。在插入之前要确保没有插入Core filler，或者有Filler的话要remove，需要注意的是不用全部remove，在放置eco cell的命令的后边会有移除部分filler的选项哟，这个非常棒。</p><p>3.5 用PT进行ECO修复</p><p>​当然这些也是可以不用手工ECO的方法，而将整个设计的网表、spef导入PT，让PT自己修复，然后导出ECO的脚本，然后将脚本导入ICC进行修复，不过感觉这个过程挺麻烦的，还不如手工来的方便，具体方法可以参见ICCECO流程那一部分。</p><h5 id="记录修复timing-removal的错误"><a href="#记录修复timing-removal的错误" class="headerlink" title="记录修复timing-removal的错误"></a>记录修复timing-removal的错误</h5><p>2024&#x2F;1&#x2F;23<br>尝试使用pt的dmsa模式修复hold time时，发现有removal的违例，很是震惊。从来没遇到过</p><img src="/2024/011821871/image-20240123205008592.png" alt style="zoom: 67%;"><p>之前clock_uncertainty的值不太对，只是修改了这个地方。就出现了recovery的违例。以为是这里的问题，修改后，发现还是有removal的违例，然后一阵搜资料。最后查看了pt 违例的timing path，发现是pt的sdc里面的input&#x2F;output delay设置的太小。导致有大量的removal违例。（类比于hold）。相当于数据保持的时间太多，不满足removal检查。</p><p>将input output delay设置好后（之前是0.35，修改为3.5。在ICC中也是3.5），removal没有违例。</p><img src="/2024/011821871/image-20240123211117779.png" alt style="zoom:67%;"><img src="/2024/011821871/eb5a2b0dce25b2ed55c869128fdd6f0.jpg" alt style="zoom: 33%;"><ul><li><p>recovery</p><p>如果report_timing的path，-end指向的是DFF的D端，则是分析setup，如果是DFF的rst端，则是recovery。</p></li><li><p>电路后仿真</p></li></ul><p>​在后仿真时，需要吃sdf文件。sdf文件既可以是ICC产生的，也可以是PT生成的。在进行带有延迟反标的仿真时，需要注意两个延迟文件之间的区别。<br>​在仿真激励tb中，使用系统函数$annotated来完成延迟反标。<br>​延迟反标的参数，有三种类型：最大、最小和典型。在ICC和PT导出的sdf文件中，每一个gate同样有三个参数。<strong>注意的是，如果不设置延迟反标的类型，会中间的默认典型值，ICC导出的sdf里面典型值不为0，PT导出sdf文件典型值为0，因此如果在使用annotated时，不指定最大最小延迟，默认典型延迟，在波形图中就不会有组合逻辑造成的多次信号跳变，导致延迟参数反标不上去</strong></p><p>icc的sdf文件</p><p><img src="/2024/011821871/image-20240127193058698.png"></p><p>pt吐出的sdf文件</p><p><img src="/2024/011821871/image-20240127193134312.png"></p><p>​措施：在使用annotated函数时，指定max&#x2F;min延迟类型，其中max用于setup检查，min用于hold检查。</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">$<span class="token variable">sdf_annotate</span> <span class="token punctuation">(</span>“sdf_file”<span class="token punctuation">[</span>, “module_instance”<span class="token punctuation">]</span> <span class="token punctuation">[</span>,<span class="token operator">/</span><span class="token operator">/</span> 实例化“sdf_configfile”<span class="token punctuation">]</span><span class="token punctuation">[</span>,  <span class="token operator">/</span><span class="token operator">/</span> 一般缺省“sdf_logfile”<span class="token punctuation">]</span><span class="token punctuation">[</span>, <span class="token operator">/</span><span class="token operator">/</span> 指定vcs保存errors和warnings的log文件,<span class="token punctuation">(</span>modelsim没有这个选项<span class="token punctuation">)</span>“mtm_spec”<span class="token punctuation">]</span> <span class="token punctuation">[</span>,<span class="token operator">/</span><span class="token operator">/</span> 指定延迟类型，MINIMUM<span class="token punctuation">(</span>min<span class="token punctuation">)</span>, TYPICAL<span class="token punctuation">(</span>typ<span class="token punctuation">)</span>,MAXIMUM<span class="token punctuation">(</span>max<span class="token punctuation">)</span>“scale_factors”<span class="token punctuation">]</span><span class="token punctuation">[</span>,  <span class="token operator">/</span><span class="token operator">/</span> 缩放因子，默认1:1:1“scale_type” <span class="token operator">/</span><span class="token operator">/</span> 指定缩放之前延迟值得来源,“FROM_TYPICAL”,“FROM_MIMINUM”, <span class="token operator">/</span><span class="token operator">/</span> “FROM_MAXIMUM<span class="token string">"和"</span>FROM_MTM” <span class="token punctuation">(</span>default<span class="token punctuation">)</span>.<span class="token operator">/</span><span class="token operator">/</span> FROM_MINIMUX 选择SDF文件中mininum timing，组合逻辑的延时最小，侧重于hold time 的检查<span class="token operator">/</span><span class="token operator">/</span> FROM_TYPICAL 选择SDF文件中typical timing<span class="token operator">/</span><span class="token operator">/</span> FROM_MAXIMUM 选择SDF文件中maximum timing，组合逻辑的延时最大，侧重于setup time的检查<span class="token punctuation">]</span><span class="token punctuation">)</span>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在后仿过程中，需要care的点<ol><li>input 端口都要给定值，不能floating不给初值，否则内部出现x态。</li><li>激励中的时钟频率，不能超过STA时的。</li><li>有些信号是反逻辑，可能和前仿的信号不一致</li><li>如果出现了setup的违例导致功能错误，可以对比STA中path的delay与波形的delay是否一致</li></ol></li></ul><p>由于集成电路制造工艺的差异，实际电路中器件的延迟总会在一定范围内波动。Verilog 中，用户不仅可以指定 3 种类型的门延迟，还可以对每种类型的门延迟指定其最小值、典型值和最大值。</p><ul><li><p>后仿的各种组合情况</p><p>PVT_corner + fast&#x2F;typical&#x2F;slow SDF</p></li><li><p>ECO</p><p>在芯片设计完成后，用于修复出现的问题。分为两个阶段：pre-mask ECO和post-mask ECO；</p></li></ul><p>​pre-mask ECO ：在设计完成后芯片还未进入工艺制造前所进行的修改。该流程的主要目的是解决设计中存在的问题，如电路逻辑不正确、功耗太高或者时序不满足等问题。</p><p>​ post-mask ECO ：设计团队需要将已制作的芯片样品反馈回来进行修改，从而修复设计中的问题。通常，post-mask ECO 采用物理层面上的修改来解决问题，例如通过引入金属连接或者改变物理结构等方式进行修复。</p>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步复位和同步复位</title>
      <link href="/2023/122543491.html"/>
      <url>/2023/122543491.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>常用的复位方式</p><ol><li>带同步复位的寄存器后紧跟一个不带复位的寄存器</li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>q1 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">begin</span>q1 <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span>q2 <span class="token operator">&lt;=</span> q1<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// 错误的复位方式    q2没有被正确的复位，并且综合生成的电路也非常奇怪。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/122543491/image-20231225203911890.png" alt style="zoom: 33%;"></li></ul><p>​因为在rst_n有效时，q2没有动作，所以rst_n作为第二级寄存器的ld_en信号，将q1的结果输出在q2上。</p><p><strong>正确的code style</strong></p><pre class="line-numbers language-none"><code class="language-none">always @(posedge clk) beginif(!nrst)q1 &lt;&#x3D; 0;else q1 &lt;&#x3D; d;endalways @(posedge clk)q2 &lt;&#x3D; q1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/122543491/image-20231225204528665.png" alt style="zoom: 33%;"><p><strong>同步复位</strong>：复位信号，只在clk的有效边沿才会发挥作用，参与输入信号d的组合逻辑，相当于做“与”逻辑。这种情况下，if-else的优先级就很重要。reset需要在if中发挥作用。</p><p>使用同步复位出现的问题：综合工具DC无法分辨复位信号和其他数据信号。<br>带同步复位的可加载触发器如下</p><img src="/2023/122543491/image-20240220164819082.png" alt style="zoom:50%;"><p>​综合工具也可能会综合成下面的结构，两者实现的功能相同。</p><img src="/2023/122543491/image-20240220164859844.png" alt style="zoom:50%;"><p>​第二种方式在门级仿真时，如果rst_n信号为低，mux的输入都是0，如果load是x态，导致触发器会输出x态，而不会复位。<strong>本质区别是 rst_n的优先级，第一种方式rst_n的优先级要高于第二种，第一种可以保证在仿真时复位的有效性</strong>，这两种方式在实际硬件中，都是可以正常复位的。因此，在仿真过程中，使用编译指令，告知综合工具，让复位信号rst_n尽可能靠近触发器，提高复位信号的优先级。</p><p><strong>优点：</strong></p><pre><code>1. 可以使用基于周期仿真的模拟器，比如verilator。2. 确保了所有的电路都是同步的。3. 由于是时钟有效时，才可以复位，所以可以过滤一些reset的毛刺。</code></pre><p><strong>缺点：</strong></p><ol><li>同步复位可能需要脉冲展宽器来保证复位脉冲足够宽</li><li>对于时钟门控的寄存器，同步复位无效。</li></ol><ul><li><strong>三态总线的复位</strong></li></ul><p>为了防止芯片上电时，内部三态总线上的总线竞争，就迫切需要时钟产生复位；</p><p>因此，芯片需要具有异步复位的功能。</p><img src="/2023/122543491/image-20231225235555437.png" alt style="zoom: 33%;"><p>也可以使用同步复位的方式实现，但是也必须使用复位信号直接撤销三态门的使能，寄存器的输出必须与rst_n做与；</p><img src="/2023/122543491/image-20231225235658088.png" alt style="zoom: 33%;"><h4 id="异步复位"><a href="#异步复位" class="headerlink" title="异步复位"></a>异步复位</h4><p>​异步复位可以保证 数据路径上没有复位信号的参与，在复位时，数据路径是干净的。</p><p>​异步复位最大的问题是 复位信号的释放。</p><p>​在DC阶段，对于clock和reset信号，通过设置输入驱动为0，表示驱动能力最强，<code>set_drive 0</code>。并设置<code>set_dont_touch_network</code>保护clk和reset信号不被修改。这样做的目的是 因为综合时，没有布局布线信息，在dc时即使插入buffer对clk和reset信号优化，也是没有意义的，到ICC阶段也会重新插buffer。反而，可能会对物理实现带来负面影响。所以最好的办法是不处理，在CTS时才真正的解决clk和reset。</p><p><strong>优点：</strong></p><pre><code> 1. 保证复位信号不会参与到数据路径中，保证数据路径是干净的。 2. 不需要时钟，就可以进行电路的复位。</code></pre><p><strong>缺点：</strong></p><ol><li>不能使用基于周期的仿真器</li><li>异步复位时，不会有亚稳态的影响，但是在释放时，很有可能clk是上升沿会采到rstn在变化，造成亚稳态。导致复位后的稳定状态丢失。</li><li>会受到毛刺的影响</li><li>异步复位 带来时序分析的困难</li></ol><ul><li><p>异步复位和异步置位寄存器</p><p>尽可能避免出现该类型的寄存器，否则，可能会造成综合前后结果不一致的问题。</p></li></ul><p>异步复位需要考虑recovery time和removal time的违例。</p><p>recovery time类似于setup time，在有效时钟沿上升之前，rst发生变化的最短时间。</p><p>removal time类似hold time，在有效时钟沿上升之后，rst发生变化所需要的最短时间。</p><ul><li><p>key points</p><p><strong>每个使用异步复位的ASIC电路，都应该包括复位同步器电路</strong>，也就是异步复位，同步释放。</p><p>异步复位同步器综合了两者的优点，</p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>nrst1 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>nrst2 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>nrst1 <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>nrst2 <span class="token operator">&lt;=</span> nrst1<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span>第二级的nrst2是为了消除，第一级异步复位信号释放带来的任何亚稳态。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/122543491/image-20231226100118399.png" alt style="zoom:50%;"><ul><li><p><strong>异步复位毛刺过滤器</strong></p><p>通过延迟电路，将延迟前后的信号做”与”，即可得到真正的复位信号。</p><img src="/2023/122543491/image-20240220172053034.png" alt style="zoom: 50%;"></li></ul><h5 id="容易出现的问题"><a href="#容易出现的问题" class="headerlink" title="容易出现的问题"></a>容易出现的问题</h5><ul><li>异步复位容易产生毛刺，导致整个电路发生复位；<br>解决办法：使用毛刺过滤电路；<br>对于时序逻辑的复位信号，当有连续周期的reset时才进行复位；<br>对于组合逻辑的复位信号，使用reset_delay &amp; reset_delay10ns判断复位；</li><li>复位信号的扇出很大，需要特殊考虑<br>解决办法：和cts一样处理；</li></ul><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><blockquote><p>《 硬件架构的艺术 数字电路的设计方法与技术》</p><p><a href="https://zhuanlan.zhihu.com/p/104550266">https://zhuanlan.zhihu.com/p/104550266</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="/2023/11277120.html"/>
      <url>/2023/11277120.html</url>
      
        <content type="html"><![CDATA[<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="Makefile的运行"><a href="#Makefile的运行" class="headerlink" title="Makefile的运行"></a>Makefile的运行</h3><p>make -f 文件名，执行特定的Makefile文件<br>Make 的默认行为是执行Makefile的第一个target，该目标一般会带起多个目标的执行。目标中有&#x3D;，或者-打头的不能指定为终极目标，因为这些字符的目标会被解析成命令行参数或者变量。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> all <span class="token target symbol">all</span><span class="token punctuation">:</span> prog1 prog2 prog3 prog4<span class="token comment"># 通过make all执行所有的target</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>检查规则(常用)</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-n</span> 打印命令，不执行<span class="token parameter variable">-s</span> ：全面禁止命令的显示<span class="token parameter variable">-q</span> 寻找目标，找到什么都不输出，找不到打印错误error<span class="token parameter variable">-B</span> 认为所有目标都需要重编译<span class="token parameter variable">-C</span> <span class="token operator">&lt;</span>dir<span class="token operator">></span> 指定读取Makefile的目录，如果有多个“-C”参数，make 的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。比如“make <span class="token parameter variable">-C</span> ~hchen/test <span class="token parameter variable">-C</span> prog”等价于“make <span class="token parameter variable">-C</span> ~hchen/test/prog”。<span class="token parameter variable">-I</span> <span class="token operator">&lt;</span>dir<span class="token operator">></span> 指定一个被包含Makefile的搜索目标。可以使用多个“-I”参数来指定多个目录<span class="token parameter variable">-t</span> 更新target的时间，组织生成目标的命令运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>命令执行顺序</li></ul><p>命令顺序执行，如果想要当前的命令在下一行使用，需要将下行命令放在当前行，并加上“；”<br>默认使用&#x2F;bin&#x2F;sh标准执行命令</p><ul><li>命令执行出错</li></ul><p>有可能会终止整个make的执行；但是有时候命令出错是允许的，所以要在命令前加上“-”，表示忽略命令的出错。<br>或者通过命令行参数的方式，<br>-i make会忽略所有出错的命令<br>-k 表示命令出错时，终止该命令执行，但是继续执行其他规则</p><ul><li>嵌套执行make</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">subsystem</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C subdir//进入子目录，执行make选项var <span class="token operator">=</span> 123<span class="token keyword">export</span> var <span class="token comment"># 声明该变量传递给子make文件</span>make -w 进入或者退出目录时会有提示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Makefile中的变量"><a href="#Makefile中的变量" class="headerlink" title="Makefile中的变量"></a>Makefile中的变量</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">Var <span class="token operator">=</span> value类似C的<span class="token keyword">define</span>，强烈建议变量的引用使用括号，比如 <span class="token variable">$</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span>等号右侧的变量可以是Makefile文件后面的内容，就有可能导致递归，所以要使用 <span class="token operator">:=</span>，表示只能使用前面的变量。Var <span class="token operator">:=</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#定义一个变量，值是一个空格</span>Nullstring <span class="token operator">:=</span>space <span class="token operator">:=</span> <span class="token variable">$Nullstring</span> <span class="token comment">#end of the line</span>dir <span class="token operator">:=</span> /foo/bar    <span class="token comment">#end</span>加了<span class="token comment">#后，表示这个dir变量最后会有4个空格导致错误。</span>Foo <span class="token operator">?=</span> valueFoo如果没有定义过，就在此处定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>高级用法</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">1. 变量值的替换  Foo <span class="token operator">:=</span> a.o b.o c.o  Bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>Foo<span class="token punctuation">:</span>.o<span class="token operator">=</span>.c<span class="token punctuation">)</span>2. 变量的值当成变量  Foo <span class="token operator">:=</span> \<span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>3. 追加变量值 <span class="token operator">+=</span>  Object <span class="token operator">:=</span> main.o foo.o  Object <span class="token operator">+=</span> another.o如果前一次的是 <span class="token operator">:=</span> ，那么 <span class="token operator">+=</span> 会以 <span class="token operator">:=</span> 作为其赋值符4. 多行变量使用<span class="token keyword">define</span>   <span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>环境变量</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">如果在命令行参数中代入该变量，环境变量的值会被覆盖。如果make时指定了-e，环境变量会覆盖Makefile中定义的变量。Makefile中定义的变量都是全局变量，<span class="token variable">$@</span> <span class="token variable">$^…</span> 都属于规则型变量也可以为某个目标target设置局部变量，该变量会作用到有这个目标所引发的所有规则区域。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">prog</span> <span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -g<span class="token target symbol">prog</span> <span class="token punctuation">:</span> prog.o foo.o bar.o<span class="token variable">$</span><span class="token punctuation">(</span>GCC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.o foo.o bar.o<span class="token variable">$</span><span class="token punctuation">(</span>addprefix src/,foo bar<span class="token punctuation">)</span> 为每个文件名添加前缀src/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Makefile中的函数"><a href="#Makefile中的函数" class="headerlink" title="Makefile中的函数"></a>Makefile中的函数</h3><h4 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>patsubst <span class="token operator">&lt;</span>pattern<span class="token operator">></span>,<span class="token operator">&lt;</span>replacement<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找&lt;text&gt; 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 &lt;pattern&gt;<br>返回被替换后的字符串</p><p>pattern：可以包含通配符%，表示任意长度的字符串。也可以是subst的&lt;from&gt;</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>objects:.o<span class="token operator">=</span>.c<span class="token variable">)</span></span> 和 <span class="token variable"><span class="token variable">$(</span>patsubst %.o,%.c,<span class="token punctuation">$(</span>objects<span class="token punctuation">)</span><span class="token variable">)</span></span> 是一样的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>strip <span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token variable">)</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>去掉string开头和结尾的空字符</p><h4 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>findstring <span class="token operator">&lt;</span>find<span class="token operator">></span>,<span class="token operator">&lt;</span>in<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果找到，那么返回 &lt;find&gt; ，否则返回空字符串<br>在字串 &lt;in&gt; 中查找&lt;find&gt; 字串</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>filter <span class="token operator">&lt;</span>pattern<span class="token punctuation">..</span>.<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，保留符合模式 &lt;pattern&gt; 的单词。可以 有多个模式。 返回符合模式 &lt;pattern&gt; 的字串。<br>filter-out 功能与filter相反</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">sort</span> <span class="token operator">&lt;</span>list<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>给字符串 &lt;list&gt; 中的单词排序（升序）。<br>返回排序后的字符串，sort 函数会去掉 &lt;list&gt; 中相同的单词。</p><h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>word <span class="token operator">&lt;</span>n<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>取字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。（从一开始）<br>返回字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。如果 &lt;n&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串。</p><h4 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h4><p>$(wordlist <ss>,<e>,<text>)<br>从字符串 &lt;text&gt; 中取从 &lt;ss&gt; 开始到 &lt;e&gt; 的单词串。&lt;ss&gt; 和 &lt;e&gt; 是一个数字</text></e></ss></p><h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><p>$(words <text>)<br>统计 &lt;text&gt; 中字符串中的单词个数。 如果我们要取 &lt;text&gt; 中最后的一个单词，我们可以这样：</text></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>word <span class="token punctuation">$(</span>words <span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token punctuation">)</span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span> 。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>firstword <span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>取字符串 &lt;text&gt; 中的第一个单词。 </p><h4 id="dir-文件名操作函数"><a href="#dir-文件名操作函数" class="headerlink" title="dir 文件名操作函数"></a>dir 文件名操作函数</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">dir</span> <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出目录部分。目录部分是指最后一个反斜杠（&#x2F; ）之前的部分。 如果没有反斜杠，那么返回 .&#x2F;</p><h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>notdir <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出非目录部分。非目录部分是指最后一个反斜杠（&#x2F; ）之后的部分。</p><h4 id="Suffix"><a href="#Suffix" class="headerlink" title="Suffix"></a>Suffix</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>suffix <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出各个文件名的后缀</p><h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出各个文件名的前缀部分。</p><h4 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>addsuffix <span class="token operator">&lt;</span>suffix<span class="token operator">></span>,<span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加后缀，把后缀 &lt;suffix&gt; 加到 <names> 中的每个单词后面。</names></p><h4 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h4><p>$(addprefix <prefix>,&lt;names…&gt;)<br>把前缀 &lt;prefix&gt; 加到 &lt;names&gt; 中的每个单词前面。 </prefix></p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">join</span> <span class="token operator">&lt;</span>list<span class="token operator"><span class="token file-descriptor important">1</span>></span>,<span class="token operator">&lt;</span>list<span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接list1 和list2</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">join</span> aaa bbb , <span class="token number">111</span> <span class="token number">222</span> <span class="token number">333</span><span class="token variable">)</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值是 aaa111 bbb222 333</p><h4 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach 函数"></a>foreach 函数</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>foreach <span class="token operator">&lt;</span>var<span class="token operator">></span>,<span class="token operator">&lt;</span>list<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中，然后再执行 &lt;text&gt; 所包含的表达式。每一次 &lt;text&gt; 会返回一个字符串，循环过程中，&lt;text&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值.   var是一个临时变量，作用域只在 foreach 函数</p><p>&lt;var&gt; 最好是一个变量名,&lt;list&gt; 可以是一个表达式，而 &lt;text&gt; 中一般会使用 &lt;var&gt; 这个 参数来依次枚举 &lt;list&gt; 中的单词</p><h4 id="if-函数"><a href="#if-函数" class="headerlink" title="if 函数"></a>if 函数</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token keyword">if</span> <span class="token operator">&lt;</span>condition<span class="token operator">></span>,<span class="token operator">&lt;</span>then-part<span class="token operator">></span><span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span><span class="token keyword">if</span> <span class="token operator">&lt;</span>condition<span class="token operator">></span>,<span class="token operator">&lt;</span>then-part<span class="token operator">></span>,<span class="token operator">&lt;</span>else-part<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>即 if 函数的参数可以是两个，也可以是三个。&lt;condition&gt; 参数是 if 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，&lt;then-part&gt; 会被计算，否则 &lt;else-part&gt; 会被计算。</p><h4 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h4><p>操作系统 Shell 的命令<br>shell 函数把执行操作系统命令后的输出作为函数返回</p><h4 id="控制-make-的函数"><a href="#控制-make-的函数" class="headerlink" title="控制 make 的函数"></a>控制 make 的函数</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>error <span class="token operator">&lt;</span>text <span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>warning <span class="token operator">&lt;</span>text <span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>很像 error 函数，只是它并不会让 make 退出，只是输出一段警告信息，而 make 继续执行。</p><h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a><strong>wildcard</strong></h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#显示扩展名</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.v<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="readlink"><a href="#readlink" class="headerlink" title="readlink"></a>readlink</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">打印解析符号链接或符号链接的规范文件名-f 通过递归给出指定名称的符号链接当前脚本的绝对路径：readlink -m <span class="token variable">$0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="abspath"><a href="#abspath" class="headerlink" title="abspath"></a>abspath</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">abspath</span> ./src<span class="token punctuation">)</span> <span class="token comment"># 返回目录或者文件的绝对路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="用法"><a href="#用法" class="headerlink" title="$$ 用法"></a>$$ 用法</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">SRC <span class="token operator">:=</span> A.c B.c<span class="token target symbol">process</span><span class="token punctuation">:</span>for i in <span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span class="token punctuation">;</span> do \readlink -f <span class="token variable">$$i</span> >> <span class="token variable">$file</span> \done使用两个<span class="token variable">$$，是因为i在shell的for循环中展开，属于shell的变量，相当于两层变量的嵌套。make读到$$i时候，会进行转义，展开成$i，然后交给shell解释程序。施加了$$的变量，需要两次展开，才能得到变量的值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Makefile中C编译、链接选项"><a href="#Makefile中C编译、链接选项" class="headerlink" title="Makefile中C编译、链接选项"></a>Makefile中C编译、链接选项</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">CFLAGS参数<span class="token operator">|</span><span class="token operator">|</span>编译<span class="token operator">|</span><span class="token operator">|</span>-c<span class="token comment"># 将C编译成.o目标文件，不链接</span>-o<span class="token comment"># 重命名</span>-Idir<span class="token comment"># 将新路径添加到include路径中，-I. -I/opt/usr...</span>-Wall   <span class="token comment"># 生成所有warning，并停止编译</span>-w<span class="token comment"># 关闭所有warning</span>-O<span class="token comment"># 优化编译选项</span>LDFLAGS参数<span class="token operator">|</span><span class="token operator">|</span>链接<span class="token operator">|</span><span class="token operator">|</span>-lxxx<span class="token comment"># 添加动态链接库，在搜索目录中找xxx.a，xxx.so的库文件</span>-static<span class="token comment"># 使用静态链接库生成目标文件，避免使用共享库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim/vscode配置和操作</title>
      <link href="/2023/112521332.html"/>
      <url>/2023/112521332.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h3 id="实现一列序号递增"><a href="#实现一列序号递增" class="headerlink" title="实现一列序号递增"></a>实现一列序号递增</h3><p>ctrl-v 选中列，然后 g + ctrl-a</p><pre class=" language-vim"><code class="language-vim">my_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   my_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> my_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span></code></pre><h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><ul><li>bash下使用vim</li></ul><pre class=" language-bash"><code class="language-bash">vim -d file1 file2vimdiff file1 file2</code></pre><ul><li>已经打开一个文件，打开另外一个文件对比</li></ul><pre class=" language-bash"><code class="language-bash">vert diffsplit file2</code></pre><ul><li>打开两个文件</li></ul><pre class=" language-bash"><code class="language-bash">在两个文件中分别执行  diffthis</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim Vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpyGalss</title>
      <link href="/2023/112431792.html"/>
      <url>/2023/112431792.html</url>
      
        <content type="html"><![CDATA[<h3 id="SPYGLASS"><a href="#SPYGLASS" class="headerlink" title="SPYGLASS"></a>SPYGLASS</h3><p>主要用于检查设计中的跨时钟域CDC问题，包含五大模块：lint，CDC（跨时钟域检查），LP（低功耗），Constraint（约束），DFT（可测性）。类似pt，属于静态验证工具，不需要编写testbench。</p><p>Rule：spyglass进行RTL分析的最小单位.<br>Goal：是一系列相关rule的集合，组合起来完成RTL的某个特定任务，user可以用guidewave定义好的goal，也可以自定义，可以指定规则的顺序。<br>Sub-Methodology：一系列Goal的集合，用以达成某方面特定目标。</p><p>SGDC：Constraints文件，包含clock和reset等约束信息</p><pre class=" language-sdc"><code class="language-sdc">current_design "key_top"clock -name clk -period 10 -edge 0 5reset -name rstn -value 0</code></pre><p>Waiver：用以过滤一些结果的文件</p><p>CDC：检查异步信号有没有同步处理就使用，组合逻辑是否有毛刺。</p><p>parameter：可以在进行RTL分析之前设定某些参数，对检查过程进行一些约束。</p><ul><li>Lint 中各个goal主要检查什么？</li></ul><p><img src="/2023/112431792/image-20231128002240109.png"></p><ul><li>Lint 检查时设置方法学，检查目标集合</li></ul><p><img src="/2023/112431792/image-20231128002527247.png"></p><p>具体操作：</p><ul><li><p>按 ‘e’ 修改代码。</p></li><li><p>对于有问题的地方，比如锁存器，可以查看原理图。</p></li></ul><p>spyglass会生成较多报告，其中常用的是<strong>moresimple.rpt</strong>，显示源文件中的错误。</p><p>使用<strong>ifdef</strong>构造来启用固定代码，添加以下内容来启用宏，从而启用<strong>Fix_W415</strong>宏：</p><blockquote><p><strong>set_option define { Fix_W415 }</strong></p><p>可以替换掉文件开头定义的&#96;define</p></blockquote><ul><li><p>读入的文件</p><ol><li>设计文件：.v或者.sv</li><li>约束文件：.sgdc</li><li>HDL libraries：之前编译过的verilog库</li></ol></li></ul><pre class=" language-tcl"><code class="language-tcl"><span class="token comment" spellcheck="true"># tcl 命令</span>read_file <span class="token operator">-</span>type verilog  xx.vread_file <span class="token operator">-</span>type sourcelist filelist.fread_file <span class="token operator">-</span>type sgdc xxx.sgdc<span class="token comment" spellcheck="true"># common settings</span>set_option top xxxset_option enableSV yes<span class="token comment" spellcheck="true"># SDC文件可以直接被spyglass读取，自动转换成SGDC，需要进行以下设置</span>set_option sdc2sgdc yescurrent_design xxxsdc_data <span class="token operator">-</span>file ssss_src.sdc<span class="token comment" spellcheck="true">#设置异步复位的值</span>reset <span class="token operator">-</span>name <span class="token string">"xxx.xx.Z"</span> <span class="token operator">-</span>async <span class="token operator">-</span>value 0</code></pre><ul><li>约束文件 .sgdc</li></ul><p>​包括clock，reset，set_case_analysis( -name -value)</p><ul><li>文件不同颜色标识<ul><li>绿色代表该模块可分析，但是不可综合</li><li>黑色表示作为黑盒子存在</li><li>白色代表可分析，可综合</li></ul></li></ul><p>手动添加waiver放弃对一些电路的检查。</p><h6 id="生成报告"><a href="#生成报告" class="headerlink" title="生成报告"></a>生成报告</h6><pre><code>write_aggregate_report datasheet write_aggregate_report dashboard</code></pre><p><a href="https://blog.csdn.net/qq_21842097/article/details/122538986?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-122538986-blog-122534341.235%5Ev38%5Epc_relevant_sort_base3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-122538986-blog-122534341.235%5Ev38%5Epc_relevant_sort_base3&utm_relevant_index=1">https://blog.csdn.net/qq_21842097/article/details/122538986?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122538986-blog-122534341.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122538986-blog-122534341.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=1</a></p><ul><li><p>时钟和复位</p><p><strong>cdc_setup中的rules</strong>：<strong>clock_info1, reset_info1, setup_clock01</strong></p><ul><li><p>clock_info1</p><p>Primary Clocks: 普通输入时钟<br>Black box clocks：黑盒或工艺库单元输出的时钟<br>Derived：寄存器或工艺库单元输出的时钟<br>Undrived Clocks：悬空的线或者门控锁存器输出的时钟<br>Gated clocks：组合逻辑输出的时钟</p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>  clk1<span class="token punctuation">,</span>    <span class="token keyword">input</span>  rstn<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> d<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">wire</span> clk3<span class="token punctuation">,</span> clk4<span class="token punctuation">;</span><span class="token keyword">reg</span> clk2<span class="token punctuation">;</span><span class="token function">BB</span><span class="token punctuation">(</span>clk1<span class="token punctuation">,</span> clk3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk1 <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span> clk2 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> clk2 <span class="token operator">&lt;=</span> <span class="token operator">~</span>clk2<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk4 <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">end</span><span class="token keyword">endmodule</span></code></pre><p>clk1是primary clock，clk2是Derived clock，clk3是Black box clocks，clk4是Undrived Clocks</p></li><li><p>Reset_info1</p><table><thead><tr><th>普通复位</th><th>Primary Presets&#x2F;Clears</th></tr></thead><tbody><tr><td>黑盒（blackbox）或工艺库单元产生的复位</td><td>Black box Presets&#x2F;Clears</td></tr><tr><td>寄存器产生的复位</td><td>Derived Presets&#x2F;Clears</td></tr><tr><td>悬空的线产生的复位</td><td>Undrived Presets&#x2F;Clears</td></tr><tr><td>锁存器，三态器件产生的复位</td><td>Gated Presets&#x2F;Clears</td></tr></tbody></table></li><li><p>Setup_clock01</p><p>报告时钟源，时钟使能信号和clock cone<br>设计中多个输入时钟通过选择器后只输出一个时钟，输出的时钟称为clock cone。</p><img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70.png" alt style="zoom:50%;"></li></ul></li><li><p>CDC_setup_check</p><p><strong>clock_info03a，clock_info05a&#x2F;b， clock_info18</strong></p><ul><li><p>clock_info03a  报告设计中未被约束的时钟引脚。</p><ol><li>时钟经过组合逻辑被disabled，门控时钟 <img src="/2023/112431792/290753-20220707153610355-1659264831.png" alt style="zoom:67%;"></li><li>约束文件中没有约束时钟引脚，且use_inferred_clocks参数被设置为No<img src="/2023/112431792/290753-20220707153634456-628658853.png" alt style="zoom: 67%;"></li><li>时钟路径上有Blackbox，且Blackbox输出的时钟没有约束<img src="/2023/112431792/290753-20220707153647566-2088386241.png" alt style="zoom:67%;"></li><li>时钟在设计中没有传输，断头时钟。<img src="/2023/112431792/290753-20220707153659862-637731003.png" alt styl="zoom:67%;"></li></ol></li><li><p>clock_info05a&#x2F;b</p><p>在设计如果有clock的mux选择输出，需要指定set_case_analysis命令来约束。</p><pre><code></code></pre></li></ul><p>input ports: clk1, clk2<br>  output port: clkout<br>  enable port: in1<br>  assign clkout &#x3D; in1 ? clk1 : clk2;<br>  在sgdc文件中：<br>  current_design test<br>  clock -name clk1<br>  clock -name clk2<br>  这样报违例。需要进行下面的配置<br>  set_case_analysis -name in1 -value 0</p><pre><code>- clock_info18报告设计中未约束的引脚sgdc中一定要约束所有的输入、输出引脚，时钟引脚以及BLACKBOX的引脚。包括：input，output，clock，reset，set_case_analysis，abstract_port</code></pre></li><li><p>CDC_verify_struct</p><p>​主要检查设计中是否有 未同步的信号，是否有毛刺。</p><ul><li><p><strong>AC_unsync01&#x2F;02</strong></p><p>如果源寄存器是控制信号，检查信号是否通过一个有效同步器。<br>如果源寄存器是数据信号，检查是否使用异步fifo或握手信号。</p></li><li><p><strong>AC_SYNC01&#x2F;02</strong></p><p>报告设计中已经同步的信号，这项规则只会报告信息，不会报告违例。</p></li><li><p><strong>AC_conv01&#x2F;02&#x2F;03</strong></p><p>报告设计中的聚合问题，可能引起数据不一致性，即同步前后数据不一致。</p><p>AC_conv01报告信号经过同步器+寄存器后的聚合违例。</p></li></ul></li></ul><img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706510260564-11.png" alt style="zoom:67%;"><p>​多bit信号，在同步后经过不同数量的寄存器，最终在一个逻辑门聚合。在源寄存器端发送的是00-&gt;11，在目的寄存器聚合的输入端的结果是00-&gt;10-&gt;11，导致和源寄存器端发送的结果不一致（数据一致性问题）。但是如果是单bit的数据变化，就不会有这种问题。<br>​<img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706524314470-14.png" alt style="zoom: 67%;"></p><p>​上图所描述的问题也是一样的。</p><p>​<img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706524438604-17.png" alt style="zoom:67%;"><br>​这种情况下没有违例，两个信号由同一个控制信号控制。如果报出违例，检查设置确实没有问题，可以设置cdc_false_path命令约束。</p><p>​AC_conv02规则报告信号经过同步器后违例，且聚合后又通过了寄存器。</p><p>​<img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706525364578-20.png" alt style="zoom:67%;"><br>​这种方式和上面的conv01不同，上面的聚合发生在寄存器后，而这种方式聚合发生在同步后，同样会出现数据一致性问题。（多bit数据同步，不能采用单bit打两拍的方式）。<strong>解决办法：如果是计数器，可以将多bit数据转成格雷码，在发送端打一拍，然后再传递出去。</strong></p><p>​报告同一个信号经过多条同步路径后，又聚合的问题。类似于多比特数据的同步问题。</p><img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706525889668-23.png" alt style="zoom:67%;"><p>​AC_conv03规则检查不同时钟域信号，经过同一个时钟域同步后的聚合问题。</p><p><img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706526000058-26.png"></p><p>​AC_glitch03 报告设计中的毛刺。</p><ul><li><strong>Clock_sync05&#x2F;06</strong></li></ul><p>​Clock_sync05报告输入信号被多个不同的时钟域寄存器采样。</p><p>​<img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706527099731-29.png" alt style="zoom: 80%;"></p><p>​Clock_syn06报告输出信号由多个时钟域信号组合而成。<br><img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706527140384-32.png"></p><p>​<strong>如果确保设计没有问题，可以使用set_case_analysis命令加强对输入信号的约束</strong></p><p><strong>AC_cdc01a AC_cdcdatahold1a AC_conv02&#x2F;04&#x2F;05 AC_fifo01 AC_handshake01&#x2F;02</strong></p><p>检查CDC_verify(functional cdc checks)：数据完整性、格雷码编码、FIFO上溢或下溢和握手协议。</p><p>AC_cdc01a<br>    检查快时钟到慢时钟同步数据传输是否丢失。</p><img src="/2023/112431792/290753-20220707155308615-135013952.png" alt style="zoom:80%;"><p>​如果快时钟域的信号只维持一个周期，慢时钟域很容易采不到。快时钟域的信号变化至少维持慢时钟域的1.5个周期不变。</p><p><img src="/2023/112431792/290753-20220707155318653-96027376.png"></p><p>AC_datahold01a 检查多bit数据被另一个时钟域采样时是否稳定，与上面的cdc_01a检查单bit类似.FIFO、握手、门控同步模块都不会被检查。</p><p>AC_conv02&#x2F;04&#x2F;05 检查跨时钟传输过程中没有聚合，也没有格雷码编码的多比特控制信号。<br>检查是否使用格雷码编码</p><p><img src="/2023/112431792/290753-20220707155437109-1964738978.png"></p><p>检查不同bit信号是否使用不同的同步方式，src_bus[0]采用多级同步器方式同步，src_bus[1]采用同步控制信号方式</p><p><img src="/2023/112431792/290753-20220707155449430-751485405.png"></p><p>检查不同bit信号是否使用同一个同步控制信号，src_bus[0]与src_bus[1]采用不同的同步控制信号</p><p><img src="/2023/112431792/290753-20220707155459981-1844018659.png"></p><p>AC_fifo01：检查fifo是否上溢或者下溢</p><p>AC_handshake01&#x2F;02: </p><p>01检查req-&gt;ack信号是否满足四相握手协议。REQ拉高-&gt;ACK拉高-&gt;REQ拉低-&gt;ACK拉低</p><p><img src="/2023/112431792/290753-20220707155544879-178987688.png"></p><p>02检查是否会有数据丢失</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpyGalss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>add delay to verilog models</title>
      <link href="/2023/112317390.html"/>
      <url>/2023/112317390.html</url>
      
        <content type="html"><![CDATA[<h2 id="verilog中的延迟模型"><a href="#verilog中的延迟模型" class="headerlink" title="verilog中的延迟模型"></a>verilog中的延迟模型</h2><h4 id="block-assignment（always）-“-”-阻塞赋值"><a href="#block-assignment（always）-“-”-阻塞赋值" class="headerlink" title="block assignment（always） “&#x3D;” 阻塞赋值"></a>block assignment（always） “&#x3D;” 阻塞赋值</h4><p>分为两种方式：LHS、RHS</p><ul><li>LHS</li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//LHS always @(a) // RHS</span>  <span class="token number">#5</span> y <span class="token operator">=</span> <span class="token operator">~</span>a<span class="token punctuation">;</span>  y <span class="token operator">=</span> <span class="token number">#5</span> <span class="token operator">~</span>a<span class="token punctuation">;</span></code></pre><img src="/2023/112317390/image-20231123170149369.png" alt="LHS in always" style="zoom: 67%;"><img src="/2023/112317390/image-20231123170340908.png" alt="always 阻塞 LHS" style="zoom: 67%;"><p>​总结：LHS是在第一次变量发生变化后，延迟12ns才进行真正的计算，如上图所示15ns后其他变量发生了变化，输出在统一在27ns时会使用最新的输入数据。<strong>相当于先延迟再计算。</strong>这里，b，ci的输入到输出，并没有经过12ns的延迟。</p><ul><li>RHS</li></ul><img src="/2023/112317390/image-20231123193908804.png" alt="always RHS 阻塞" style="zoom: 67%;"><p>​如果延迟12ns的期间，a，b，ci发生了变化，则输出不会体现出来。<strong>相当于先计算，再延迟。</strong></p><p>​在任何阻塞赋值的语句上，尽可能不使用这种形式。</p><h4 id="noblocking-assignment-（always）“"><a href="#noblocking-assignment-（always）“" class="headerlink" title="noblocking assignment （always）“&lt;&#x3D;” 非阻塞赋值"></a>noblocking assignment （always）“&lt;&#x3D;” 非阻塞赋值</h4><img src="/2023/112317390/image-20231123204725158.png" alt="Nonblocking Assignments with Delays" style="zoom:67%;"><ul><li>LHS</li></ul><p>​这种情况和阻塞赋值的”LHS”具有一样的问题。 </p><ul><li>RHS</li></ul><p>​<strong>这种是延迟组合逻辑的正确方式</strong></p><p>​<img src="/2023/112317390/image-20231123212135502.png" alt="always 非阻塞" style="zoom:67%;"></p><p>​<img src="/2023/112317390/image-20231123212223383.png" alt="always 非阻塞" style="zoom: 50%;"></p><p>​15ns时，a发生变化，在此后的12ns如果a，ci，b发生变化，则在27ns不会使用最新的数据，而是每个变化点后的12ns才发生改变。符合预期效果。</p><h4 id="Continuous-assignment"><a href="#Continuous-assignment" class="headerlink" title="Continuous assignment"></a>Continuous assignment</h4><img src="/2023/112317390/image-20231123213602068.png" alt="continous assignments" style="zoom:50%;"><p>​RHS delay，存在和always同样的问题，间隔小于12ns的任何输入变化都不会被检测到。</p><img src="/2023/112317390/image-20231123213721809.png" alt="assign '=' delay " style="zoom:50%;"><img src="/2023/112317390/image-20231123213918097.png" alt="assign delay wave" style="zoom: 50%;"><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>只有always块的RHS才可以准确描述组合逻辑的延迟。</strong></p>]]></content>
      
      
      <categories>
          
          <category> RTL仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTL延迟建模方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小谈case语句</title>
      <link href="/2023/112324934.html"/>
      <url>/2023/112324934.html</url>
      
        <content type="html"><![CDATA[<h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>​最近一直在写code，随着学习的深入，越来越想知道verilog 语法和对应的电路实现是什么样子的。</p><p>​首先，确定一点，完备的case，所有的分支都是并行的，且互斥，所以讨论有没有优先级是没有意义的，它对应的电路是一个MUX。（没有优先级）</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">完备的<span class="token keyword">case</span>分支，等价于 <span class="token keyword">if</span> <span class="token keyword">else</span><span class="token operator">-</span><span class="token keyword">if</span> <span class="token keyword">else</span><span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>缺省case</li></ul><p>​case的分支中，如果缺省，不进行其他操作，dc综合的时候<strong>会生成锁存器latch</strong></p><p>​这个时候如果添加原语 <strong>&#x2F;&#x2F;synopsys full_case</strong> ，目的是让综合器DC知道所有情况都已经列全了，不会生成latch。</p><ul><li><p>full case</p><p>每个可能的case expression的取值，都有与之相对应的分支。都列全了，即使没有default，也是full case</p><p>synopsys的dc_shell把full_case解释为：如果case不是full，对于没有出现的分支条件，输出就当成“不关心”处理，在综合的时候，对于没有出现的分支，会根据逻辑优化赋个常数。<strong>这样会导致前仿和后仿的结果不一致，所以需要注意这个地方</strong>，如果case中有default，case_full会被忽略。</p></li><li><p>parallel case</p><p>parallel case是指case expression只能匹配一个分支，不能出现一对多的情况。</p><p>告诉DC，所有条件都是互斥的，且都是并行，不存在优先级。</p><p>优先级只会存在于多对一的情况下。</p><p><strong>在仿真的时候出现了多对一的情况，会导致仿真执行有一定的优先级，这样就不是parallel case。如果针对这种情况dc时，加上parallel case，会综合出没有优先级的编码器。</strong></p><p>通过<strong>遍历条件</strong>在case中是否<strong>只会被执行一次</strong>，我们可以判断case的综合结果为串行还是并行</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​当case 是full且是parallel的时候，综合出来的电路是没有优先级的MUX，多选一数据选择器；</p><p>​如果case不是full，又没有default，会综合出latch。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高RTL仿真速度</title>
      <link href="/2023/11224275.html"/>
      <url>/2023/11224275.html</url>
      
        <content type="html"><![CDATA[<h2 id="如何提高仿真器的效率"><a href="#如何提高仿真器的效率" class="headerlink" title="如何提高仿真器的效率"></a>如何提高仿真器的效率</h2><p>了解仿真器的底层原理，合适的code style会节省仿真时间。</p><h4 id="仿真算法："><a href="#仿真算法：" class="headerlink" title="仿真算法："></a><strong>仿真算法：</strong></h4><ol><li><p>基于时间的（spice仿真器）</p><p>每个时间节点对所有元件都进行计算，效率低。</p></li><li><p>基于事件的（Verilog XL，NC verilog）</p><p>只有电路发生变化时，才进行处理。效率高。</p></li><li><p>基于周期的（Verilator ）</p><p>只在时钟边沿计算，不管时序，使用两值逻辑。仅适用于同步电路，效率高。比如CPU的仿真。</p></li></ol><p>​以下的测试都是基于Verilog-XL</p><ul><li><h4 id="case语句和多if-else-if语句"><a href="#case语句和多if-else-if语句" class="headerlink" title="case语句和多if else if语句"></a>case语句和多if else if语句</h4><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// case                         // if else-if                    </span><span class="token important">always @</span>（<span class="token operator">*</span>）<span class="token keyword">begin</span>                <span class="token important">always @</span>（<span class="token operator">*</span>）<span class="token keyword">begin</span>                    <span class="token function">case</span><span class="token punctuation">(</span>sel<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                  <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span>                     <span class="token number">2'b00</span><span class="token punctuation">:</span> out <span class="token operator">=</span> a<span class="token punctuation">;</span>                 out <span class="token operator">=</span> a<span class="token punctuation">;</span>                        <span class="token number">2'b01</span><span class="token punctuation">:</span> out <span class="token operator">=</span> b<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span>                     <span class="token number">2'b10</span><span class="token punctuation">:</span> out <span class="token operator">=</span> c<span class="token punctuation">;</span>                 out <span class="token operator">=</span> b<span class="token punctuation">;</span>                        <span class="token number">2'b11</span><span class="token punctuation">:</span> out <span class="token operator">=</span> d<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span>                     <span class="token keyword">default</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> a<span class="token punctuation">;</span>              out <span class="token operator">=</span> c<span class="token punctuation">;</span>                    <span class="token keyword">endcase</span>                         <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b11</span><span class="token punctuation">)</span>             <span class="token keyword">end</span>                                     out <span class="token operator">=</span> d<span class="token punctuation">;</span>                                                   <span class="token keyword">end</span>      </code></pre><p>测试案例：8选1数据选择器，</p><p>仿真发现：基于case的多路选择器，CPU仿真时间更短。</p></li><li><h4 id="带有begin-end和不带begin-end"><a href="#带有begin-end和不带begin-end" class="headerlink" title="带有begin end和不带begin end"></a>带有begin end和不带begin end</h4><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span><span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span>    <span class="token keyword">else</span>  c <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span>    <span class="token function">if</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span>    <span class="token keyword">else</span>  c <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span></code></pre></li></ul><p>​测试结果：nobegin表述的内存利用率和仿真时间要优一些。</p><ul><li><h4 id="define-和-parameters"><a href="#define-和-parameters" class="headerlink" title="&#96;define 和 parameters"></a>&#96;define 和 parameters</h4><img src="/2023/11224275/define1.jpg" alt="define&amp;parameters"></li></ul><p>​parameters要更好一些。</p><ul><li><h4 id="always-group和nogroup"><a href="#always-group和nogroup" class="headerlink" title="always group和nogroup"></a>always group和nogroup</h4><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> <span class="token keyword">begin</span>        out1 <span class="token operator">&lt;=</span> a<span class="token punctuation">;</span>        out2 <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span>        out3 <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span>        out4 <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out1 <span class="token operator">&lt;=</span> a<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out2 <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out3 <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out4 <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span></code></pre><p><img src="/2023/11224275/image-20231122100101428.png" alt="group&amp;nogroup"></p><p>group的仿真时间明显缩短了。</p></li><li><p>verilog可综合</p></li></ul><p>​左移，右移逻辑的操作数，可以是常数，也可以是变量，都是可以综合的，综合结果不一样。 常数的操作数，综合 出来是一个定值，变量的操作数综合出来是一个mux。</p><ul><li>DC时综合的原语</li></ul><pre class=" language-tcl"><code class="language-tcl"><span class="token operator">/</span><span class="token operator">/</span> synopsys translate_off忽略该部分的代码，DC时不会进行转移。<span class="token operator">/</span><span class="token operator">/</span> synopsys translate_on忽略的部分在前仿时是可以发挥作用的，如果错误使用translate_off on语句，会导致前仿和后仿的结果不一致。</code></pre><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// 小心使用translate off on</span>ex<span class="token punctuation">.</span>带两个异步复位信号的D触发器一般的实现方式如下：<span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst <span class="token keyword">or</span> <span class="token keyword">negedge</span> nset<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nset<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         q <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span>这种方式会导致前仿和后仿出现细微的区别。极端测试向量如下：如果nrst和nset同时拉低，则结果输出为<span class="token number">0</span><span class="token punctuation">.</span>经过半个周期后，nrst拉高了，输出结果依然为<span class="token number">0</span><span class="token punctuation">.</span>因为<span class="token important">always</span>块是边沿敏感触发的，但是nset和nrst都是异步的，nset此时为<span class="token number">0</span>，q输出结果应该为<span class="token number">1</span>；计算结果与实际电路不符。解决办法：    加入translate on off语句。配合<span class="token keyword">force</span> 和 relase正确code如下：<span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst <span class="token keyword">or</span> <span class="token keyword">negedge</span> nset<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nset<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         q <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">// synopsys translate_off</span><span class="token important">always @</span><span class="token punctuation">(</span>nrst <span class="token keyword">or</span> nset<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>nrst <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nset<span class="token punctuation">)</span>   <span class="token keyword">force</span> q <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>                <span class="token keyword">release</span> q<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">// synopsys translate_on</span>该代码可以保证，在nrst撤离时，nset如果为<span class="token number">0</span>，q输出结果为<span class="token number">1</span>；这是在前仿时需要加入的特殊语句，并加上原语。在实际综合过程中，不会被综合。保证了前仿和实际流片的结果完全一致。在工艺库中，有时钟，异步复位和异步置数的端口，也就是说<span class="token important">always</span>块中的敏感列表，最多可以有三个。但是不能是同时<span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> clk。一个信号不能依赖两个边沿。</code></pre><ul><li><p>verilog调试</p><p>bg：verilog中的参数可以用 &#96;define和parameter指定，这种方式必须要求我们在编译前修改好，编译后就不能再修改了。但是为了节省编译时间，可以使用 $test$plusargs和$value$plusargs来指定。</p></li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps<span class="token keyword">module</span> tb<span class="token punctuation">;</span><span class="token keyword">reg</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> testname<span class="token punctuation">;</span><span class="token keyword">initial</span> <span class="token keyword">begin</span><span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"**********************RESULT IS BELOW*********************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">if</span><span class="token punctuation">(</span><span class="token property">$test</span><span class="token property">$plusargs</span><span class="token punctuation">(</span><span class="token string">"TAISHAN"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"****************TAISHAN is selected******************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"**********************$test$plusargs FAIL**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token property">$value</span><span class="token property">$plusargs</span><span class="token punctuation">(</span><span class="token string">"TESTNAME=%s"</span><span class="token punctuation">,</span> testname<span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">begin</span>  <span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"*****************Running test %0s.********************"</span><span class="token punctuation">,</span> testname<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"**********************$value$plusargs FAIL**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token property">$finish</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span>使用方式：<span class="token number">1</span><span class="token punctuation">.</span>simv<span class="token number">2</span><span class="token punctuation">.</span>simv<span class="token operator">+</span>TATSHAN<span class="token number">3</span><span class="token punctuation">.</span>simv<span class="token operator">+</span>TAISHAN<span class="token operator">+</span>TESTNAME<span class="token operator">=</span>HUASHAN</code></pre><p>在仿真时，0时刻会执行一些系统函数，有些数据没有准备好，导致发生系统仿真错误，因此，可以在代码中初始化变量的值。</p><p><img src="/2023/11224275/image-20240203213035815.png"></p><p><img src="/2023/11224275/image-20240203213107944.png"></p>]]></content>
      
      
      <categories>
          
          <category> RTL仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 仿真器底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
