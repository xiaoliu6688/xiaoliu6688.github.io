<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DFT-FLOW</title>
      <link href="/2024/081033826.html"/>
      <url>/2024/081033826.html</url>
      
        <content type="html"><![CDATA[<img src="/2024/081033826/image-20240810110410570.png" alt="image-20240810110410570" style="zoom: 33%;"><p>DFT用来检测制造过程中的缺陷，而不是设计bug。</p><h4 id="Stuck-At-Fault-Model-故障分析模型"><a href="#Stuck-At-Fault-Model-故障分析模型" class="headerlink" title="Stuck-At Fault Model 故障分析模型"></a>Stuck-At Fault Model 故障分析模型</h4><p>用逻辑结果0和1代替物理失效产生的故障</p><p><img src="/2024/081033826/image-20240810113810794.png" alt="image-20240810113810794"></p><p><img src="/2024/081033826/image-20240810115325881.png" alt="image-20240810115325881"></p><p><img src="/2024/081033826/image-20240810115410268.png" alt="image-20240810115410268"></p><p>测试向量是软件自动生成的。</p><p>优势：可以通过软件穷举所有的输入激励。<br>缺点：某些错误可能无法发现；每一步需要花费时间计算。</p><p>为了设置芯片内部寄存器的状态，检测故障，需要使用特殊的寄存器。</p><p><img src="/2024/081033826/image-20240810130033206.png" alt="image-20240810130033206"></p><p>所有寄存器通过扫描链连接在一起</p><p><img src="/2024/081033826/image-20240810130311471.png" alt="image-20240810130311471"></p><p> <img src="/2024/081033826/image-20240810131016740.png" alt="image-20240810131016740"></p><p>实际工作模式</p><p><img src="/2024/081033826/image-20240810132527009.png" alt="image-20240810132527009"></p><p>ATE：Auto Test Equipment，ATE可以自动执行一系列的测试，收集和分析测试数据。<br>ATPG：自动生成有效检测硬件故障的测试向量</p><h4 id="DFT-“views”"><a href="#DFT-“views”" class="headerlink" title="DFT “views”"></a>DFT “views”</h4><p>-view spec：only for <strong>insert_dft</strong><br>-view exist：only for <strong>dft_drc</strong> </p><h3 id="Top-Down-Scan-Insertion-Flow"><a href="#Top-Down-Scan-Insertion-Flow" class="headerlink" title="Top-Down Scan Insertion Flow"></a>Top-Down Scan Insertion Flow</h3><p><img src="/2024/081033826/image-20240810173936226.png" alt="image-20240810173936226"></p><h5 id="Specify-a-clock"><a href="#Specify-a-clock" class="headerlink" title="Specify a clock"></a>Specify a clock</h5><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl"><span class="token keyword">set</span> <span class="token variable">test_default_period</span> 100set_dft_signal <span class="token operator">-</span>view existing_dft <span class="token operator">-</span>type ScanClock <span class="token operator">-</span>port clock <span class="token operator">-</span>timing <span class="token punctuation">&#123;</span>45 55<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2024/081033826/image-20240810163341509.png" alt="image-20240810163341509"></p><h5 id="Specify-a-reset"><a href="#Specify-a-reset" class="headerlink" title="Specify a reset"></a>Specify a reset</h5><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_dft_signal <span class="token operator">-</span>view existing_dft <span class="token operator">-</span>type Reset <span class="token operator">-</span>port resetn <span class="token operator">-</span>active_state 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2024/081033826/image-20240810163539268.png" alt="image-20240810163539268"></p><h5 id="Specify-a-Scan-enable"><a href="#Specify-a-Scan-enable" class="headerlink" title="Specify a Scan enable"></a>Specify a Scan enable</h5><p>scan enable used for <strong>both</strong> dft_drc and insert_dft</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_dft_signal <span class="token operator">-</span>view exist <span class="token operator">-</span>active 1 <span class="token operator">-</span>type ScanEnable <span class="token operator">-</span>port test_se set_dft_signal <span class="token operator">-</span>view spec <span class="token operator">-</span>active 1 <span class="token operator">-</span>type ScanEnable <span class="token operator">-</span>port test_se <span class="token operator">-</span>hookup_pin U3<span class="token operator">/</span>Z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2024/081033826/image-20240810165352709.png" alt="image-20240810165352709"></p><h5 id="Specify-a-Constant"><a href="#Specify-a-Constant" class="headerlink" title="Specify a Constant"></a>Specify a Constant</h5><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_dft_signal <span class="token operator">-</span>view existing_dft <span class="token operator">-</span>type Constant <span class="token operator">-</span>port atpgmode <span class="token operator">-</span>active_state 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="/2024/081033826/image-20240810165825982.png" alt="image-20240810165825982"></p><h5 id="Specify-a-Scan-In"><a href="#Specify-a-Scan-In" class="headerlink" title="Specify a Scan In"></a>Specify a Scan In</h5><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_dft_signal <span class="token operator">-</span>view spec <span class="token operator">-</span>type ScanDataIn <span class="token operator">-</span>port test_si <span class="token operator">-</span>hookup_pin U1<span class="token operator">/</span>Z<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2024/081033826/image-20240810170026245.png" alt="image-20240810170026245"></p><h5 id="Specify-a-Scan-Out"><a href="#Specify-a-Scan-Out" class="headerlink" title="Specify a Scan Out"></a>Specify a Scan Out</h5><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_dft_singal <span class="token operator">-</span>view spec <span class="token operator">-</span>type ScanDataOut <span class="token operator">-</span>port test_so <span class="token operator">-</span>hookup_pin U2<span class="token operator">/</span>A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2024/081033826/image-20240810170134268.png" alt="image-20240810170134268"></p><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p><img src="/2024/081033826/image-20240810174039687.png" alt="image-20240810174039687"></p><h5 id="创建DFT协议"><a href="#创建DFT协议" class="headerlink" title="创建DFT协议"></a>创建DFT协议</h5><p> test protocol：在测试模式下如何控制设计（clocking，scan shifting，disabling asynchronous reset）</p><p><strong>Steps for creating a test protocol</strong></p><ol><li><p>define scan signals，clocks，resets，constant</p><p>set_dft_signal</p></li><li><p>define&#x2F;create the test protocol using</p><p>read_test_protocol  or  create_test_protocol</p></li></ol><p>让工具理解定义的scan clock，reset，scan enable，scan in，scan out等，为后面的dft_drc和insert_dft做准备。在dft_drc，preview_dft，insert_dft之前需要保证有test_protocol。</p><h5 id="dft-drc"><a href="#dft-drc" class="headerlink" title="dft_drc"></a>dft_drc</h5><p>检查是否违反设计规则，确保正确设置了DFT</p><h5 id="插入扫描路径-insert-dft"><a href="#插入扫描路径-insert-dft" class="headerlink" title="插入扫描路径 insert_dft"></a>插入扫描路径 insert_dft</h5><pre class="line-numbers language-none"><code class="language-none">preview_dftinsert_dft<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>preview_dft 命令是把将要实现的DFT结构报告出来而不是真正要去实现它。 因此 preview_dft 命令允许用户不进行逻辑综合就能对scan chain等信息进行预览，并且根据需求再调整DFT设计。</p>]]></content>
      
      
      <categories>
          
          <category> 数字中端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced SOC Design</title>
      <link href="/2024/071810566.html"/>
      <url>/2024/071810566.html</url>
      
        <content type="html"><![CDATA[<h2 id="Advanced-SOC-Design-Clock"><a href="#Advanced-SOC-Design-Clock" class="headerlink" title="Advanced SOC Design Clock"></a>Advanced SOC Design Clock</h2><p>低功耗 &#x3D;&gt; many clock domain</p><ul><li>跨时钟域数据传输</li><li>STA  false path</li><li>function verification 困难</li></ul><h3 id="glitch-free-clock-Switching"><a href="#glitch-free-clock-Switching" class="headerlink" title="glitch-free clock Switching"></a>glitch-free clock Switching</h3><p><img src="/2024/071810566/image-20240718142706324.png" alt="image-20240718142706324"></p><p>由于select信号和时钟是异步的，所以会有产生毛刺的概率。</p><p>解决办法：让两个时钟都在低电平的时候才能切换，保证了没有毛刺。</p><p><img src="/2024/071810566/image-20240718143138683.png" alt="image-20240718143138683"></p><p>为了降低亚稳态，DFF1的输入是异步的，所以需要使用两级同步器打拍（上升沿触发）</p><p><img src="/2024/071810566/image-20240718143729197.png" alt="image-20240718143729197"></p><p>对于ratioed clocks，可以类比到多个时钟域切换，为了减小毛刺，所有时钟为低电平时，才切换。而不需要上述方式，判断每两个时钟为低电平的时候切换。当所有时钟为低电平的时候，都可以进行时钟切换。</p><p><img src="/2024/071810566/image-20240718144837174.png" alt="image-20240718144837174"></p><h3 id="clock-gating"><a href="#clock-gating" class="headerlink" title="clock gating"></a>clock gating</h3><p><img src="/2024/071810566/image-20240718150157476.png" alt="image-20240718150157476"></p><h4 id="XOR-based-Clock-Enable-Signal"><a href="#XOR-based-Clock-Enable-Signal" class="headerlink" title="XOR based Clock Enable Signal"></a>XOR based Clock Enable Signal</h4><p><img src="/2024/071810566/image-20240718151303834.png" alt="image-20240718151303834"></p><p>如果输入和输出一样，门控时钟就有效。</p><p>ICG会引入skew，给CTS带来压力，影响建立和保持时间检查。</p><p>如果clock latency大于period，还会恶化pll jitter，影响setup和hold检查。</p><h4 id="Asynchronous-Synchronous-Interface"><a href="#Asynchronous-Synchronous-Interface" class="headerlink" title="Asynchronous-Synchronous Interface"></a>Asynchronous-Synchronous Interface</h4><p><img src="/2024/071810566/image-20240718152422063.png" alt="image-20240718152422063"></p><p>亚稳态如果不处理，会传递给下级模块，下级逻辑的settle time不一致导致采样不一样的结果。</p><p>为什么两级同步器之间不加任何组合逻辑原因？</p><ul><li>增加组合逻辑 会增加settle时间（判决时间）</li></ul><p><img src="/2024/071810566/image-20240718154002938.png" alt="image-20240718154002938"></p><p>异步信号只能接入一个寄存器。如果接入到两个寄存器，可能造成数据一致性的问题，进入不确定的状态。</p><h5 id="多个异步输入信号接入到不同的逻辑"><a href="#多个异步输入信号接入到不同的逻辑" class="headerlink" title="多个异步输入信号接入到不同的逻辑"></a>多个异步输入信号接入到不同的逻辑</h5><p><img src="/2024/071810566/image-20240718154339622.png" alt="image-20240718154339622"></p><p>解决办法：</p><ul><li><p>每次只有一个变化。格雷码编码</p></li><li><p>握手机制</p></li><li><p>debouncing </p><p>连续采样数据很多次，如果连续两次采样的数据都是一样的，就可以接收这次数据。这种方法适合在采样时钟下，输入数据持续多个周期的场景， 适合慢时钟域数据传输到快时钟域。</p></li></ul><p><img src="/2024/071810566/image-20240718155039261.png" alt="image-20240718155039261"></p><h4 id="CDC"><a href="#CDC" class="headerlink" title="CDC"></a>CDC</h4><p><img src="/2024/071810566/image-20240718162137799.png" alt="image-20240718162137799"></p><p>快时钟域到慢时钟域：</p><ol><li>开环：3个边沿原则</li><li>闭环：握手机制，ack和req</li></ol><h5 id="多比特数据跨时钟域传输方法"><a href="#多比特数据跨时钟域传输方法" class="headerlink" title="多比特数据跨时钟域传输方法"></a>多比特数据跨时钟域传输方法</h5><p><img src="/2024/071810566/image-20240718163236677.png" alt="image-20240718163236677"></p><h5 id="CTS-issues"><a href="#CTS-issues" class="headerlink" title="CTS issues"></a>CTS issues</h5><img src="/2024/071810566/image-20240718170832951.png" alt="image-20240718170832951" style="zoom:67%;"><h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p>并不是所有的寄存器都需要reset，它会占用很大的功耗、面积等。</p><p>当芯片第一次起来时，一个额外的POR（power on reset）确保进入有序的状态。</p><p>不要把有reset和没有reset的寄存器放在一个always块中。</p><img src="/2024/071810566/image-20240718201029670.png" alt="image-20240718201029670" style="zoom:80%;"><p>异步复位在释放时，考虑是否有race condit</p><p><img src="/2024/071810566/image-20240719095317255.png" alt="image-20240719095317255"></p><p>复位时，Q：1 0 0 0 ，在异步复位释放时，有可能产生 0 0 0 0的非法状态。</p><p>因此，需要保证异步复位信号是同步释放的，满足removal和recovery time。</p><p>尽可能保证复位时的值和释放时的值是同一个，否则会导致输出有一个周期的延迟，造成功能错误。</p><p>为了滤除复位信号上的毛刺，设计毛刺过滤电路。</p><p><img src="/2024/071810566/image-20240719101126658.png" alt="image-20240719101126658"></p><p>如果时钟频率很快，无法满足在一个时钟周期内将复位信号到达所有寄存器。解决办法：</p><ol><li><p>reset signal distribution</p><p><img src="/2024/071810566/image-20240719103416123.png" alt="image-20240719103416123"></p></li><li><p>停止clk，等待复位信号计数到一定数值稳定后，再打开时钟</p><p><img src="/2024/071810566/image-20240719103514844.png" alt="image-20240719103514844"></p></li></ol><h4 id="multi-clock-reset"><a href="#multi-clock-reset" class="headerlink" title="multi clock reset"></a>multi clock reset</h4><p><img src="/2024/071810566/image-20240719104629097.png" alt="image-20240719104629097"></p><p>不同时钟域的复位信号有一定的顺序。</p><h4 id="cross-reset-domain"><a href="#cross-reset-domain" class="headerlink" title="cross reset domain"></a>cross reset domain</h4><p>一个时钟域可能有不同的reset域，</p><p><img src="/2024/071810566/image-20240719104956631.png" alt="image-20240719104956631"></p><img src="/2024/071810566/image-20240719140141386.png" alt="image-20240719140141386" style="zoom:67%;"><p>RST1 release时，产生异步信号给DFF2，在DFF2的上升沿容易产生亚稳态。</p><p><img src="/2024/071810566/image-20240719141256767.png" alt="image-20240719141256767"></p><h3 id="Power-on-Reset"><a href="#Power-on-Reset" class="headerlink" title="Power on Reset"></a>Power on Reset</h3><p>保证每次复位，微处理器进入同样的状态。</p><p><img src="/2024/071810566/image-20240719112723314.png" alt="image-20240719112723314"></p><p>PLL用POR做reset，需要extend POR等待时钟稳定后，才可以release复位信号。</p><p><img src="/2024/071810566/image-20240719113444704.png" alt="image-20240719113444704"></p><h2 id="IO-serdes"><a href="#IO-serdes" class="headerlink" title="IO serdes"></a>IO serdes</h2><p>系统同步方案</p><p>接收和发送使用同一个时钟，critical path在于两个时钟交互的路径上，有input&#x2F;output delay、skew的限制</p><p><img src="/2024/071810566/image-20240719142656055.png" alt="image-20240719142656055"></p><p>源同步方案（DDR）</p><p>64bit 数据总线的DDR，每8bit使用一个data strobe采样数据。如果64bit共用一个data strobe，数据的skew太大</p><p><img src="/2024/071810566/image-20240719144803471.png" alt="image-20240719144803471"></p><p><img src="/2024/071810566/image-20240719145039502.png" alt="image-20240719145039502"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SOC设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog硬件设计及建模</title>
      <link href="/2024/071129443.html"/>
      <url>/2024/071129443.html</url>
      
        <content type="html"><![CDATA[<h2 id="第2章-SV声明的位置"><a href="#第2章-SV声明的位置" class="headerlink" title="第2章 SV声明的位置"></a>第2章 SV声明的位置</h2><p>logic：四态变量，0 1 x z<br>enum：枚举变量<br>typedef：用户定义类型<br>struct：结构体</p><h3 id="2-1-package包"><a href="#2-1-package包" class="headerlink" title="2.1 package包"></a>2.1 package包</h3><p>为了使得多个模块共享用户定义的类型，sv增加了包的概念。在<code>package</code>和<code>endpackage</code>之间定义。包中可综合的结构有：</p><ol><li>parameter和localparam常量定义</li><li>const变量定义</li><li>typedef用户定义类型</li><li>automatic的task和function定义</li><li>从其他包中import语句</li><li>操作符重载定义</li></ol><p>包中还可以进行全局变量声明、静态任务定义和静态函数定义，但是这些都是不可综合的。包是一个独立的空间，不需要包含在verilog模块中。</p><p>const常量是sv常量，每个模块的实例可以对parameter常量重新定义，但是不能对localparameter定义。</p><p>如果赋给real类型变量，parameter定义的变量需要是显式的小数（4.0）。</p><h4 id="引用包的内容"><a href="#引用包的内容" class="headerlink" title="引用包的内容"></a>引用包的内容</h4><ol><li>用范围解析操作符直接引用</li><li>将包中特定子项&#x2F;通配符导入到模块或者接口中</li></ol><p>import definations:: *;</p><p>在综合时，包中定义的任务和函数必须声明为automatic，不能包含静态变量。</p><h3 id="2-2-unit编译单元声明"><a href="#2-2-unit编译单元声明" class="headerlink" title="2.2 $unit编译单元声明"></a>2.2 $unit编译单元声明</h3><p>相比verilog，sv增加了编译单元的概念。编译单元是同时编译所有的源文件，编译单元可以为软件提供对整个设计的子模块单独编译的方法。编辑单元域可以包含：</p><ol><li>时间单位和精度</li><li>变量声明</li><li>net声明</li><li>常量声明</li><li>用户定义的数据类型</li><li>任务和函数定义</li></ol><p>注意，外部声明不可综合。<strong>不要在$unit空间进行任何声明，所有声明在package包中</strong> 外部编译单元域声明不是全局的，sv的编译单元域之作用域同时编译的源文件，每次编译源文件，就会创建一个唯一针对此次编译的编译单元域。必要时将包导入$unit中。</p><p>为了防止重复定义，使用 <strong>条件编译</strong>。带条件编译的包</p><pre class="line-numbers language-systemverilog" data-language="systemverilog"><code class="language-systemverilog">&#96;ifndef DFF_DONE  &#96;define DFF_DONEpackage definitions     parameter Version &#x3D; &quot;1.1&quot;    typedef enum &#123;ADD, SUB, MUL&#125; opcode_t;    typedef struct &#123;        logic [2:0] a;        logic [2:0] b;        opcode_t OP;    &#125; instruction_t;    function automatic [31:0] multipler(input [31:0] a, b);        runturn a*b;    endfunctionendpackageimport definitions:: *;&#96;endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个需要包中定义的设计或者测试平台都应该将</p><pre class="line-numbers language-systemverilog" data-language="systemverilog"><code class="language-systemverilog">&#96;include &quot;definations.pkg&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>放在文件的开始，如果包已经被编译并导入到unit域，该文件的编译就会被忽略。</p><p>使用&#96;include目的是为了保证在defination.pkg文件末尾的导入语句导入到设计或者测试文件中，编译正在使用的同一$unit域。如果直接出现在编译器的命令行中（和.v一样），包和导入语句就会被编译到另外一个$unit空间，而不是设计或测试平台正在使用的$unit域。</p><p>可在编译单元域可综合的结构有：</p><ol><li>typedef用户定义类型</li><li>自动函数&#x2F;任务</li><li>parameter&#x2F;localparam常量</li><li>包导入</li></ol><h2 id="第3章-SV文本值和数据类型"><a href="#第3章-SV文本值和数据类型" class="headerlink" title="第3章 SV文本值和数据类型"></a>第3章 SV文本值和数据类型</h2><p>sv中给变量赋值全1：<code>reg [31:0] data; data = &#39;1;</code></p><p>verilog数据类型<br>    reg、integer和time是四值逻辑。wire和其他net类型的共有120种逻辑（四态逻辑+多个驱动强度）。</p><p>sv数据类型<br>    定义的信号同时具有类型和数据类型。类型指示信号是 <strong>线网还是变量</strong>。数据类型指示是四值逻辑还是二值逻辑。</p><h2 id="System-Verilog基础"><a href="#System-Verilog基础" class="headerlink" title="System Verilog基础"></a>System Verilog基础</h2><p>构造函数 new：在声明时，不能有返回值，void也不可以。</p><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>静态变量在多个实例之间是共享的。</p><p>静态方法只能访问静态变量，访问非静态变量是非法的。静态方法不能是virtual的。</p><p>在不创建对象的情况下，可以访问静态变量和静态方法。</p><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>浅拷贝中，所有变量的值都被复制，但是不复制对象，只复制句柄。</p><p>要想实现深拷贝，需要实现自定义的方法，完成对象的复制。每次调用copy方法时，句柄都指向新的对象。</p><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>派生类继承父类的方法和属性；允许多级继承；子类可以修改父类的属性和方法；</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SV设计与建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Digital_VLSI_Design(Prof_Adam)</title>
      <link href="/2024/050742599.html"/>
      <url>/2024/050742599.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>reference</p><p><a href="https://www.eng.biu.ac.il/temanad/digital-vlsi-design/">https://www.eng.biu.ac.il/temanad/digital-vlsi-design/</a></p></blockquote><h1 id="Digital-VLSI-Design"><a href="#Digital-VLSI-Design" class="headerlink" title="Digital_VLSI_Design"></a>Digital_VLSI_Design</h1><h2 id="Lecture-3-Logic-Synthesis"><a href="#Lecture-3-Logic-Synthesis" class="headerlink" title="Lecture 3: Logic Synthesis"></a>Lecture 3: Logic Synthesis</h2><img src="/2024/050742599/image-20240507095514852.png" alt="image-20240507095514852" style="zoom: 50%;"><img src="/2024/050742599/image-20240507095835141.png" alt="image-20240507095835141" style="zoom: 67%;"><p>时钟单元 clock cells，目的是平衡时钟上升和下降时间（影响传播延迟tcq），减小skew。</p><p>AOI22，表示两输入的与门和两输入的或门，I表示取反。</p><img src="/2024/050742599/image-20240507100714515.png" alt="image-20240507100714515" style="zoom:67%;"><p>物理视图<br>GDSII用来DRC，LVS<br>LEF文件用来布局布线，RC参数提取。</p><img src="/2024/050742599/image-20240507101104094.png" alt="image-20240507101104094" style="zoom:80%;"><p><img src="/2024/050742599/image-20240507101222615.png" alt="image-20240507101222615"></p><p>technology lef文件用来布局和布线。</p><p><img src="/2024/050742599/image-20240507101454395.png" alt="image-20240507101454395"></p><p>analysis：读取verilog文件并检查语法错误<br>elaborate：将RTL转成布尔逻辑结构，减少状态和编码寄存器，绑定getch库中的叶子单元</p><img src="/2024/050742599/image-20240507221107324.png" alt="image-20240507221107324" style="zoom: 33%;"><p>pre-mapping：映射到一般的单元中</p><p>technology mapping：映射一般逻辑到工艺库中</p><p>post-mapping optimization：改变门的尺寸，布尔逻辑迭代，优化结构满足设计约束</p><img src="/2024/050742599/image-20240507102214269.png" alt="image-20240507102214269" style="zoom: 50%;"><p><img src="/2024/050742599/image-20240507223901860.png" alt="image-20240507223901860"></p><p>LEF文件：为了便于P&amp;R，包括详细的pin信息，不包括ploy，扩散区等。通常只有cell的尺寸，size和形状。pin脚位置，金属块。</p><p><img src="/2024/050742599/image-20240507225048811.png" alt="image-20240507225048811"></p><p><img src="/2024/050742599/image-20240507225122821.png" alt="image-20240507225122821"></p><p>technology file：包含不同层的属性，包括pitch，with，via，金属方向，设计规则等，用来布局和绕线。</p><p><img src="/2024/050742599/image-20240507225423852.png" alt="image-20240507225423852"></p><p>BDD二元决策图可以将真值表转换成门级单元， </p><p><img src="/2024/050742599/image-20240507105718413.png" alt="image-20240507105718413"></p><p>优化BDD的方法：</p><ol><li>合并相同的叶子结点</li></ol><p><img src="/2024/050742599/image-20240507110430249.png" alt="image-20240507110430249"></p><ol start="2"><li>合并行为相同的结点</li></ol><p><img src="/2024/050742599/image-20240507111006987.png" alt="image-20240507111006987"></p><p>最左面的x3无论是0&#x2F;1，结果都是1，可以直接将x2连到1上即可。</p><p>二元决策图，在变量选择的顺序上比如X1,X2,X3，和X3,X2,X1对应的二元决策图也是不一样的，优化策略也不同。</p><h3 id="技术映射"><a href="#技术映射" class="headerlink" title="技术映射"></a>技术映射</h3><p>使用递归树覆盖算法，将逻辑网络映射到工艺库中，分为以下三步： </p><ol><li><p>映射网表和技术库到简单的门级单元上（两输入的与非门或者非门）</p></li><li><p>将输入的网表树化，形成递归树的形式</p></li><li><p>减小树的成本</p></li></ol><h4 id="简单门映射"><a href="#简单门映射" class="headerlink" title="简单门映射"></a>简单门映射</h4><p><img src="/2024/050742599/image-20240508100120080.png" alt="image-20240508100120080"></p><p><img src="/2024/050742599/image-20240508100449609.png" alt="image-20240508100449609"></p><h4 id="树化"><a href="#树化" class="headerlink" title="树化"></a>树化</h4><p>保证二叉树的形式，一个输出只能作为一个叶子结点</p><p><img src="/2024/050742599/image-20240508100735457.png" alt="image-20240508100735457"></p><h4 id="最小树覆盖"><a href="#最小树覆盖" class="headerlink" title="最小树覆盖"></a>最小树覆盖</h4><p><img src="/2024/050742599/image-20240508101617358.png" alt="image-20240508101617358"></p><h3 id="数据门控"><a href="#数据门控" class="headerlink" title="数据门控"></a>数据门控</h3><p><img src="/2024/050742599/image-20240507195707301.png" alt="image-20240507195707301"></p><p>在进行加法时，shifter的功能是关闭的。</p><h3 id="时序优化"><a href="#时序优化" class="headerlink" title="时序优化"></a>时序优化</h3><p><img src="/2024/050742599/image-20240507200820190.png" alt="image-20240507200820190"></p><p>关键路径靠近输出。</p><p><img src="/2024/050742599/image-20240507201010412.png" alt="image-20240507201010412"></p><p><img src="/2024/050742599/image-20240507201128327.png" alt="image-20240507201128327"></p><p><img src="/2024/050742599/image-20240507201235730.png" alt="image-20240507201235730"></p><h2 id="lecture5-STA"><a href="#lecture5-STA" class="headerlink" title="lecture5: STA"></a>lecture5: STA</h2><p>false path</p><p><img src="/2024/050742599/image-20240511101154091.png" alt="image-20240511101154091"></p><p>SDC约束</p><p>tcl语法-collection集合</p><p><img src="/2024/050742599/image-20240511101750700.png" alt="image-20240511101750700"></p><p><img src="/2024/050742599/image-20240511101905652.png" alt="image-20240511101905652"></p><p><img src="/2024/050742599/image-20240511102059530.png" alt="image-20240511102059530"></p><p>clock define</p><p><img src="/2024/050742599/image-20240511102426289.png" alt="image-20240511102426289"></p><p><img src="/2024/050742599/image-20240511102456491.png" alt="image-20240511102456491"></p><p>I&#x2F;O 约束</p><p><img src="/2024/050742599/image-20240511102533967.png" alt="image-20240511102533967"></p><p>设置最大延迟时间和最小时间不需要考虑时钟。</p><p><img src="/2024/050742599/image-20240511103113175.png" alt="image-20240511103113175"></p><p><img src="/2024/050742599/image-20240511103210194.png" alt="image-20240511103210194"></p><p><img src="/2024/050742599/image-20240511103249591.png" alt="image-20240511103249591"></p><p><img src="/2024/050742599/image-20240511103441847.png" alt="image-20240511103441847"></p><p><img src="/2024/050742599/image-20240511103653925.png" alt="image-20240511103653925"></p><p>timing report</p><p><img src="/2024/050742599/image-20240511104143288.png" alt="image-20240511104143288"></p><p><img src="/2024/050742599/image-20240511104219740.png" alt="image-20240511104219740"></p><p><img src="/2024/050742599/image-20240511104509098.png" alt="image-20240511104509098"></p><h1 id="Advanced-SOC-Design"><a href="#Advanced-SOC-Design" class="headerlink" title="Advanced SOC Design"></a>Advanced SOC Design</h1><h2 id="Fond-end-design-flow"><a href="#Fond-end-design-flow" class="headerlink" title="Fond-end design flow"></a>Fond-end design flow</h2><p>逻辑综合前后可能会导致RTL和Netlist不一致，比如 <strong>initial value，timing delay，casex和casez</strong></p><p><img src="/2024/050742599/image-20240717145547556.png" alt="image-20240717145547556"></p><p>Timing includes：</p><ol><li>gate delay</li><li>interconnect delay</li><li>crosstalk &amp; noise     （Star RC  mental fill）</li></ol><p><img src="/2024/050742599/image-20240717152716901.png" alt="image-20240717152716901"></p><p>即使有STA，还需要动态仿真测试STA无法考虑到的，比如复位功能。</p><p><img src="/2024/050742599/image-20240717160805825.png" alt="image-20240717160805825"></p><img src="/2024/050742599/image-20240717161058827.png" alt="image-20240717161058827">]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> asic flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低功耗方法学（三）</title>
      <link href="/2024/042561284.html"/>
      <url>/2024/042561284.html</url>
      
        <content type="html"><![CDATA[<h2 id="6-电源门控的架构问题"><a href="#6-电源门控的架构问题" class="headerlink" title="6 电源门控的架构问题"></a>6 电源门控的架构问题</h2><p>这章讨论一些有关植入电源门控的架构问题，特别的，它解决了分区、层次结构和多个电源门控域。</p><h3 id="6-1-垂直结构和电源门控"><a href="#6-1-垂直结构和电源门控" class="headerlink" title="6.1 垂直结构和电源门控"></a>6.1 垂直结构和电源门控</h3><p>为了支持这种可移植性，必须在电源域级别强制设置模块边界。也就是说，给定的模块应该属于单个电压域，而不是跨多个域。一些工具和流程通过RTL流程分配到不同的电压域，但是会导致分析和实现困难。</p><p>电源门控会增加IR drop，导致性能下降，级联多个电压降可能呢过导致延迟增加到不可接受的程度。</p><p>扁平化的电源门控交换网络如下图所示</p><img src="/2024/042561284/image-20240426102400513.png" alt="image-20240426102400513" style="zoom:67%;"><img src="/2024/042561284/image-20240426102417327.png" alt="image-20240426102417327" style="zoom: 67%;"><h5 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h5><ul><li>映射电源门控区域到模块的边界。</li><li>当划分分层电源门控设计时，确保电源门控可以映射到扁平化的交换结构。</li></ul><h5 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h5><ul><li>避免控制信号通过电源门控或者断电区域</li><li>避免使用超过一级或者两级的电源门控系统</li></ul><h3 id="6-2-电源网络及其控制"><a href="#6-2-电源网络及其控制" class="headerlink" title="6.2 电源网络及其控制"></a>6.2 电源网络及其控制</h3><p>在基于处理器的SoC设计中，CPU系统很可能引入很多电源网络。</p><ul><li>CPU子系统具有独立的电源轨道，允许CPU完全关闭以实现长期睡眠操作模式。</li><li>CPU逻辑的门控电源支持短期泄露节省模式，其中高速缓存可以保留，但所有泄漏的标准单元逻辑都在本地关闭。</li><li>始终开启的电源为隔离单元供电。</li><li>SoC级别的常开电源，用于控制外部电源轨开关和电源的握手</li><li>一些常开保留电源供电来自于非电源门控轨道，这需要工艺库中具有带有状态保留的寄存器单元。</li></ul><p>电源网络控制如下图所示，具有独立的VDDCPU和常开的VDDOSC，他们有一个共同的VSS地。电源门控控制单元区域具有非门控状态保持电源</p><img src="/2024/042561284/image-20240426111009781.png" alt="image-20240426111009781" style="zoom:67%;"><h4 id="6-2-1-外部电源开关"><a href="#6-2-1-外部电源开关" class="headerlink" title="6.2.1 外部电源开关"></a>6.2.1 外部电源开关</h4><p>外部电源轨开关可提供最佳的长期泄漏节省，但是会引入显著的开启延迟。</p><p>通常只有少数的电压轨可以进行外部切换，每个电源都会需要稳压器和电路板成本。每个电源轨都需要片上电源分配，使得电源规划和物理布局规则变得很复杂。大多数soc至少具有三个电源轨：</p><ul><li>IO电源（至少1.8&#x2F;2.5&#x2F;3.3V）</li><li>常开的SOC电源轨道</li><li>干净的模拟电源给PLL</li><li>一个可选的保持活动的电压供电给到实时时钟</li></ul><p>添加两个或三个以上的外部开关电源轨会显著增加最终产品的复杂性和成本。通常，芯片和电路板的共享接地&#x2F;VSS连接方法最适合外部电源轨切换。</p><img src="/2024/042561284/image-20240426133612114.png" alt="image-20240426133612114" style="zoom:50%;"><p>外部电源轨切换会导致唤醒事件出现显著的延迟（几十us到几ms级别），在RTL级别量化这些延时是很困难的，通常，应该抑制时钟，直到开关电源轨稳定在允许的误差内。对于在几百MHz的时钟域中，相当于几万个时钟周期。当引入动态电压调节时，单独的电源轨成为必要。通常希望为大型存储器提供自己的电源。</p><h5 id="推荐-1"><a href="#推荐-1" class="headerlink" title="推荐"></a>推荐</h5><ul><li><p>最大限度的减小外部开关电源轨的数目（考虑到相关额外的电源空间成本和片上配电）</p></li><li><p>外部切换电源轨，最好使用同一个公共地</p></li><li><p>在实现电压缩放的系统重，必须为每个电压缩放的区域提供独立的电源轨</p></li></ul><h5 id="陷阱-1"><a href="#陷阱-1" class="headerlink" title="陷阱"></a>陷阱</h5><ul><li><p>针对重要的外部电源轨切换时间进行设计：唤醒中必须考虑数万或数十万个时钟周期延迟</p></li><li><p>尽管从系统设计的角度来看，多轨看起来很优雅，但它们在生产中带来了验证和部署挑战。</p></li></ul><h4 id="6-2-2-片上电源门控"><a href="#6-2-2-片上电源门控" class="headerlink" title="6.2.2 片上电源门控"></a>6.2.2 片上电源门控</h4><p>片上电源门控比片外电源轨门控快得多。对于非常小的区域，电源门控需要几个甚至几百个时钟周期。</p><h3 id="6-3-电源状态表和常开寄存器"><a href="#6-3-电源状态表和常开寄存器" class="headerlink" title="6.3 电源状态表和常开寄存器"></a>6.3 电源状态表和常开寄存器</h3><p>当处理多个电源门控电源域时，电源布线可能会变得复杂，下图显示了三个电源域，每个域都有电源门控。</p><img src="/2024/042561284/image-20240426141349369.png" alt="image-20240426141349369" style="zoom:50%;"><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>||       未完待续~       ||</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 低功耗圣经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂七杂八</title>
      <link href="/2024/04057752.html"/>
      <url>/2024/04057752.html</url>
      
        <content type="html"><![CDATA[<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><blockquote><p>参考语义化版本2.0.0 <a href="https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a></p></blockquote><p>版本号规则</p><ol><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><p>初始版本号为：0.1.0</p><h1 id="版本内容修改格式如下"><a href="#版本内容修改格式如下" class="headerlink" title="版本内容修改格式如下"></a>版本内容修改格式如下</h1><pre class="line-numbers language-none"><code class="language-none"># [0.1.0] -2024-04-09### Added- xxxxxx### Fixed- xxxx### Changed- xxxxx- xxxxx### Removed- xxxxxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>串口通信协议-UART、SPI、I2C</title>
      <link href="/2024/031321104.html"/>
      <url>/2024/031321104.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Reference </p><p><a href="https://blog.csdn.net/qq_40268672/article/details/124436244">https://blog.csdn.net/qq_40268672/article/details/124436244</a></p></blockquote><h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p>全双工的异步串口协议，主要用于调试，至少三根线RX、TX和GND</p><p>协议主要包括空闲位，起始位，数据位，奇偶校验位和停止位。空闲位是高电平，起始位是1bit的低电平，数据位一般是5,6,7,8位（如果不用奇偶校验位，数据帧可以为9bit），停止位一般是1位的高电平。UART常见的波特率一般有4800，9600，19200，38400，115200。</p><img src="/2024/031321104/20200803195509148.png" alt="img" style="zoom: 67%;"><p>优点：只有两根线，不需要时钟信号；具有奇偶校验位。<br>缺点：数据帧最大9位，不支持多从。传输速率受到波特率的限制。</p><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>全双工的同步串口协议，常用于显示驱动器外设通信。由一个主设备和多个从设备组成，SPI接口信号有sdi串行数据输入，sdo串口数据输出，sck时钟信号以及cs片选信号。cs决定了唯一的与主设备通信的从设备，片选信号低电平有效。SPI协议有多种不同的配置，由时钟相位和时钟极性决定。</p><p>时钟极性表示当SCLK为空闲时，电平是高电平还是低电平。</p><ul><li>CPOL&#x3D;0；时钟空闲是低电平</li><li>CPOL&#x3D;1；时钟空闲是高电平</li></ul><p>时钟相位CPHA决定在第几个时钟变化边沿开始采样数据；</p><ul><li>CPHA&#x3D;0；在时钟信号SCK的第一个跳变沿采样</li><li>CPHA&#x3D;1；在时钟信号SCK的第二个跳变沿采样</li></ul><p>因此，不同的时钟相位和极性共有4种SPI协议的配置。CPHA&#x3D;0，表示第一个边沿：<br>对于CPOL&#x3D;0，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿采样<br>对于CPOL&#x3D;1，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿采样<br>CPHA&#x3D;1，表示第二个边沿：<br>对于CPOL&#x3D;0，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿采样<br>对于CPOL&#x3D;1，idle时候的是高电平，第一个边沿就是从低变到高，所以是上升沿采样</p><p>从机数目受到系统负载电容的限制，降低master在电平之间的切换能力。</p><img src="/2024/031321104/v2-90fa89c6af8665282dd058768841801f_1440w.webp" alt="img" style="zoom: 50%;"><p>优点：没有起始位和停止位，可以持续传输数据；数据传输速率快，比I2C快几乎两倍，全双工通信。<br>缺点：使用四根线，没有数据传输反馈信号和奇偶校验位。</p><h2 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h2><p>两根线：一根是时钟线SCL和一个数据线SDA，属于半双工通信。</p><p>IIC的起始条件为在SCL为高电平期间，SDA出现下降沿</p><img src="/2024/031321104/a4b57424cb284c92a2362c24d2958404.png" alt="在这里插入图片描述" style="zoom:67%;"><p>结束条件为在SCL高电平期间，SDA出现上升沿</p><img src="/2024/031321104/a74416ae63334f068ae25c988fa5fbb2.png" alt="在这里插入图片描述" style="zoom:67%;"><p>在数据传输时，只有SCL在低电平期间，才允许数据变化，在高电平期间不允许变化，因为是判断起止条件的。</p><img src="/2024/031321104/ac4872ce1ace49e998acd746db02c1c2.png" alt="在这里插入图片描述" style="zoom:50%;"><p>IIC有一个很重要的概念： <strong>应答</strong>。slave收到数据后，会给master发送一个应答信号，slave的时钟信号是master发出的。应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，<strong>低电平0表示应答，1表示非应答</strong>。需要应答时，数据发出方将SDA总线设置为3态输入，由于IIC总线上有上拉电阻，因此此时总线默认高电平，若数据接收方正确接收到数据，则数据接收方将SDA总线拉低，以示正确应答。</p><p><strong>IIC传输时是从MSB开始传输到LSB结束的</strong></p><p>写时序</p><p><img src="/2024/031321104/image-20240323140356689.png" alt="image-20240323140356689"></p><p>读时序</p><p><img src="/2024/031321104/image-20240323140811569.png" alt="image-20240323140811569"></p><p>​1.产生start信号。<br>​2.传送器件地址（写ID_Address），ACK。<br>​3.传送字地址（写REG_Address），ACK。<br>​4.再次产生start信号<br>​5.再传送一次器件地址，ACK。<br>​6.读取一个字节的数据，<strong>读数据最后结束前无应答(NO ACK)信号</strong>。<br>​7.产生stop信号。</p><img src="/2024/031321104/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluXzQxMzM4MDgx,size_14,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom:67%;"><p>​I2C是单主机多从机，发出的地址和数据对所有slave都是可见的，如果发送的地址和slave的地址匹配，slave就会给master一个应答。在时钟线（SCL）为高电平的时候，一定不能动数据线（SDA）状态，除非是启动或者结束总线。</p><p>优点：I2C支持多主多从；占用的GPIO少，节省资源。有应答机制。<br>缺点：slave不能太多，增加负载电容。半双工通信。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="设备从属关系"><a href="#设备从属关系" class="headerlink" title="设备从属关系"></a>设备从属关系</h3><p>​UART没有主从关系；SPI存在主从关系，通过CS片选信号选择从机；IIC也存在主从关系，通过发出的数据地址选择从机。</p><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><p>​UART和SPI都是全双工通信，两根数据线。I2C是半双工通信。  SPI和I2C是同步通信方式，UART是异步通信</p><h3 id="传输速度"><a href="#传输速度" class="headerlink" title="传输速度"></a>传输速度</h3><p>​UART传输速度最慢，SPI比I2C要快，达到几Mbps</p><h3 id="传输距离"><a href="#传输距离" class="headerlink" title="传输距离"></a>传输距离</h3><p>​I2C弱于UART和SPI，使用上拉电阻（实现线与），抗干扰能力较弱。适合短距离通信。</p><h3 id="通信特征"><a href="#通信特征" class="headerlink" title="通信特征"></a>通信特征</h3><p>​UART：异步，一帧传输5 6 7 8位，低位先传输。UART需要固定的波特率，两位数据的间隔要相等。<br>​SPI：同步，允许一位一位传输，允许暂停。从最高位开始传输。<br>​I2C：同步，一次传输8bit，最高位开始传输。<br>​SPI和I2C都是同步的，没有波特率的要求。</p><p>未完待续~</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总线协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AES加解密算法IP</title>
      <link href="/2024/031353724.html"/>
      <url>/2024/031353724.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>reference</p><p><a href="https://www.cnblogs.com/xzj8023tp/p/12970790.html">https://www.cnblogs.com/xzj8023tp/p/12970790.html</a></p></blockquote><h2 id="加密算法概念"><a href="#加密算法概念" class="headerlink" title="加密算法概念"></a>加密算法概念</h2><p>一个密码系统的加密密钥和解密密钥相同，或者虽然不相同但是由其中的任意一个可以很容易地推导出另一个，则称该密码系统采用的是对称密码体制。优点是 <strong>加解密速度快</strong>，安全系数不高。AES是对称密钥体制算法。</p><p>如果一个密码系统的加密密钥和解密密钥不同，并且由加密密钥推导出解密密钥(或者由解密密钥推导出加密密钥)是计算上不可行的，则称该密码系统采用的是非对称密码体制。采用非对称密码体制的每个用户都有一对选定的密钥，其中一个是可以公开的，一个由用户自己秘密保存。RSA是非对称加密算法的一种。优点是安全系数高，可以方便、安全的实现数字签名和验证。</p><h3 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h3><p>AES算法在明文加密时，需要将整个明文分组，每组16个字节。</p><h4 id="AES加密算法两种模式ECB和CBC"><a href="#AES加密算法两种模式ECB和CBC" class="headerlink" title="AES加密算法两种模式ECB和CBC"></a>AES加密算法两种模式ECB和CBC</h4><h5 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h5><p>相同的输入产生相同的输出。优点：简单，有利于并行计算，误差不会传送。缺点：可能对明文进行主动攻击。</p><img src="/2024/031353724/SouthEast.jpeg" alt="img" style="zoom: 50%;"><h5 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h5><p>将加密的结果进行级联，第一组加密需要添加额外的数据块IV。需要将上组加密结果与当前明文异或作为第二组分组加密的输入。CBC并行度较差，每次都要等待上次结果。</p><img src="/2024/031353724/SouthEast-1713508082381-3.jpeg" alt="img" style="zoom: 67%;"><h4 id="AES加密算法具体实现"><a href="#AES加密算法具体实现" class="headerlink" title="AES加密算法具体实现"></a>AES加密算法具体实现</h4><p>AES算法是作用在有限域（2^8）,该域中的元素是由8bit组成的字节。它们可以通过异或做加法运算，也可以通过某种方式做乘法运算，而且每一个字节都有逆元。</p><p>密钥长度为128比特。字节（8bits）是AES算法中数据运算的基本单位。AES加密算法由三部分组成：初始密钥加、Nr-1轮循环加密和最后一轮加密。每一轮都有一个由初始密钥生成的轮密钥。</p><ul><li><p>有限域中的加法运算<br>相当于对两个字节做按位异或。</p></li><li><p>有限域中的乘法运算<br>相乘的结果为两个多项式的模乘，AES中不可约多项式(模)为 x^8+x^4+x^3+x+1</p></li><li><p>有限域的X乘运算<br>x（十六进制{02}）乘b(x)可以先对b(x)在字节内左移一位（最后一位补0）；如果b7&#x3D;1，再与十六进制数{1b}做逐比特异或来实现。该运算记为b&#x3D;xtime(x)。</p></li><li><p>四字节运算</p></li></ul><img src="/2024/031353724/image-20240316162412992.png" alt="image-20240316162412992" style="zoom:45%;"><p>AES算法的具体操作是在状态矩阵上进行的。对于128bit的数据，状态矩阵共有4行，32列。每行有4个字节。除了初始密钥（种子密钥），还需要10个轮密钥。</p><p>加密时，将输入字节按照a00，a10，a20，a30；a0,1，a1,1，a2,1，a3,1…的顺序映射到状态矩阵上，加密的最后以同样的顺序提取状态矩阵从而得到输出字节。</p><p>AES加密算法由三部分组成，初始密钥加、Nr-1轮循环加密和最后一轮加密，采用轮迭代结构由四个不同的变换组成。加密过程的四个变换分别为：字节变换（S盒变换）、行移位变换、列混合变换和轮密钥加变换。整个加解密过程如下：</p><img src="/2024/031353724/image-20240316162831828.png" alt="image-20240316162831828" style="zoom:50%;"><ul><li>S盒变换 SubBytes</li></ul><p>​字节替代变换，针对字节的非线性、可逆变换。一个向量乘以一个可逆矩阵，得到输出。它将状态中的每一个字节进行非线性变换为另外一个字节。可以将所有的字节变换排成一个表格，查表直接得到输出。提高速度，减小了矩阵的运算。</p><img src="/2024/031353724/1710436556338.jpg" alt="1710436556338" style="zoom:50%;"><ul><li>行移位变换</li></ul><p>​循环移位。对于128bit的加密，第一行不移动，第二行移动1个字节，第三行移动2个字节，第三行移动3个字节。对于加密，循环左移。解密，后3行依次右循环移动3，2，1个字节。</p><img src="/2024/031353724/image-20240315092725268.png" alt="image-20240315092725268" style="zoom: 50%;"><ul><li>列混合变换</li></ul><img src="/2024/031353724/image-20240315093320194.png" alt="image-20240315093320194" style="zoom:50%;"><img src="/2024/031353724/image-20240315093334980.png" alt="image-20240315093334980" style="zoom:50%;"><p>​解密与加密类似，固定多项式变为拟矩阵，表示如下。</p><img src="/2024/031353724/image-20240316163552550.png" alt="image-20240316163552550" style="zoom:50%;"><ul><li><p>轮密钥加变换</p><p>将状态矩阵与轮密钥进行逐位比特异或操作。</p></li></ul><h4 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h4><p>初始密钥K，共产生4*（Nr+1）个双字。最终的密钥流程产生一个四字节双字的线性数组。{w0,w1,w2,w3}是初始密钥，其中，w0对应的bit[127:96]。</p><p><img src="/2024/031353724/image-20240316163738922.png" alt="image-20240316163738922"></p><ul><li>位置变换</li></ul><p>​将4字节的输入序列，循环左移一个字节输出。</p><ul><li>S盒变换</li></ul><p>​将一个4字节的输入序列的每个字节进行S盒变换输出。</p><ul><li>常量变换</li></ul><p>​Rcon[]是一个具有10个元素的常量数组，x0&#x3D;{01},x1&#x3D;{02},…….x(8)&#x3D;{1b},x(9)&#x3D;{36}</p><h4 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h4><p>为什么AES-128算法采用10次轮加密，而不是20次？</p><p>因为考虑了安全性和性能（速度）的折中，10轮迭代加密基本满足AES加密算法的安全性要求，加密时间也可以接受。</p><h3 id="DES加密算法"><a href="#DES加密算法" class="headerlink" title="DES加密算法"></a>DES加密算法</h3><h4 id="初始置换（IP置换）"><a href="#初始置换（IP置换）" class="headerlink" title="初始置换（IP置换）"></a>初始置换（IP置换）</h4><p>将输入的64bit明文块进行置换和重新排列，生成新的64bit数据块目的：增加加密的混乱程度，使得每一位都能够对后面的加密过程产生影响，提高加密强度。</p><img src="/2024/031353724/4f2a76eb1686402fabf130533445e38a.png" alt="在这里插入图片描述" style="zoom:67%;"><p>逆初始变换的变换规则和初始变换相反，可逆的。</p><h4 id="加密轮F函数"><a href="#加密轮F函数" class="headerlink" title="加密轮F函数"></a>加密轮F函数</h4><p><img src="/2024/031353724/image-20240702151958722.png" alt="image-20240702151958722"></p><p>将64bit的数据分为两组，低32bit为右，高32bit为左。每一轮F函数都需要进行一系列的扩展变换，然后与子密钥异或，进而S盒替换、P盒替换。</p><h4 id="扩展变换"><a href="#扩展变换" class="headerlink" title="扩展变换"></a>扩展变换</h4><p>32bit数据通过扩展置换表得到新的48bit数据。</p><img src="/2024/031353724/image-20240702153041256.png" alt="image-20240702153041256" style="zoom:67%;"><p>通过位数扩展使得每一位都可以在下一步操作中影响更多的比特，达到扩散的效果。</p><h4 id="S盒替换"><a href="#S盒替换" class="headerlink" title="S盒替换"></a>S盒替换</h4><p>扩展置换后的48bit数据，通过8个S盒得到32bit数据。具体如下：每组6bit数据的第1bit和最后1bit拼接得到{data[6]，data[1]}行索引，中间4bit作为列索引得到相应的数据。</p><h4 id="P盒替换"><a href="#P盒替换" class="headerlink" title="P盒替换"></a>P盒替换</h4><p>和初始变换类似，替换数据的位置即可。</p><img src="/2024/031353724/image-20240702155217039.png" alt="image-20240702155217039" style="zoom:67%;"><h4 id="子密钥产生模块"><a href="#子密钥产生模块" class="headerlink" title="子密钥产生模块"></a>子密钥产生模块</h4><p>DES算法使用64bit密钥，真正参与加解密运算的只有56bit，64位密钥中第1、8、16、24、32、40、48、56及64位都是奇偶校验标志位，用于检验密钥在产生子密钥的过程中是否发生错误。</p><img src="/2024/031353724/image-20240702161608655.png" alt="image-20240702161608655" style="zoom: 80%;"><p>64bit初始密钥首先根据密钥转换表得到56位密钥，原理和初始置换相同。再由56位密钥产生16组子密钥。根据子密钥移位序列表将两个28位的数据循环左移，而后拼接合成，再根据置换表的内容进行置换选择得到48bit输出数据。</p><p>每一组子密钥的生成都需要经历移位、重组、置换步骤，16组子密钥对应16轮重复运算，且每一轮旋转移位后得到的左28位与右28位数据又将作为下一个子密钥生成的输入。</p><h3 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h3><p>Altera开发板的逻辑单元LC是LE，LE的结构：一个4输入的LUT和寄存器</p><p><img src="/2024/031353724/webp.webp" alt="img"></p><p>xillinx开发板的逻辑单元是CLB，一个CLB包括两个slice，每个slice由4个 6输入的LUT和8个寄存器组成。</p><p><img src="/2024/031353724/webp-1719911249197-5.webp" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>低功耗方法学（二）</title>
      <link href="/2024/030658141.html"/>
      <url>/2024/030658141.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-电源门控概述（power-gating）"><a href="#4-电源门控概述（power-gating）" class="headerlink" title="4 电源门控概述（power gating）"></a>4 电源门控概述（power gating）</h2><p>为了减少芯片的总泄漏功耗，非常希望添加关闭未使用的模块的机制，这种技术称为电源门控 <strong>power gating</strong></p><h3 id="4-1-动态功耗和泄漏功耗分布"><a href="#4-1-动态功耗和泄漏功耗分布" class="headerlink" title="4.1 动态功耗和泄漏功耗分布"></a>4.1 动态功耗和泄漏功耗分布</h3><p>电源门控的基本策略是提供两种电源模式：低功率模式和活动模式。目标是在恰当的时间以适当的方式在这些模式中切换，以最大限度的节省功耗，同时最大限度的减少对性能的影响。</p><p>电源门控比时钟门控更有复杂，因为需要模块之间复杂的通信和时间延迟以安全进入和退出电源门控模式。电源门控的控制权可以由软件调度，作为设备驱动程序或操作系统空闲任务的一部分，也可以由电源管理控制器在硬件中启动。需要从以下角度考虑选择哪种控制模式</p><ol><li>可能节省的漏电功耗</li><li>产生进入和退出电源门控模式的时间</li><li>进入和离开这个模式消耗的能量</li><li>模块的活动分布（活动或者睡眠的比例）</li></ol><p><strong>术语</strong></p><p>​SLEEP：进入低功耗模式<br>​WAKE：返回活动模式</p><ul><li><p>通过时钟门控降低功耗</p><img src="/2024/030658141/image-20240306225913409.png" alt="image-20240306225913409" style="zoom: 33%;"></li><li><p>通过电源门控降低功耗</p><p>WAKE时间和时钟运行直接的响应时间很重要，在系统设计层次不能</p><img src="/2024/030658141/1709739346255.jpg" alt="1709739346255" style="zoom:33%;"></li><li><p>电源门控切换速度不彻底（真实情况）</p><img src="/2024/030658141/image-20240306234721173.png" alt="image-20240306234721173" style="zoom:33%;"></li></ul><h3 id="4-2-电源门控在不同子系统上的影响"><a href="#4-2-电源门控在不同子系统上的影响" class="headerlink" title="4.2 电源门控在不同子系统上的影响"></a>4.2 电源门控在不同子系统上的影响</h3><p>带有缓存的CPU系统通常可能长期处于休眠或者不活动状态，使得电源门控的设计更加具有必要性。需要考虑一下因素：</p><ul><li>电压门控技术可以很好的降低CPU的泄漏功耗</li><li>如果每次CPU断电时缓存内容都丢失，上电时需要重新填充，可能需要花费大量时间和成本</li><li>节省的净能量取决于睡眠和唤醒的活动性。即电源门控节省的能量和重新加载消耗的能量。</li></ul><p>外围子系统受到设备驱动程序和操作系统的电源管理方案控制。需要在唤醒时快速恢复状态以最大限度的节省功耗</p><ul><li>设备驱动程序可能需要显示加载&#x2F;恢复密钥状态或启动硬件定时器控制作为唤醒&#x2F;睡眠的一部分</li><li>更好的方式是外设在睡眠模式时，保存一些状态，但是需要额外的电路和控制。</li></ul><h3 id="4-3-电源门控的设计原理"><a href="#4-3-电源门控的设计原理" class="headerlink" title="4.3 电源门控的设计原理"></a>4.3 电源门控的设计原理</h3><p>使用电源门控的SoC简化视图如下，与时钟通电的模块不同，电源门控功能模块通过电源开关网络接收电源。电源开关网络分布在电源门控功能模块周围。Isol模块放置在电源门控模块和始终开启模块之间，当输入处于阈值电压时，输出电压的过渡状态很短，不会对后面always on模块产生较大影响，起到了隔离的作用。</p><img src="/2024/030658141/image-20240307135341610.png" alt="image-20240307135341610" style="zoom:40%;"><p>对于某些电源门控模块，非常希望在断电时保留模块内部状态，并在通电期间恢复该状态。这种策略在上电期间可以节省大量时间和功耗。实现方式：将保留寄存器替代普通寄存器。</p><p>保持寄存器通常具有比主寄存器慢但是泄漏电流小得多的辅助寄存器或者影子寄存器。影子寄存器始终处于通电状态，并在电源门控期间存储主存储器的内容。该控制信号由电源门控控制器提供。</p><h4 id="4-3-1-电源切换-细粒度和粗粒度"><a href="#4-3-1-电源切换-细粒度和粗粒度" class="headerlink" title="4.3.1 电源切换-细粒度和粗粒度"></a>4.3.1 电源切换-细粒度和粗粒度</h4><p>电源切换一般有两种方法：细粒度电源门控和粗粒度电源门控</p><p>在细粒度电源切换门控中，开关放置在库中每个标准单元中，由于开关必须提供电源所需要的最坏情况电流，因此必须相当大，以免影响性能。每个单元的面积开销很大（通常是原始单元大小的2到4倍）。下面是带上拉的细粒度与门。</p><img src="/2024/030658141/image-20240307144844883.png" alt="image-20240307144844883" style="zoom:50%;"><p>细粒度电源门控的主要优点是，开关上的IR压降的时序影响和钳位器的行为很容易表征，因为他们包含在单元内，可以采用传统的设计方法部署细粒度电源门控。</p><p>在粗粒度电源门控中，一组门级单元通过一组开关单元来切换电源。时序分析困难，但是面积相比细粒度小很多。</p><p>目前，设计中都是使用粗粒度电源门控。任何电源门控的关键挑战是减小涌浪电流，以避免电源网络中出现过多的IR压降。否则，电源门控模块的功能和状态 当进行睡眠&#x2F;复位顺序不同时会被破坏。</p><h4 id="4-3-2-电源门控的挑战"><a href="#4-3-2-电源门控的挑战" class="headerlink" title="4.3.2 电源门控的挑战"></a>4.3.2 电源门控的挑战</h4><ol><li>电源开关结构设计</li><li>电源门控控制器设计</li><li>保持寄存器和隔离寄存器的选择和使用</li><li>最大限度减少电源门控对时序和面积的影响</li><li>接口隔离</li><li>时钟和复位的功能控制</li><li>对每个受支持的电源状态与状态相关的验证</li><li>制造和生产测试策略</li></ol><h2 id="5-电源门控设计"><a href="#5-电源门控设计" class="headerlink" title="5 电源门控设计"></a>5 电源门控设计</h2><p>带有电源门控的SoC结构，需要解决的问题：开关网络和电源门控控制器的设计、何时何地插入保留寄存器和隔离寄存器。</p><img src="/2024/030658141/image-20240309092347605.png" alt="image-20240309092347605" style="zoom: 67%;"><h3 id="5-1-开关结构设计"><a href="#5-1-开关结构设计" class="headerlink" title="5.1 开关结构设计"></a>5.1 开关结构设计</h3><p>第一种架构是切换VDD还是VSS，或者同时切换。一般采用NMOS传递低电压，PMOS传递高电压，因为没有阈值电压损失。但是这种切换的开关电源会导致较大的IR Drop在电源上，进而影响设计中门的延迟。</p><img src="/2024/030658141/image-20240309094251614.png" alt="image-20240309094251614" style="zoom:50%;"><p>对于Header-Switch结构，当开关关闭时，GATED VDD输出趋近于低电平。对于Footer-Switch 结构，当开关关闭时，GATED VSS输出趋近于高电平。</p><p>注意，在NMOS导通传递低电平，在PMOS导通传输高电平时，无法保证没有电压损失，因为开关有漏电流。<strong>这也是为什么输出需要隔离单元的原因之一</strong></p><p>推荐的方式:</p><ul><li>切换电源或者低，而不是两者都切换，以减小IR drop。</li><li>在设计前期决定是Header-Switch还是GATED VDD更适合系统设计。</li><li>Header-Switch更适合外部电源门控</li><li>Header-Switch适合用在多电压或者电压调节技术中</li></ul><p>缺点：</p><p>Footer-Switch电源门控与外部开关电源或者多个电源混用时，会导致整个设计的功耗、时序和功能变得复杂，对标准单元库提出了更复杂的要求。</p><h4 id="5-1-1-控制开关网络"><a href="#5-1-1-控制开关网络" class="headerlink" title="5.1.1 控制开关网络"></a>5.1.1 控制开关网络</h4><p>关键问题在于限制模块电源切换时所产生的涌浪电流，过多的这种电流会导致电源出现电压尖峰，可能损坏常开模块中寄存器以及电源门控模块中的保留寄存器。</p><p>一种代表性降低涌浪电流的方法是将控制信号以链表方式连接到开关，来自电源控制器的控制信号连接到第一个开关，它缓冲（具有适当的延迟）信号并将其发送到下一个开关。</p><p>这种链的结果是，从发出“加电”信号到模块加电需要一些时间。因此，交换结构通常会提供确认信号来指示该结构已完全加电。该信号可以简单地是“加电”控制信号的最终缓冲版本。</p><p>更激进的一种方式是依次使用多个上电控制信号，第一控制信号可以打开一组弱开关或“涓流”开关，这些开关启动加电但限制浪涌电流。然后第二控制信号可以打开主电源开关组。</p><p>无论具体的控制方法如何，在上电序列期间，重要的是要等到交换结构完全上电，然后才能使电源门控块恢复正常操作。该上电序列的时序由电源控制器负责。</p><p>电源开关结构的控制信号（电源开&#x2F;关和确认的整个链）必须由始终开启的缓冲区进行缓冲，而不是由电源门控缓冲区进行缓冲。</p><h4 id="5-1-1-电源门控的建议和陷阱"><a href="#5-1-1-电源门控的建议和陷阱" class="headerlink" title="5.1.1 电源门控的建议和陷阱"></a>5.1.1 电源门控的建议和陷阱</h4><p>建议</p><ul><li>电源控制器需要针对特定的电源门控技术来设计</li><li>应该为电源门控控制端口提供断言，以匹配所选的开关技术，确保RTL设计环境中的功能验证和覆盖率</li><li>电源门控控制信号必须在测试期间可控。</li></ul><p>陷阱</p><ul><li>将外部电源门控和内部电源门控相结合可能会很麻烦，因为在内部的电源在外部电源门控期间可能不会“始终开启”。在这种情况下需要仔细设计和验证。</li></ul><h3 id="5-2-信号隔离"><a href="#5-2-信号隔离" class="headerlink" title="5.2 信号隔离"></a>5.2 信号隔离</h3><p>电源门控模块的每个接口都需要进行管理，确保关闭该电压域不会导致其他模块的任何输入出现涌浪电流。并且需要保证掉电模块的输出浮动不会导致上电模块出现虚假翻转行为。</p><p>电源门控模块的输出是主要的问题，因为它们可能导致其他模块出现电气或者功能问题。输入一般不是问题，因为它们可以通过上电模块驱动为有效逻辑值，不会在断电模块中产生电气或者功能问题。</p><h4 id="5-2-1-信号隔离技术"><a href="#5-2-1-信号隔离技术" class="headerlink" title="5.2.1 信号隔离技术"></a>5.2.1 信号隔离技术</h4><p>控制掉电模块输出的基本方法是使用隔离单元将输出钳位到特定的有效值。</p><p>隔离单元分为三种类型：将信号钳位到0的单元、将信号钳位到1的单元以及将信号锁定存为最近值的隔离单元。</p><p>钳位库单元旨在避免信号输入浮动时出现的涌浪电流和泄漏路径，只要控制输入信号处于合适的状态即可。此外，这些钳位库单元具有特殊的属性，保证在综合时不会因逻辑优化而被优化掉或者优化错误。</p><p>两种隔离单元，与门类型和或门类型</p><img src="/2024/030658141/image-20240310183835490.png" alt="image-20240310183835490" style="zoom: 43%;"><p>注意的是，这些钳位单元对于输入到输出带来了一些延迟，对于关键路径，可能会带来setup违例的影响，比如高速缓存接口。另一种不增加延迟的隔离技术是使用上拉或者下拉晶体管。但是可能会带来多个驱动晶体管，需要仔细设计和排序，避免竞争使用。即使上拉或者下拉晶体管是相对较弱的器件，总数也可能足够大，以至于总线产生的电流过量导致问题。</p><img src="/2024/030658141/image-20240310191620029.png" alt="image-20240310191620029" style="zoom: 43%;"><p>为了避免输出毛刺，在上电期间，需要保证输出隔离。这种隔离效果应该是直接的，对于上拉&#x2F;下拉晶体管来说，可能相当具有挑战性，因为只要这些晶体管在活动状态下重新上电，会出现多点驱动问题，输出不定，产生毛刺。</p><p>尽管上拉&#x2F;下拉钳位隔离单元在面积和时序上有优势，但是由于出现的诸多问题，不建议参与RTL设计。相反，建议使用”门级”单元格式。</p><h4 id="5-2-2-输出和输入隔离"><a href="#5-2-2-输出和输入隔离" class="headerlink" title="5.2.2 输出和输入隔离"></a>5.2.2 输出和输入隔离</h4><p>如上所述，有必要隔离电源门控单元的输出，以避免浮动输出驱动上电模块输入的电气问题。从逻辑上讲，将信号钳位在电源门控模块的输出还是目的模块的输入没有什么区别。</p><p>但是有一些实际考虑因素会影响这一选择。</p><p>电源门控模块的输出至少会流向多个上电模块。如果在上电模块的输入隔离，需要多个隔离单元。因此，在电源门控模块的输出隔离更节省面积。在电源门控模块的输出做隔离，使得分析更加容易。</p><p>但是源头隔离输出的方式，对于布局和布线提出了一些限制。与电源门控模块中的其他门不同，隔离单元必须保证在断电期间保持通电状态，所以需要提供常开的电源线，使得电源布线变得复杂，但是现在EDA工具能够解决这个问题。</p><p>因此，强烈建议输出信号采用源头隔离的方式。</p><h4 id="5-2-3-接口协议和隔离"><a href="#5-2-3-接口协议和隔离" class="headerlink" title="5.2.3 接口协议和隔离"></a>5.2.3 接口协议和隔离</h4><p>设计电源门控模块的接口时，有两个目标：最大程度地减少泄漏电流和避免不必要或不正确的行为。</p><p>无论如何，需要考虑在断电期间，将接口信号钳位到0&#x2F;1带来的影响。钳位到错误的电平，可能会增加漏电流。</p><p>对于Header switched设计方式，建议使用高电平有效，低电平有效复位，将所有信号钳位到0。对于Footer-switched方式，建议高电平有效信号和低电平有效复位，并将所有信号钳位为“0”，此规则有一个可能的例外：如果在接收块的输入处使用传输门。如果使用传输门，我们可能需要钳位为“1”以避免潜路径泄漏。</p><img src="/2024/030658141/image-20240310205621878.png" alt="image-20240310205621878" style="zoom: 33%;"><p>普遍倾向于使用高电平有效和低电平有效复位的原因有两个：这是最常用的设计；对于RTL设计也容易、易于调试</p><p>最后一点：对于复杂的协议，可能需要更复杂的隔离策略：将信号在断电时保持不变。这种方法允许重新启动进程，而不是从复位状态开始。但是这种需要带锁存的隔离单元，并不是所有库中都有该单元。只有在绝对必要时才使用该策略。</p><h3 id="隔离的建议和陷阱"><a href="#隔离的建议和陷阱" class="headerlink" title="隔离的建议和陷阱"></a>隔离的建议和陷阱</h3><p>建议</p><ul><li>隔离电源门控模块的输出</li><li>使用隔离单元而不是上拉或下拉式钳位，除非使用非常专门的接口协议</li><li>确保在隔离控制信号测试期间可以检测到卡在 0 和卡在 1 故障</li></ul><p>缺陷</p><ul><li>确保隔离单元始终处于通电状态</li><li>时钟上的隔离钳位会使时钟树合成和时序收敛变得相当复杂，如果可能，请避免在电源门控模块中生成并在该模块外部使用的时钟。</li></ul><h3 id="5-3-状态保留和恢复的方法"><a href="#5-3-状态保留和恢复的方法" class="headerlink" title="5.3 状态保留和恢复的方法"></a>5.3 状态保留和恢复的方法</h3><p>给定电源开关结构和隔离策略，就可以对逻辑模块进行电源门控。如果不使用保留策略，断电后重新上电，所有状态信息都会丢失。要在上电时恢复其状态，该模块必须从外部源恢复其状态或从复位条件建立其状态。无论哪种情况，所需的时间和功率都可能很大。</p><p>保留状态的寄存器数目，需要根据子系统的特征进行评估。</p><p>多种方法可以保存和恢复电源门控模块的内部状态</p><ul><li>基于软件的读写寄存器</li><li>使用扫描链在片外存储芯片掉电时的状态</li><li>使用保留寄存器保存寄存器的状态</li></ul><p>采用软件方法保留和恢复状态的缺点</p><ul><li>总线阻塞会降低断电和上电的速度</li><li>总线冲突会使得模块保存和恢复状态时间不确定。</li><li>实现起来较为复杂。</li></ul><h4 id="5-3-2-基于扫描链保留状态"><a href="#5-3-2-基于扫描链保留状态" class="headerlink" title="5.3.2 基于扫描链保留状态"></a>5.3.2 基于扫描链保留状态</h4><p>为了DFT而设计的扫描链可以重新用关于执行状态保留，几乎不会增加多余的硬件开销。在断电期间，扫描寄存器像扫描测试一样，输出到片外或片内存储器中，如果位于片内，存储器需要时钟通电。在上电期间，扫描链从存储器加载数据。</p><p>一旦状态被扫描到内存中，整个子系统的电源可以完全断电，无需为保留寄存器 保留时钟开启的电源区域。</p><p>从RTL设计角度来说，存在挑战。在DC之前不会插入和连接扫描触发器，但有必要在综合之前对控制器进行仿真和调试。</p><p>为了实现最快的保存和恢复时间，我们希望使用内存数据总线的所有位宽来保存数据写入内存。意味着扫描链的数量等于内存数据总线的宽度。实际上，扫描链可能太多，无法用于制造测试。但通常我们会使用至少 8 个扫描链，并且可能是 8 的倍数。对于多条的扫描链，需要平衡扫描链的长度，因为这写扫描链都是使用同一个移位使能信号。</p><p>寄存器状态保存和恢复会带来较大功耗，如果使用外部存储器，则 IO 功率可能会很大，即使使用内部存储器，仅仅通过扫描链移动数据就可能需要大量的动态功率。并且可能带来不可接受的IR电压降。</p><p>对于长期睡眠，通过关闭整个子系统可以节省漏电。如果可以使用扫描链恢复状态，对于功耗的节省更加显著。</p><p>下面是4bit的保存数据扫描链示意图，其中一个扫描链比其他扫描链短，一旦扫描链平衡，状态就可以保存在内存中，然后从内存中恢复。</p><p><img src="/2024/030658141/image-20240323200253055.png" alt="image-20240323200253055"></p><p>网表实现之前（插入扫描链），对RTL级进行仿真和验证是一个挑战，但是并非不可克服。</p><p>一种方法是将添加条件代码，这些代码仅在模拟基于扫描保留时才进行编译。该代码进行行为级建模，以验证控制器是否正常运行以及数据是否正确写入存储器和从存储器中读取。</p><h4 id="5-3-2-保留寄存器"><a href="#5-3-2-保留寄存器" class="headerlink" title="5.3.2 保留寄存器"></a>5.3.2 保留寄存器</h4><p>保留寄存器包含一个“影子”寄存器，可以在断电期间保留寄存器状态，并在上电时恢复。与主寄存器不同，影子寄存器需要始终在通电状态。</p><p>下图显示了两个保留寄存器，在每种情况下，主寄存器均有开关电源轨“VDD_SW”供电，CLK，D和RESETN引脚均在主寄存器上运行。影子寄存器始终由电源VDD供电。</p><p>左图中，当SAVE有效时，主寄存器的状态将加载到影子寄存器中。当RESTORE有效时，影子寄存器的状态被加载回主寄存器。右图中，当RETAIN变高时，主寄存器状态加载到影子寄存器中，当RETAIN变低时，影子寄存器状态加载回主寄存器。RETAIN是边沿敏感信号。</p><img src="/2024/030658141/image-20240323203605089.png" alt="image-20240323203605089" style="zoom:50%;"><p>物理实现中，保留寄存器会带来一定的面积开销，通常为20%或更多。一些保留寄存器包含保护带，以尽可能稳健地将保留状态与电源门控瞬态隔离。在这种情况下，面积开销可能高达 50% 或更多。在具有大量寄存器的设计中，该区域的影响可能很大。</p><p>考虑替代方案。我们可以限制实现仅使用低泄漏、高 VT 寄存器，</p><h4 id="5-3-3-用于保留的电源控制器设计"><a href="#5-3-3-用于保留的电源控制器设计" class="headerlink" title="5.3.3 用于保留的电源控制器设计"></a>5.3.3 用于保留的电源控制器设计</h4><p>控制器必须给出保存和恢复寄存器明确的顺序。影子寄存器可能很慢，需要保证在保存操作时，主寄存器的数据是稳定的。大多数设计人员在执行保存之前停止时钟。当然，保存操作必须在电源关闭之前完成。</p><p>必须先完成恢复操作，然后才能将新值加载到主寄存器。大多数设计人员在还原操作完成之前不会重新启动时钟。</p><p>虽然功率门控控制器在设计中需要一定的注意，但保留寄存器对标准触发器的实际替代可以在实现期间可以通过EDA工具自动完成。</p><p>为了最小化泄漏，时钟和复位树可能在掉电期间关闭。为了防止这些浮动（模拟中的X）信号损坏保留寄存器，保留必须优先于时钟和复位在设计功率门控控制器时，重要的是要理解功率门控库中可用单元的行为，以确保影子寄存器不会因浮动时钟和复位而损坏。</p><h4 id="5-3-4-部分和完全状态保留"><a href="#5-3-4-部分和完全状态保留" class="headerlink" title="5.3.4 部分和完全状态保留"></a>5.3.4 部分和完全状态保留</h4><p>在部分状态保留中，只保存和恢复“架构上可见”的状态。挑战在于非保留寄存器需要在安全、合法和可验证的状态下上电启动。非保留寄存器的典型例子：FIFO、存储器和计数器。这些器件转换成保留寄存器可能非常昂贵。</p><p>深状态和浅状态的概念在确定非保留寄存器时可能有用。浅状态指的是直接控制设计逻辑的寄存器，也就是说，可以绘制为状态机图的设计部分。深状态是指状态机使用的寄存器，但其中包含大量的辅助数据，如内存，计数器和FIFO，通常不会将这些器件作为状态机的一部分。</p><p>对于部分保留，合理的策略可以是保存和恢复浅状态，并且具有用于处理深状态的单独策略。重置深状态寄存器的控制器是一种可能的策略。在恢复时，需要仔细和有选择的使用复位，保证只复位非保留寄存器，不干扰保留寄存器。</p><h4 id="5-3-5-系统级问题和保留"><a href="#5-3-5-系统级问题和保留" class="headerlink" title="5.3.5 系统级问题和保留"></a>5.3.5 系统级问题和保留</h4><p>构成时钟门控使能的所有状态位都需要保留或重新初始化为安全和可重启的条件，以此方式，可以干净地重新生成时钟门控单元锁存器的内容，而不需要向时钟门控单元添加保持。</p><h4 id="5-3-6-状态保留的建议和陷阱"><a href="#5-3-6-状态保留的建议和陷阱" class="headerlink" title="5.3.6 状态保留的建议和陷阱"></a>5.3.6 状态保留的建议和陷阱</h4><h5 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h5><ul><li>如果实现部分保留，则为设计的保留和非保留存储部分提供单独的重置。这允许对上电复位和恢复&#x2F;重新初始化操作进行清晰的验证。</li><li>在实现部分保留时，确保状态机和定序器不依赖于非保留状态，以避免状态相关的死锁或无效状态条件。(The如果必须用非保留状态测试许多保留状态值，则要验证的状态空间可能是巨大的）。</li><li>在专用保留寄存器的面积影响太高的情况下，则重用制造扫描链是一种选择。</li><li>在扫描测试期间，必须使保留控制可控且可观察。</li></ul><h5 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h5><ul><li>不良的浪涌电流管理或保留电源噪声可能会损坏保留寄存器，导致重启时出现不安全&#x2F;无效状态。</li><li>部分保留需要更严格的重置和恢复验证，以确保保留&#x2F;恢复状态和重新初始化的非保留状态之间永远不会出现死锁情况。</li><li>影响时钟门控的使能需要保存其状态，以确保接下来的行为正确。</li><li>基于扫描的保存和恢复方法可能使用系统总线来向&#x2F;从存储器传输数据。该总线通常可以具有等待状态;因此，需要注意确保扫描保存&#x2F;恢复控制器可以支持等待状态而没有任何数据丢失。</li></ul><h3 id="5-4-电源门控控制"><a href="#5-4-电源门控控制" class="headerlink" title="5.4 电源门控控制"></a>5.4 电源门控控制</h3><p>有了电源交换结构、隔离策略和保留策略，我们现在可以设计控制掉电和上电顺序的电源控制器</p><h4 id="5-4-1-电源控制时序"><a href="#5-4-1-电源控制时序" class="headerlink" title="5.4.1 电源控制时序"></a>5.4.1 电源控制时序</h4><p>不需要保存状态情况下，关闭电源进行下面操作。</p><ul><li>刷新正在进行的任何总线或外部操作</li><li>在适当的阶段停止时钟，以最大限度地减少漏入电源门控区的电流</li><li>置位隔离控制信号，将所有输出置于安全状态。</li><li>对模块进行复位，使其在复位条件下上电</li><li>置位电源门控控制信号，使模块掉电</li></ul><p>在恢复电源时，进行下面操作</p><ul><li>使电源门控控制信号无效，让模块上电。</li><li>根据控制涌浪电流的方法和技术，选择对多个控制信号排序，分阶段上电。</li><li>取消复位有效，确保门控上电后的初始化。</li><li>取消隔离控制信号有效，恢复输出</li><li>重新启动时钟，无毛刺且不违反最小脉宽设计约束</li></ul><img src="/2024/030658141/image-20240324104727581.png" alt="image-20240324104727581" style="zoom:67%;"><img src="/2024/030658141/image-20240324110003813.png" alt="image-20240324110003813" style="zoom:67%;"><h4 id="5-4-2-握手协议"><a href="#5-4-2-握手协议" class="headerlink" title="5.4.2 握手协议"></a>5.4.2 握手协议</h4><p>电源门控上电和掉电需要时间，电源门控切换结构必须限制电压尖峰（可能会破坏保留寄存器或其他上电模块），大多数设计通过在上电期间限制电流来实现这一点，从而限制电压上升到其最终值的速率。</p><p>电源控制器必须适应此过程，它必须等到加电完成后才能发出restore。也就是说，它必须在通电和恢复时插入延迟。最简单的方法是在控制时序中加入一个固定延迟。计数器计数到足够周期以满足上电和掉电时间。但是，在RTL中嵌入这样的时间常数将RTL绑定到特定交换结构实现的定时。结果是IP的便携性或可重复使用性明显降低。</p><p>因此，建议使用req-ack握手来控制电源切换结构。</p><img src="/2024/030658141/image-20240324112423023.png" alt="image-20240324112423023" style="zoom:67%;"><p>电源控制器发出N_PWR_REQ以关闭电源交换结构。交换结构负责在电源完全关闭时返回N_PWR_ACK。上电时，控制器解除N_PWR_ACK以打开交换结构。当交换结构完全打开并且可以安全进行时，交换结构解除N_PWR_ACK。之后按照，RESET和ISO的时序发出信号。</p><p>在电源控制器中，电源的ACK信号通常是异步的，需要将该信号同步到该时钟域才可以使用。</p><h4 id="5-4-3-电源门控控制器的建议和缺陷"><a href="#5-4-3-电源门控控制器的建议和缺陷" class="headerlink" title="5.4.3 电源门控控制器的建议和缺陷"></a>5.4.3 电源门控控制器的建议和缺陷</h4><h5 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h5><ul><li>设计具有用于电源门控控制的请求和确认握手的控制器</li><li>需要设计同步器确保安全的唤醒时序</li></ul><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul><li>一种关键情况是，控制器在掉电后立即尝试对模块上电，而实际上掉电尚未完成。也就是说，上电序列在电源门控结构仅部分断电时开始。设计人员在设计功率控制器时需要仔细考虑这种情况。请记住，关断时间取决于半导体工艺和温度。</li></ul><h3 id="5-5-电源门控设计与验证-RTL仿真"><a href="#5-5-电源门控设计与验证-RTL仿真" class="headerlink" title="5.5 电源门控设计与验证-RTL仿真"></a>5.5 电源门控设计与验证-RTL仿真</h3><p>接下来我们考虑在RTL级验证电源门控电路的问题。这是一个挑战，因为硬件描述语言（HDL）不提供用于在RTL级描述电源连接的机制。为了模拟电源门控，我们需要扩展Verilog，通过修改代码或使用一组单独的命令来描述电源连接和电源开关。</p><p>同一电源格式（Unified Power Format，UPF）定义了用于电源门控和仿真的语言格式和语义。UPF标准的大部分内容都涉及电源策略的实现。</p><h4 id="5-5-1-推断RTL中电源门控的行为"><a href="#5-5-1-推断RTL中电源门控的行为" class="headerlink" title="5.5.1 推断RTL中电源门控的行为"></a>5.5.1 推断RTL中电源门控的行为</h4><p>第一步是模拟掉电块的影响。</p><p>UPF提供了一种机制（一组tcl命令），用于定义电源域（一组Verilog模块）和电源域的一组电源（电源和接地电源网）。</p><p>下图显示了要模拟设计的电源连接。Verilog模块my_module（实例U1）有一个header开关，用于控制模块中所有逻辑的电源。功率门控控制器解除断言pwr_req以使模块掉电，并且断言pwr_req以使模块上电。信号pwr_ack是表示交换机已完成上电&#x2F;掉电的确认信号。在RTL级别，它只是一个缓冲版本的req。在门级网表中，它将具有真实的延迟。具体的UPF命令如下</p><img src="/2024/030658141/image-20240324172644978.png" alt="image-20240324172644978" style="zoom:67%;"><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">create_power_domain top <span class="token operator">-</span>include_scopecreate_power_domain top_power_domain <span class="token operator">-</span>include_scopecreate_supply_net VDD_SOC <span class="token operator">-</span>domain top_power_domainconnect_supply_net VDD_SOC <span class="token operator">-</span>domain top_power_domaincreate_supply_net VSS_SOC <span class="token operator">-</span>domain top_power_domainconnect_supply_net VSS_SOC <span class="token operator">-</span>domain top_power_domainset_scope U1create_power_domain my_power_domain <span class="token operator">-</span>include_scopecreate_supply_net sw_vdd <span class="token operator">-</span>domain my_power_domainset_domain_supply_net my_power_domain <span class="token operator">-</span>primary_power_net sw_vdd <span class="token operator">-</span>primary_ground_net <span class="token operator">/</span>top<span class="token operator">/</span>VSS_SOC<span class="token comment">#create_power_switch block1_sw   -domain block1  </span><span class="token comment">#-input_supply_port &#123;&lt;PIN_NAME> VDD&#125; </span><span class="token comment">#-output_supply_port &#123;&lt;PIN_NAME> VDD_1&#125; </span><span class="token comment">#-control_port &#123;&lt;PIN_NAME> inst_always_on/pwr_ctrl&#125; </span><span class="token comment">#-on_state     &#123;&lt;state_name> &lt;input_pin_name> &lt;boolean_expression>&#125;</span><span class="token comment">#-off_state    &#123;&lt;state_name> &lt;boolean_expression>&#125;</span>                        create_power_switch my_power_switch <span class="token operator">-</span>domain my_power_domain<span class="token operator">-</span>input_supply_port <span class="token punctuation">&#123;</span>my_sw_input_port <span class="token operator">/</span>top<span class="token operator">/</span>VDD_SOC<span class="token punctuation">&#125;</span><span class="token operator">-</span>output_supply_port <span class="token punctuation">&#123;</span>my_sw_output sw_vdd<span class="token punctuation">&#125;</span><span class="token operator">-</span>control_port <span class="token punctuation">&#123;</span>my_sw_control <span class="token operator">/</span>top<span class="token operator">/</span>pwr_req<span class="token punctuation">&#125;</span><span class="token operator">-</span>ack_port <span class="token punctuation">&#123;</span>my_ack_port <span class="token operator">/</span>top<span class="token operator">/</span>pwr_ack<span class="token punctuation">&#125;</span><span class="token operator">-</span>on_state <span class="token punctuation">&#123;</span>pwr_on_state my_input_port<span class="token punctuation">&#123;</span>my_sw_control_port <span class="token operator">==</span> 1<span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token operator">-</span>off_state <span class="token punctuation">&#123;</span>pwr_off_state <span class="token punctuation">&#123;</span>my_sw_control <span class="token operator">==</span> 0<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当pwr_req拉低时（请求关断），开关会关闭所有元件的电源，也就是所有寄存器的输出为x，U1的输出为x。与此同时，pwr_ack信号拉低，通知电源控制器电源已经完全关闭。UPF支持为应答信号分配延迟，但对于RTL仿真，我们使用默认的零延迟。</p><p>当pwr_req拉高时，开关将电源接通U1的所有元件，所有寄存器恢复其正常操作，与此同时，将pwr_ack设置为高，通知电源控制器电源已完全打开。</p><p>对于不支持UPF的仿真器，可以使用行为级代码模拟电源门控的行为。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>current_state <span class="token operator">&lt;=</span> <span class="token number">4'b0101</span><span class="token punctuation">;</span><span class="token keyword">else</span>current_state <span class="token operator">&lt;=</span> next_state<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token constant">`ifdef</span> RTL_PG_EMULATE<span class="token keyword">wire</span> sw_vdd<span class="token punctuation">;</span><span class="token keyword">assign</span> sw_vdd <span class="token operator">=</span> pwr_req <span class="token operator">&amp;</span> pwr_ack<span class="token punctuation">;</span><span class="token constant">`endif</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token constant">`ifdef</span> RTL_PG_EMULATE<span class="token keyword">or</span> <span class="token keyword">negedge</span> sw_vdd<span class="token constant">`endif</span> <span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token constant">`ifdef</span> RTL_PG_EMULATE<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sw_vdd<span class="token punctuation">)</span>current_state <span class="token operator">&lt;=</span> <span class="token number">4'bXXXX</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token constant">`endif</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>current_state <span class="token operator">&lt;=</span> <span class="token number">4'b0101</span><span class="token punctuation">;</span><span class="token keyword">else</span>current_state <span class="token operator">&lt;=</span> next_state<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// 在掉电的瞬间，current_state输出x态。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-5-2-推断RTL中的电源门控和保留的行为"><a href="#5-5-2-推断RTL中的电源门控和保留的行为" class="headerlink" title="5.5.2 推断RTL中的电源门控和保留的行为"></a>5.5.2 推断RTL中的电源门控和保留的行为</h4><p>对于使用保留的设计， 下一步是修改RTL建模保留状态的行为。</p><ul><li>在保存操作之前，保留状态变量初始化为x</li><li>在SAVE操作时，采样寄存器的状态保存到 保留寄存器。</li><li>电源门控时，强制所有的寄存器输出x</li><li>在RESTORE操作时，从保留寄存器的值恢复到主寄存器</li><li>建模时，确保电源门控、保持、复位和时钟的优先级顺序。</li></ul><p>UPF提供命令来指定保留寄存器的“always on”电源网络以及保存和恢复控制信号。默认情况下，set_retention命令会将电源域中的所有寄存器转换为保留寄存器。</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set_retention my_retention_strategy <span class="token operator">-</span>domain my_power_domain<span class="token operator">-</span>retention_power_net VDD_SOCset_retention_control my_retention_strategy<span class="token operator">-</span>domain my_power_domain<span class="token operator">-</span>save_signal <span class="token punctuation">&#123;</span>SAVE posedge<span class="token punctuation">&#125;</span><span class="token operator">-</span>restore_signal <span class="token punctuation">&#123;</span>NRESTORE negedge<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过RTL来建模描述保存和恢复寄存器的行为</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> save_current_state<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> SAVE<span class="token punctuation">)</span> <span class="token keyword">begin</span>save_current_state <span class="token operator">&lt;=</span> current_state<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> NRESTORE<span class="token punctuation">)</span> <span class="token keyword">begin</span>current_state <span class="token operator">&lt;=</span> save_current_state<span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 低功耗圣经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低功耗方法学（一）</title>
      <link href="/2024/030235044.html"/>
      <url>/2024/030235044.html</url>
      
        <content type="html"><![CDATA[<h1 id="低功耗方法学-一"><a href="#低功耗方法学-一" class="headerlink" title="低功耗方法学(一)"></a>低功耗方法学(一)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>参考《Low_Power_Methodology_Manual_for_Soc_Design》，将认为重点的知识点进行记录和总结。</p></blockquote><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><h3 id="1-1-功耗和能量"><a href="#1-1-功耗和能量" class="headerlink" title="1.1 功耗和能量"></a>1.1 功耗和能量</h3><p>​功耗是瞬时能量，能量是一个总和；类似于速度和距离的关系；</p><img src="/2024/030235044/image-20240302005439890.png" style="zoom: 40%;"><h3 id="1-2-动态功耗"><a href="#1-2-动态功耗" class="headerlink" title="1.2 动态功耗"></a>1.2 动态功耗</h3><p>动态功耗有两种，电容充放电功耗和短路电流功耗；</p><img src="/2024/030235044/image-20240303101531073.png" alt="image-20240303101531073" style="zoom: 33%;"><p>第一项是电容充放电功耗，第二项是短路电流功耗，tsc为短路电流持续时间。随着工艺尺寸的降低，静态功耗的占比越来越大，甚至超过动态功耗。</p><p>降低电压会大大降低功耗，但是会导致载流子的速度降低，影响性能。一般SoC设计者，使用以下方式降低功耗。</p><ol><li>多电压技术。不同设备采用不同电压，外围低速设备使用低电压。</li><li>电压缩放技术，动态电压管理技术。一个模块支持多电压工作，在执行繁忙任务时，使用高电压，在执行低性能任务时，使用低电压。</li><li>时钟门控技术，降低信号翻转带来的功耗。</li></ol><h3 id="静态功耗"><a href="#静态功耗" class="headerlink" title="静态功耗"></a>静态功耗</h3><p>​静态功耗是在信号不翻转时的功耗，又称为漏电功耗。来源：栅极漏电、衬底电流和漏极反偏结漏电。</p><img src="/2024/030235044/image-20240303151547141.png" alt style="zoom:33%;"><h2 id="2-标准低功耗方法学"><a href="#2-标准低功耗方法学" class="headerlink" title="2 标准低功耗方法学"></a>2 标准低功耗方法学</h2><h3 id="2-1-时钟门控"><a href="#2-1-时钟门控" class="headerlink" title="2.1 时钟门控"></a>2.1 时钟门控</h3><p>动态功耗中，时钟缓冲器带来的功耗占比超过50%，甚至更多。降低这种功耗最常见的办法是在不需要时钟时，关闭时钟。</p><p>在现在的EDA工具中，带有同步使能的寄存器，通过会自动识别并转换成门控时钟电路，而不影响逻辑功能，如下图所示。</p><img src="/2024/030235044/image-20240303154850877.png" alt style="zoom: 40%;"><p>如果使用时钟门控的寄存器为多bit，比如32bit，使用时钟门控技术对于功耗的降低是非常明显的。因为使用一个门控时钟，输出连接32个寄存器，节省了32个重复的选择器逻辑。</p><h3 id="2-2-门级功耗优化"><a href="#2-2-门级功耗优化" class="headerlink" title="2.2 门级功耗优化"></a>2.2 门级功耗优化</h3><p>除了门控时钟优化，也可以通过优化门级逻辑，降低功耗。</p><img src="/2024/030235044/image-20240303162241287.png" alt style="zoom:50%;"><p>上图与门的输出就有较高的活动性，通过降低与门输出线上的负载电容，可以降低功耗。因此，将后级或非门拆分为或门和非门，减小与门输出的负载。</p><p>下图4输入的与门，不同的输入引脚有不同的输入功率。对于活动性高的信号可以接入输入功率低的引脚，活动性低的信号可以接入输入功率高的引脚，避免输入功率大和开关活动性高同时出现，进而降低功耗。</p><p>通过修改管子的尺寸，改变驱动能力，可以降低动态功耗。</p><p><strong>门级逻辑优化技术，由工具自动实现，对RTL设计人员是透明的。</strong></p><h3 id="2-3-多电压"><a href="#2-3-多电压" class="headerlink" title="2.3 多电压"></a>2.3 多电压</h3><p>功耗与电压成二次方关系，不同模块采用不同电压。但是需要复杂的电源网络供电，以及信号电平转换器等。</p><img src="/2024/030235044/image-20240303165214237.png" alt style="zoom:50%;"><h3 id="2-4-多阈值电压逻辑"><a href="#2-4-多阈值电压逻辑" class="headerlink" title="2.4 多阈值电压逻辑"></a>2.4 多阈值电压逻辑</h3><p>工艺库中通常提供不同阈值电压相同逻辑的单元，通常是在满足时序的基础上，使用高阈值电压的管子降低功耗。</p><img src="/2024/030235044/image-20240303165856495.png" alt style="zoom:50%;"><h2 id="3-多电压设计"><a href="#3-多电压设计" class="headerlink" title="3 多电压设计"></a>3 多电压设计</h2><p>使用多个独立电压对芯片进行供电，考虑复杂的供电策略：根据不同的负载提供不同的电压，根据模块不同的行为提供不同的电压，RAM在保持状态时提供低电压，在读写时提供高电压，甚至可以考虑 电源门控技术。多电压策略分类如下：</p><ol><li>静态电压调节SVS：不同模块采用不同的电压，一个模块分配一个电压；</li><li>多电压调节MVS：一个模块可以采用不同电压进行切换。</li><li>动态电压和频率调节DVFS：检测负载变化，对电压和频率进行调节。</li><li>自适应电压调节AVS：DVFS的扩展，构造环路，通过反馈自适应调节电压。</li></ol><h3 id="3-1-多电压设计中挑战"><a href="#3-1-多电压设计中挑战" class="headerlink" title="3.1 多电压设计中挑战"></a>3.1 多电压设计中挑战</h3><ol><li>电平转换器：不同电压域的数据信号传输需要level shifter缓冲器，实现从一个电压摆幅到另外一个摆幅。</li><li>静态时序分析：工艺库中的时序分析都是针对单一电压的单元，多个模块在不同电压下运行，工艺库无法提供准确的时序参数表征和分析。</li><li>布局布线：多电压的版图设计需要更复杂和更仔细的布局规划，电源网络会更复杂。</li><li>PCB板级：需要更多的稳压模块提供不同的电压。</li><li>上电和断电顺序：给电顺序可能会影响电路的功能。</li></ol><h3 id="3-2-电压调节的接口-电平移位器"><a href="#3-2-电压调节的接口-电平移位器" class="headerlink" title="3.2 电压调节的接口-电平移位器"></a>3.2 电压调节的接口-电平移位器</h3><p>现在芯片的电压一般都在1v左右，为什么还需要处理从0.9v到1.2v电压域的信号？</p><p>一个根本的原因在于：0.9v的电压驱动1.2v栅极，会导致NMOS和PMOS同时导通，产生动态短路功耗。</p><p>此外，标准单元库的特点是 最好输入是干净、快速、轨到轨的输入范围。否则，会导致信号在一个电压域的驱动单元和另一个电压域的接收单元之间呈现出明显的上升时间和下降时间降低问题，对时序分析带来不好的影响，甚至带来短路电流。</p><h4 id="3-2-1-高电平-低电平-电平转换器"><a href="#3-2-1-高电平-低电平-电平转换器" class="headerlink" title="3.2.1 高电平-低电平 电平转换器"></a>3.2.1 高电平-低电平 电平转换器</h4><p>实现起来比较容易，两个串联的反相器即可，只需要一个电源轨，来自较低或目标电源域的电源轨。并且，仅引入了缓冲器的延迟，对时序分析影响不大。</p><img src="/2024/030235044/image-20240304210034774.png" alt="image-20240304210034774" style="zoom: 33%;"><h4 id="3-2-2-低电平-高电平-电平移位器"><a href="#3-2-2-低电平-高电平-电平移位器" class="headerlink" title="3.2.2 低电平-高电平 电平移位器"></a>3.2.2 低电平-高电平 电平移位器</h4><p>欠驱动信号会降低接收输入端的上升和下降时间，导致更高的短路电流和降低噪声容限。</p><p>对于跨电压域的时钟信号尤为重要，上升和下降时间的任何退化都会导致时钟偏移skew变大。</p><p>一种简单直接的设计方式：采用缓冲和反向形式的低电压用来驱动交叉耦合的PMOS管，最后输出接一级缓冲。如下图所示，共用一个地。这种电平移位器带来的延迟较大。</p><img src="/2024/030235044/image-20240304215419001.png" alt="image-20240304215419001" style="zoom: 40%;"><h4 id="3-2-3-电平转换器的布局"><a href="#3-2-3-电平转换器的布局" class="headerlink" title="3.2.3 电平转换器的布局"></a>3.2.3 电平转换器的布局</h4><p>高电压域到低电压域的数据传输，通常将电平移位器放在低电压域，因为电平移位器只需要低电压轨道，将缓冲器放在高电压域。</p><img src="/2024/030235044/image-20240304222217976.png" alt="image-20240304222217976" style="zoom:40%;"><p>低电压域到高电压域的数据传输，由于输出驱动器需要比输入级更多的电流，所以将电平转换器放在高电压域中。</p><img src="/2024/030235044/image-20240304225632558.png" alt="image-20240304225632558" style="zoom:40%;"><h4 id="3-2-4-自动化插入"><a href="#3-2-4-自动化插入" class="headerlink" title="3.2.4 自动化插入"></a>3.2.4 自动化插入</h4><p>高电平-低电平 电平移位器的插入应该考虑时序问题；不使用电平移位器会导致延迟计算的误差，如果两个域的电压差很大，则该误差不可接受。</p><p>低电平-高电平 电平移位器的插入应该考虑功耗和时序问题。不使用电平移位器会导致高电压域的输入级不会一直关断，产生短路电流。并且影响了输入转换时间，导致延时计算误差。</p><h4 id="3-2-5-电平移位器的建议和缺陷"><a href="#3-2-5-电平移位器的建议和缺陷" class="headerlink" title="3.2.5 电平移位器的建议和缺陷"></a>3.2.5 电平移位器的建议和缺陷</h4><ul><li>建议</li></ul><ol><li>将高-低 电平移位器放在低电压域；低-高 电平移位器放在高电压域；</li><li>低-高 电平移位器 会带来显著的延迟效应，考虑这些延迟是否影响关键模块的时序。</li><li>确保不同电压域直接存在明确的关系。</li></ol><ul><li><p>缺陷</p><p>电平移位器的加入，导致时序分析困难</p></li></ul><h3 id="3-3-在多电压中的时序问题"><a href="#3-3-在多电压中的时序问题" class="headerlink" title="3.3 在多电压中的时序问题"></a>3.3 在多电压中的时序问题</h3><h4 id="3-3-1-静态时序分析"><a href="#3-3-1-静态时序分析" class="headerlink" title="3.3.1 静态时序分析"></a>3.3.1 静态时序分析</h4><p>在静态电压调节中，只需要一个工艺库，对不同电压的时序参数进行了表征，就可以针对不同电压域进行时序分析。目前，这个问题很容易得到解决。</p><img src="/2024/030235044/image-20240304235232681.png" alt="image-20240304235232681" style="zoom:40%;"><p>对于左面的模块，既有0.9v的电压，也有1v的电压，在时序约束时，应该按照哪个电压约束？</p><p>解决办法：为每个电压指定对应的时钟约束，一组用于0.9v，一组用于1.0v；因为这两个电压对应于不同的性能和时钟速度。当同时满足时序要求时，才算是真正的完成时序检查。</p><h3 id="3-4-多电压带来的系统问题"><a href="#3-4-多电压带来的系统问题" class="headerlink" title="3.4 多电压带来的系统问题"></a>3.4 多电压带来的系统问题</h3><p>不同电压的上电问题，在同一时间启动所有的不同电源是不切实际的，某些IP需要特定的上电顺序。</p><p>电源控制器通常由CPU控制，意味着电源控制软件必须与CPU上运行的系统软件集成。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 低功耗圣经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FMCW频率源系统建模</title>
      <link href="/2024/022817065.html"/>
      <url>/2024/022817065.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="2d7b897f7b84b310bd1c0137fc623264d4140e03925875724ddf93a04227a524">4630436162ade97ba2718b7d0c4b3b6351ade09e539dfebeb5402828e29e64b0474ba98726a3f48ffd712f7d028c0f8590bc7f86c7306404b3affc0f0001546dd88f03f4ef2e0711b996ee8d42bbcf79da327a1d501a906dc08f19870f01c80be620a7d2b84f91009ed0ba0f601b70a6829b934c0d2cbe664828ac9267a0907d782961a6129afb3496f582ed17d6735d99981128f3cb5b443074e00cc483026afddf1bba17e4596b20db3b825ff12322d8f1694b391dbcf90fa66dd5bd0be7f746870ff27e14d1aade0107678a3ae431154d1fbdfa28a3bdbf965461f3eb1b0b2f92060cb810c8ae6c604646bcc339af0d4b4d8015710cbe47634b2bede05e7bfdc9544129fe2aa5c50000fd4f876317cd33074477c2fa8711aec9dad80e7d1a5116bbb79bfbe32e3f4a7983f8d7f7e9bdc441583e22cd8b85a7e268bb423c29e207bfe92c2c851480f3ee8c250b730ac0450ab6d6258998584da12d69451ab1acb9b52d20868d634287117c9e9ae82eab37b7efbb06d8af5585c7cdd360170496354aac0edf9eccbd4cb08e48a7d76252052ec09ed5b66c4098a11efe2efb78f770b7d6a03c344e8606196ad60b423c85416b354f1b63a7a8bcd420b863fe2f4df3409233f672ea0c13310c963ee9714964e7b2d21afd437d612411fff304e24bd67e26ace6e9625a5f8fda3afb89163dca08f7d1b94973eceefa79711177d505ed4233e598fad8d5fc5d94a2f506b62dc20bcf34b4a35fddee8b029b26d29ce7eaef4a65ab31ae0b0018d9c38e79fd1b2e2d9306efae05fb53cca250b1766db0a690d2a96dd0b5fc5442da8b4111c022282bea19c33cbee4e73488bc230b04e5262ebd93bd504a9c9bc4a6b22da4cc60f029232cd00c3bc70785ec9b866340e94e39abbac166272ab4d68619de42404bd38559d9d3763dadf0d8fc4e864b413a62dc30f4ce2d284a7ee48738f39e93cd9b6ec500cea02c262f75a2ccc6f6447ef8a52bcf08da3fad7e326c037a222a044da8a57e19d7dc2b0ef79cb02fcf24a3876e4ac916af6bd808d07633fea45e70ca0ce9fff9537753e2dd8a4f01bada9d0bc1a32eaabf11d75d17403e80ba2a36b1200bbafb5fa04795484d3b0a2f73dfcc9d37721d5d1e35213375d74a627519e1be693c17096a8d0db9d036a5938762dd0e56c31b20b8c8eba3fac905d0e4d7c5bc2200e408c953b6fe716ae33086397844cf0e6367f1c997bf1e332bed52ca7d8769299ff6fd2127531c644453cc0335022c45d020719be232114a4b8b72de0dce169e0fb94d7dbf4748cbacc1f9c53d8a3a6763eb15d167291d5210916c8495e28e11a323e7f81b56f8d7cc4421495228956e96259ff6e6675ed8ec5a4c08d3a0c9d59f08b7a30491c1fe30f552c9c3406e5903a5601e6dd240f7838f5a117a178f9e144603e9aebde8b8527b3eafd5e886cefa1ce89ada4ffe47c9326321c5a2101890d826498d46b6679499bd24a2263f71470ab4c11df0a48c93b43dcbb6026934540ac0d0479480adc295d9450b07b66855975a005ff528e366afd98da062688dc6fbd2e724bef1822df0cbbe37be6f21cae3bcb0cbd8733aa27d58f8c6a14053db8e103a9021d766f1e57eed1a3b82fed8bc6133672b52a26e52061af29457fe6ddb036b68e89d09a94840a745875bf1533d4f518623090116d349a82069c591d98337e3b22cdd7beef3016fb1d9a1e1fe18d46df8ccf2445f52022691802d7d51146f0fb8141ff7cda54bc651e2ca3c3f22487969c453b0bccbc03b68d15d44ce5881d3343ecae7fa3aa3b4534bdc7978d2b42547648f0dcf7479e1e257d96de572fadaffd370835225a695aabd112834e8e6c7bab037575552d18a313467eac6701319a1f1b2bf529689eae5c3c2c9243025021fd6b2121ea5ce3b32ba9abe0bcb1e5bc4721b360f7a351b1c5148bdfd4245b662564e46965bcad9a7df0cd4245bf83bc24a659d030623a5e3d0bfa855c0bcb7c7c3475396d71cca59290b11d9be78ea046cdec4f79362af6b095911fee420aec3bcfa7a08cd4ca890a8d48908603fba3f3418717ef99460b8e8e9bc850c93da038ae19b92127e2f91ae3c5cbf22d31677894894b5bfcc2c9cdafaaa14711105eb64b70fd00db408d889a6e5b585930eced4d73f20541edd7620a7039d444928e1139628f741e0f33f655ea287209939865c48bac1bc1c52c213e454bd710df3cd75ca93a90d55f0a51f3bb6c85f6019600c5da64e3c6bdfea20f64384391ebda6a8f2b7d6dfe3286a3951f2ef2022b078fa38ec872e7754acfd4550185270a378bd6a16b1d0179d092de90e953277fa46e5311bb6c18e8c5dad0b2bc4063ac38c56aca006de62504f671c10977ba2ccc95eeca37dbe33e2aa5bcbbc047ec42c0662e90b4667fde7fd61947782d182577cf0edb7e8c0971d3f753ba0192cd5ddb2b812752ad26b2131ba4e2ff1e06a1068942ece55c194a7bf0b2364fd06200774d25fa98ae64d73922a4b8e549d2029b7eaf6f6e7857004b134f8fd00cfb420d3d19b09de437843084fa56d349f90c2b5b1d98bc483bad46fe311c790fb1e201900d5c5745084ba3b591bca3ff7cdda2e88d31c612d61ed28ebf14c64ecbc9d91434a7429f1c657933ffd37a9bb0f8ce562e05ebef69aa5dcdf369c745f28f2508fd080590dd0162046b8b27c3845ad36da27607115239fab27fc20731af4055e85020505baa396e42fae48cf347ea9c0fc254c197e501c18c7dec24c5ec7c1472ee7500fa741f48e9566d7dc8be00b8d138d7c1334861a5060d6632e44c8c4b854fbec6c5c2d369eccfdcf2b891b94dfe7048aac591e204df1edd299116678123ba018d5b658b4f29a54cae35a5cf7b8ae4a783f0300d1ad3845604dc3d5dae17a46821c7472ea7a9e15dcab26a4d2126e7003d4b33ae97a9166eabae25a768a8e7f80b31dcde6030233239dec724d03d5862f9f7a9b26b0bdab621bbd187fccc11571ec983352a30ff8d77e2671549eeca11a478bd48a44f8f245c331dd21229253bd35699a16cb9c582ed479376997292887583355c414527d3ff6d0555b3304d433d72469bb6e40b303627254773dd2437210e75fe434bee328c0d51d532f5ff79db54c4702bd9706ec30435be655301ceb71104b38a3f047b29f1ceb2f30efa2558b1c50fd1771fcf3979980baa8f752500a257a83d68bf911f80beb5d3489356327ef317f7ae9641a6de0cf8375a56d19520855c1b08bfcaf870e290871a93456888286b58fd9c818336feb2a7c3c3e178e5c6d5b286a452d7f3fc2d17ebf3ec03386cf71322f47b0ed3021b1d4454576beff7c2dc156e93bbb98aa8e0aa7589a7451c1460f4f2e85c68dcb7c0e468958899cb1580297c0e0a2cc9f8843e1151fea7b191a48b5dc509b8450d35c982855dd6bf41f91fef8e62518680611f7416317139c93a7b46905c86d9f6c8db6ce45d644392bbb4570a7c5b0b78eaac3c6e2902d4525491ff37495411922637bf1c402224db5169c49a1fbe0a9441d12f4df53b2ceb4a6b21e1881f845880a27a65e911a0ccd9b16883f6f923aaa74e152e50cb8e0ae639cdebd678526c5374e521fc005f0c48b10f4a115bb0e1ec86b893598cf172fd4529e3e3acab57563e0bafe5de1a3c4726ccf3f3c5a92ed3493d386ea197eb9e9f0f4586720f189e49b126894e92bf18f4af1be293da4c9b13602890d87d7d9d90f4e66e5ffdda002269a128dcda51487a940d45a946367863164b08e040e6c0be6a1fb5b3445b7f1da743976956984e8bdf58afbdad0d52fd6164c06afe09b1aa2556b57745b66edb2dd65bc61c21684ab6213d34d47a40ba204875cc22cd535229351dbbe4e9ddce33b159d94dd2b79fde50405692a00665877e35e15c123755c4acfcd9e4b5e9e6ba3345d87f3a95eca86f1fa0055256d1b509f1705a80a6ca65a36eec2002ad2668740bf409fd3e3f9b12488d5f04072d3bcbdb1d0e4f19f6b5ec29ba7332d1f96518d87b1e783e73f238bc03640054870e30fc82d7636d47722b57f154cd83e8a6d4393ff44b82ef2e8360f5342c07efbfe93914a4e6ec0fd0bfadb265273f0d7a8ec82baf97d2fbce3012b5156c76c6e6d3ee9c86f9088f36ee6cd9b463c115cb4b747afe187692575e7cdd4a3864c27fe6b7daeeb250d15aa3e79838968a12b302e2e6e678a7359d8d22828b4f73a95027ca787e9a6e6baba69e9b50cdd00a2584bd5c958d5cd7f24e6d411855f169d9f023e69c0b063b5e3c467caa99fe27e8366e70557ed996355a2549f15a00a54fd5ed064ed8ea5606eec86134dc267e5be96a6a276d1c1d0f80db1ea928dbcc6e23658c30d498b835f4d44cf047d9de6dd10a3570f9623a6f6a9d8d092c9111c030f755c383dea6378041982892f03a0ab9591b240328772e77dc3facb4ab91446e19d158ece05f5a73d4fcd86e711fd938ac1fd57a346d0860a38d933b02765de87fab88d5ab20697bd483278cfd83eaa18d9f20f4e262198ae6a5774c1781de08ff62916114d61ca6da75cc43e5fda58c339758816f56c0b3f9723717cec261ab3e8abf801f231a5001e0b13e112b7cfb46a6f0757975de4dd4536ad5efafc9d8968b5728d0c9144b7c73d291f9a0054ac60487aaa0cb24bc1a7e0cc7321081787fb4f210f6ba02763fc5b0568856714c114d90b50db6f051d3bf1a9b121f0cbd85a1184b0ba887fccaa2843e9f9d62d267e11107804dcfdc99ee170c1b4a4105f1f07c0e80e1c70806ac36b132f4d50869a2f32543d6f8c9d2f945bb5f6e7042f33d7f6db99a75b47bde5ad25b50bd54473165a0fbe782b286e9c872efb39dff81ab31fe7067c22124e2cef6a5a77601a3894c68881fb111de8a7c92917d7ceea042ad2f444bf9ae620cc61d5f912b1bbc4b12f2748732cb1af1a947bc7032ae05c8ae25773faa08838e8c7013c18d2cd421c12f21cdc5d8644ee453fc4dd1b53fe1ecf289d95f75878ffba50752432e8cff69321b5603806636a72e5353a98a620cfc649074d3ad21e1d9a8684abdca0040a6f582bb87a4a978b6e736ac0be5d103820d25ed88602bb32d2785e3aa2f619ace99dac4e0a658045d13f5a1bc9b7ca17c19ff434a6d04ee9f51eff686019052171a66fbb6f25f04146f0fcfa78a0c32c88d01a90aa16325b723c8a727ea23aacb5c9c12e4b81b67aabcf0cc40a127922dc2a6fe06dd5996206d77c70433baa2651d12ab929cadeed5aa35c85da21069f5f2d506f7a1eefe663dabfa916e83e4e3992eca6f87a1dd15fbc6e0085856b4b8186b02f27dfa166c632bdd6d0232d950a7a7d7b1e974eea35c2c9ca29505fe29eebf5d61507d4892013eea45b1914374cedaa9b95fc8d783393827cd074c0053398bb6ffefd749e1b13bba23f570197154e8277566495e751649366360baa604ded9291c7d15fd001a9fb9b4b3b98a90e1f41734d7a3463b318e58343c4e5d129d0c54cc70c5bdb82905c24282903fa34881e226939f9ed3f2c713e028d2d3977271d6ffb5a726c42526a2ed745101d5d746249fc28d23e201c7b402f91b92511fc03f9643345f4823c5a33f0542583e4c911e73357d790c22dd0aa97be9868975379163a739a23bc62e3bfdda6ae5fadc73ecb47e7747f55569742bdd9869f73f9ffb4893a21f26f11667c99f7140db732d249d700f86aa5cde5cefd7d6aeda49420c1d44d912574d5e7bce51e7bfadcc49b550d1af27057c38fde79373bf4595b110d1c17d7aff90f8b66b4ef30fb5dbccb6ce22e0f72c56e0d84af7c5d8adfb4cec956df19a63cdcbd661bdbc397f48589e1a8512f277a71d8cca0c5978cad7c19a666a9b7f26ad236156c10962c26dd77d45b4185993760a4454ee994edf1169765121f377a00ce24b0e71379742c861e6eb1fb72f4e752fbf6cc942e558ff707aaaf4275dec0d69828667dfb6c2ed39244be97b80cef49a7263c0c1b749b5439643c8d366e6e326855d5fe610b78c5d1a9eeaf4d6b78e2f4e87da332e2a60d0dabeb2232f49a3009c163b6466842eca30802a5be5d28cdb8b7cf6cd1cd64c9175d0e1e37c64d65727b1b57b3d9aed80b38a89546bf3cc78dcf74736448a2b90456e443eee2a2847284feca42ede150d21f829ed6761bf632b2cdf46c2a0e9ea850cf200eed94ea5280ab30f2d697c5cc83cd5d52dbca458a6d726db3c82af4808f8d1465d9123ccb971f60c2d04dd97954a502392285d93899a34203edc4f2c2dc7b81d10479ba1d3b0243c80abcf3a8ce352a94b655795b52071db855b48d9a41688b1d4b9f74dc1bedffa9abfb24fdb79397e99fc551c2e916d5361e2d6e04dbb2264fb3a09b107e97f0679bfc2ed48cfdfcbdedf7167037df793c7cb4ab98790052967b23b93965a7ca2f6d688c2e8d49a7862d794ecef87ffc2208afca1a48008e3b8fae01e6f79b5ba0458e706fd889ae75f1916299e5f109514c0f74307f46d9ddf1ba81f0bb62f0e57f81728698d3de2f8974547b43d2bf98b1718afa02cf993949df5038b05eb618f88520ffeb8c46aff8e891f5c644e9021c87c5de440da2f162a6505d5fbac4ef2d26b7cfccb83ff75907a335dae5278ff5e6f5e92874934535b7457ff0f22ca7e31cd7c042a6ff04c08b73c9f036848bae03398f5f69793c2452b9871648961770e27c7211752a9dd908dfa70ee997f4f65225628a0a5fc2219e647ce3727ce322204be9a29eb427c5f0b2df73337ad6c3c497a0c4e5550041eb468c12842c41033e397e4f93773e31e8c71c6a8c7b0af61b1c36c2dbfeba23ae480c1c551b97e9bfc03562648087600214df9dc8e0446a2e79643977320bd775ad73c85cb763195757ba89987ee2a5a802596326569bb0338679e4f305a9c63c4ca066f6c2a2e000b89eaa86f121cb81c34eecaff917275461aee8d2c8fddcc327e73b260b829e75a9cdf555045c5b82f1ad3477a625fde6a75fa07baeb4daf9225a94ae724e906693ce50b5701d503b44e88ae36c0472e091210bec60a670b5d27887f921d29a78ef93906111ea8e2a6dbbad610fef61f491c1fa753eb303a7efda106b4c8d63f5408feec5e6886c2aa593dfc3576ce42f4282b668745474fa3d5a43cb7b58f0cf83fc4aac11f6cd2c28f3d454603d889478a1bbff762aa1476727bbb0bf994f017f78108ff659d00f0ed9464406416477b5feff932741fe319e9091c9225e7d666f0367a02966b2fa0696d4ecf8ba45e30120e33f5b0d024035ceb6e7f5d8041488d4ac21f6751e29d82a0445c5f29691fbc5426d6f342726e315f9cf0c8de2ded0a1f52ff6010d6ead36f85d9e7caee6497998c56acb3029047ee9e7c77cb1fd380a7b2891a9b9304638784dbafbdfaac681799f630676adb0f2c2f5c592981eaecee305d3e638e08f487e98f574caa76f72d1568bdb727e2f34815360e638a6427917b26ee7e42da3d34afab1f30afcbdc59c1f055d6297009f21ff63b70bdafc394c3bf902993c88b79d870b53390e5573ad89239b81072aa1abf5cac8ffcd404446bf1b0e35d8c705fba7db1394ce23adea92c6f5122da6018ac26b6e6d8f2e67552e546ae2a31de8c91ae2a1563651c8abb7fbef21f6012a010c6b3d3e0884de1d48316a8b63b3d01a2d184003741740a9d5f475e1126f5b90227bcc546d2b9dcf4883ac83fe9d7f553b668308ccd51a46443034e3e7977d90735c5a466c9b6547502b22d6a177888cc074a7af39d071f65fa9aef3f9d07010dbbadb8c0dd635cc721c4974ba0be2e0f549bb090dfd839146975824e011bda912e699cac577a4d11b503da3ada107202b2b9afcdfa95c43270b977654985235474c3aa61f762747a6cf9a628251dd69a4a6351fe64dbe623068be4f2d715e14d8b621030686e29462f78c47916104e24b38a65a7bda1787843061d7e919c68028ddb1b96e6c70b6a691c923eba92cad7614691412bde2053baf20fec6fe2bb7df0c435a1874154a8678c86ced790b65783d8a4423f6dbd2cb9b41fe10a38b7497dc1b9664d2687cd2f5e699283e6e5b01cc52ec35a4d8e39be1d018167407c42bbf1a77718f9f41c446fd79a8891d584afb932ede318455ea30c43904f7b4e391e2bcb13fa572a8649524f29ff486ca0dfb855cf74d05789bedf4d6c10a36f93beb5bbeacfdf69fcef857c97b3ae96892baa665ddb945081325790c669f001cd3b0f83500573c2bc56f598fc7de7cd02a455ca607789a4c7cda3a957a7f7546de2bf8f83cf5cee334f23b80446ab5b226154be7981cf10e0fd0bb7749de42f6eb90940d4844773686a9bd1b5f149dbc4e0759d87de0487b4735914f616dba62d3deb1d0031bd7cb662b62286de16bbe5d26de3bdbc91816cefdd2bb0dbb3d04deb235f1be339ce5c3769c21013dc0a561032b929060997149222ab4f0ca7a089a495d4d732dfa9660fb4cca11d44f250fe7b2a2ed</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 课题组项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FMCW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FMCW</title>
      <link href="/2024/022837365.html"/>
      <url>/2024/022837365.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="bcc886015d867e685b6559a1a44adb96ac29f5a8c6a876082b4e78820267315c">10d79030e8222445804370796b90fca106f15dd47c03b7cc3ac7fb0590359f37ccd6ce25dabd9e485ae27a888d7ca1365faa8a02c4def6f2b680714dbfda3152f3e1c340acfd9ff0ccfb8758f48d76fc9b1d64545e4a4abbbe4e54f9a5bc525eb3873879f528981e5cf4dc75af378932210948467a541081f9fe77ad477811a3f1bd4da116b2ebc0184d867743e2d6547a787c27042c570fc5383eb78929b1d4a7d00c7253cf993abc4ea298ad840ae58ecdc6e9b11ff1038c0442badd946644538ca9882ae6ae86523929deb5acc2fbfe4b27919a28501eaa7ac9a9eb86e7a093e710c4a4aa0a2d29d2ecdf38ece2e29b1f62f1f0be16b6777521431f0a86398e38112c884626a2d54841b54856c0cdf0a0b17a33e0368c8c01c5c655e778bb6750ba0d1021a519867fcee72dd3ab0cd37a5f4f7698655764508f14e4753e290e4b98b6435e84a4e221b9c2bc55e078586965c73d478583e60e1005f0f932d0520ab4fc97597faf900e45dd35eb9dad57b36b93b200baadf06e32e06fff981451c60bab187a114a9b69e0d3d9bdae2260fb22b76a4f7e449ec5d66e3de863a73e35b9373995ea3ab27f9ad1106c83409fdaca90bf984aff8d1dbce64c1abfa669ce682a5c5eb865101716ebc98a5f54dabacb2898b8e85cb05a37227a186cd46d6dc08ec9577edcc8b94a3f4f2ce411ac9fb1e74fcc6d3ead1a50b8d0fef91147ef92ec7a658fe7ce2cab39a1eb9847cc43dd76bbe5984c51de5e445b53398573196217409add999afb0f10602845ffcd9854f4ef57108f05a140d4906dfb3e1d41b9a678421951dc93f4f7e0de5f24aff55f31e65f967b71c26f432bb60058b61cf88f3cb315e877c036031a2511ed04e6c4a39b075918abf76742d820024f35ee5a7a6e27f8c9adb853da1faa2e27da2a703a23ae76b617625341c8a3898c5d7249036804bc8cc94994e9cee71d7496153c43e4bb4f57dd461e3fae30bea5c2d3fc7f15240a358f313ff1aca8ef151df3dc3487b28987157972c89b8b8023449028b26881321891d94cb0e5a506ac2a0e37fd986f099ded74b920c78a4f98691b6ea1c5913f4f5b8def831b699a6188601e4b138cf02cbe1f2016e5746c47fa6c73c4ea8530122aa5865eea1886098d5c880f04eb234bfc6518e810dd90ea92e303b1f7d98d1793405089bce16f9e761ba09c5d07dc6504cef4ddb14aed99365faaa61ce1b3c716759740c8e61551cd9597b5aaed29baeba25bed32f1e8be6406aa9f3df69f1118a55f44b51aa9ad9eb0279f58fa4e6fd7962133b37ff133f220ab4210d640b4473ae678c4c376cd3c28a7be4c2ce1f4a6b4943fb75a539f951dd9d23aa3b054b2315bf0cb5a8696ca4c7670bee4e17d315732b57e67863ec6b3a017bc82465d1f2c7972c06a0c2d27c8f808262f01cf9d6f318aab3ec13ce48b7be2fc44643f6c43b2d452c23880d427224d4bfc61722b1e13a2c6cdeca20678dcc3e01e3fb8eeacca2e37c70fa5db0f6c309ccbddfc727b42e5bf51bcdecf6086ffbd86775f9c583ab53d127274d8f05ab56df31b6d1976a98d394280c4b4740e460a295e491c851379e08f984c66f7c76ea38cfa72e3d563707383c4427d1daea64268be9f880440b1e782b135b291cd4fb0ac3b89bd0feb61924fb92d550da3341269e8193072ce1f4f75e8fb0270e3ea698df492edcecf9290700fbb691dfe00af9ee1b04a2634990cfe1d3c1f5e8cf48e2f92ed379efbe8b91fd36227ddbbdac767530a4bbea9aebcce2f753eb6438331523d5a3ddb4b0ea650edecc65ffe6c1c7024c3ad729e98364b6d802b65a8555fa4a967b4d42a3dfe778e1317b353f4778e8d15bf93c0cd00c196030fe0a9af468592c8b34db2d3eb9594cc0f41961e70d61ac96488adef66d18fa51bbaf4b0a2140677d88a6b704fb9add9e6a53983741da4b940087adf3c6b12c89e5fc922ad4469c38c5b8759176f56467b9b65dbe0a4e5abb51f9a76146830e29eb13c80930db10b9653c5c1a64163b7f804e4c4206cd9e1b2b6d32618bd65fcf56eab37957ffe3c9de383541040af43c001adf9160ccc18b053b5d7fae8a5e2bc3f4ef7fa8ab6ac75a839d8c1b88c1599689168a0cf05462af9d81467395ac0635195508abc36889bd1306a69ba95898710ad9b0593d23ff643ebe4efdfc646cf8b42b33aabf42d59a1cb88a1150065571967ac858488c7461cfc41d77a328d71d7e32e342d52db78e9d65812d41447ac2c032fdf55c8339c4d8dc7d8e530ceb93fe1712cbaef00a8239c53ed91a2adbbbd7e97a00a26c7ff415a4e1c508f68f877296ac1ed7068112e134a2231c185</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 课题组项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FMCW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-异常处理设计</title>
      <link href="/2024/022651980.html"/>
      <url>/2024/022651980.html</url>
      
        <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="ecall自陷指令"><a href="#ecall自陷指令" class="headerlink" title="ecall自陷指令"></a>ecall自陷指令</h3><p>发生异常ecall时，处理器需要完成的操作：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">PC <span class="token operator">=></span> csr<span class="token punctuation">[</span>mepc<span class="token punctuation">]</span>causeid <span class="token operator">=></span> mcausecsr<span class="token punctuation">[</span>mtvec<span class="token punctuation">]</span> <span class="token operator">=></span> PC<span class="token comment">// 在WB阶段，硬件自动完成</span><span class="token comment">// 将当前PC写入mepc</span><span class="token comment">// 跳转到mtvec继续执行指令</span><span class="token comment">// 将id号保存在mcause</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mret指令"><a href="#mret指令" class="headerlink" title="mret指令"></a>mret指令</h3><p>将mepc给PC，跳转到发生异常处，改变程序执行顺序。在WB阶段执行；</p><p><strong>在WB阶段执行mret和ecall指令时，都更改了pc的值，需要对流水线前四级的寄存器进行冲刷reflush</strong></p><p><img src="/2024/022651980/image-20240227164253113.png"></p><h3 id="csr相关指令"><a href="#csr相关指令" class="headerlink" title="csr相关指令"></a>csr相关指令</h3><p><strong>csrrw，csrrwi，csrrs，csrrsi，csrrc，csrrci；</strong></p><img src="/2024/022651980/image-20240227152225346.png" alt style="zoom:50%;"><img src="/2024/022651980/image-20240227152627604.png" alt style="zoom:50%;"><img src="/2024/022651980/image-20240227152651142.png" alt style="zoom:50%;"><img src="/2024/022651980/image-20240227152745330.png" alt style="zoom:50%;"><ul><li><p><strong>csrrw rd csr, rs1</strong>，<strong>csrrwi rd, csr, uimm[4:0]</strong><br>ID译码阶段，读取寄存器堆CSR[csr]，regfiles[rs1];<br>WB写回阶段，将读取的结果保存在寄存器堆中，CSR[csr] &#x3D;&gt; X[rd]，X[rs1] &#x3D;&gt; CSR[csr];<br><strong>如果rd&#x3D;0，不会向regfiles写入数据</strong></p></li><li><p><strong>csrrs rd, csr, rs1   csrrsi rd, csr, zimm[4:0]</strong><br>ID译码阶段，读取寄存器堆CSR[csr]，regfiles[rs1];<br>​EXE执行阶段， X[rs1] &#x2F; zimm | CSR[csr] &#x3D;&gt; exe_o;<br>​WB写回阶段，CSR[csr] &#x3D;&gt; X[rd]，exe_o  &#x3D;&gt; CSR[csr];</p></li><li><p><strong>csrrc rd, csr, rs1   csrrci rd, csr, zimm[4:0]</strong><br>  ID译码阶段，读取寄存器堆CSR[csr]，regfiles[rs1];<br>  EXE执行阶段， ~(X[rs1] &#x2F; zimm) &amp; CSR[csr] &#x3D;&gt; exe_o;<br>  WB写回阶段，CSR[csr] &#x3D;&gt; X[rd]，exe_o  &#x3D;&gt; CSR[csr];</p></li></ul><h3 id="数据通路和控制信号设计"><a href="#数据通路和控制信号设计" class="headerlink" title="数据通路和控制信号设计"></a>数据通路和控制信号设计</h3><p>​根据上文描述，设计数据通路。ID阶段csr1_o和csr2_o的选择如下所示</p><img src="/2024/022651980/image-20240227163318097.png" alt style="zoom: 50%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>csr1_sel <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span><span class="token function">if</span><span class="token punctuation">(</span>i_type <span class="token operator">&amp;</span> <span class="token punctuation">(</span>opcode <span class="token operator">==</span> <span class="token number">7'b1110011</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token function">case</span><span class="token punctuation">(</span>fun3<span class="token punctuation">)</span><span class="token number">3'b010</span><span class="token punctuation">:</span>csr1_sel <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span> <span class="token comment">// csrrs</span><span class="token number">3'b110</span><span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b01</span><span class="token punctuation">;</span> <span class="token comment">// csrrsi</span><span class="token number">3'b011</span><span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b11</span><span class="token punctuation">;</span> <span class="token comment">// csrrc</span><span class="token number">3'b111</span><span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b10</span><span class="token punctuation">;</span> <span class="token comment">// csrrci</span><span class="token number">3'b001</span><span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span> <span class="token comment">// csrrw</span><span class="token number">3'b101</span><span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span> <span class="token comment">// csrrwi</span><span class="token keyword">default</span> <span class="token punctuation">:</span> csr1_sel <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span><span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">if</span><span class="token punctuation">(</span>i_type <span class="token operator">&amp;</span> <span class="token punctuation">(</span>opcode <span class="token operator">==</span> <span class="token number">7'b1110011</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token function">case</span><span class="token punctuation">(</span>fun3<span class="token punctuation">)</span><span class="token number">3'b010</span><span class="token punctuation">:</span>csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// csrrs</span><span class="token number">3'b110</span><span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// csrrsi</span><span class="token number">3'b011</span><span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// csrrc</span><span class="token number">3'b111</span><span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// csrrci</span><span class="token number">3'b001</span><span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// csrrw</span><span class="token number">3'b101</span><span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// csrrwi</span><span class="token keyword">default</span> <span class="token punctuation">:</span> csr2_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕代码</title>
      <link href="/2024/022637133.html"/>
      <url>/2024/022637133.html</url>
      
        <content type="html"><![CDATA[<h2 id="毛刺过滤电路"><a href="#毛刺过滤电路" class="headerlink" title="毛刺过滤电路"></a>毛刺过滤电路</h2><h3 id="同时过滤正毛刺和负毛刺"><a href="#同时过滤正毛刺和负毛刺" class="headerlink" title="同时过滤正毛刺和负毛刺"></a>同时过滤正毛刺和负毛刺</h3><p>用verilog设计一个功能模块，将不足两个时钟周期长度的毛刺过滤掉，时序图如下所示：</p><p>输入信号：clk，rst_n，Din</p><p>输出信号：Dout</p><p><img src="/2024/022637133/v2-92bfd62c33dd99594745ac2becfc5206_720w.webp" alt="img"></p><p>思路：如果两个周期输入信号保持不变，则输出。否则，保持不变；</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">filter</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       <span class="token number">17</span>clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>       din<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span>  dout <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">reg</span> din_r<span class="token punctuation">;</span> <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        din_r  <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        din_r  <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         dout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>din <span class="token operator">==</span> din_r<span class="token punctuation">)</span>        dout <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="仅过滤单向毛刺"><a href="#仅过滤单向毛刺" class="headerlink" title="仅过滤单向毛刺"></a>仅过滤单向毛刺</h3><ul><li><p>过滤负毛刺</p><p>过滤一个周期的负毛刺，当负电平持续两个周期，才可以输出低电平；</p><p>采用两拍的寄存器，两级输出做 “<strong>或</strong>”操作；</p></li><li><p>过滤正毛刺</p><p>过滤一个周期的正毛刺，当正电平持续两个周期，才可以输出正电平；</p><p>采用两拍的寄存器，两级输出做 “<strong>与</strong>”操作；</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">filter_pos</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>       din<span class="token punctuation">,</span>    <span class="token keyword">output</span>      dout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        din_r <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        din_r <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> dout <span class="token operator">=</span> din <span class="token operator">&amp;</span> din_r<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="消抖动电路"><a href="#消抖动电路" class="headerlink" title="消抖动电路"></a>消抖动电路</h2><p>题目：用verilog实现按键抖动消除电路，抖动小于15ms，输入时钟12MHz。</p><p>思路：添加计数器，如果15ms数据没有变化，将输入放在输出。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> de_jitter <span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>       din<span class="token punctuation">,</span>        <span class="token keyword">output</span>      dout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">localparam</span> jitter_factor <span class="token operator">=</span> <span class="token number">180000</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span><span class="token keyword">reg</span> din_r<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        din_r <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         din_r <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         flag <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>din_r <span class="token operator">==</span> din<span class="token punctuation">)</span>        flag <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         flag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         dout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> jitter_factor <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        dout <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="串并、并串转换"><a href="#串并、并串转换" class="headerlink" title="串并、并串转换"></a>串并、并串转换</h2><h3 id="串转并"><a href="#串转并" class="headerlink" title="串转并"></a>串转并</h3><p>​    用一个计数器count，每输入8个数，就输出一次，每周期dout_temp左移一位，然后再将输入的1bit串行据存入dout_temp的最低位。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Serial_Parallel</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>            clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>            nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>            data_in<span class="token punctuation">,</span>    <span class="token keyword">input</span>            data_valid<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_out<span class="token punctuation">,</span>    <span class="token keyword">output</span>           data_out_valid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_reg<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>data_valid<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span>            cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        data_reg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>data_valid<span class="token punctuation">)</span>        data_reg <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span>data_reg<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data_in<span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        data_valid <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        data_out <span class="token operator">&lt;=</span> data_reg<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        data_valid <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        data_out <span class="token operator">&lt;=</span> data_reg<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="并转串"><a href="#并转串" class="headerlink" title="并转串"></a>并转串</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Parallel_Serial</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>           clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>           nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>     data_in<span class="token punctuation">,</span>    <span class="token keyword">input</span>           data_in_valid<span class="token punctuation">,</span>    <span class="token keyword">output</span>          data_out_valid<span class="token punctuation">,</span>     <span class="token keyword">output</span>          data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in_reg<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         data_in_reg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>data_in_valid<span class="token punctuation">)</span>         data_in_reg <span class="token operator">&lt;=</span> data_in<span class="token punctuation">;</span>    <span class="token keyword">else</span>         data_in_reg <span class="token operator">&lt;=</span> data_in_reg <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>data_in_valid<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> data_out_valid <span class="token operator">=</span> <span class="token punctuation">(</span>cnt <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> data_out <span class="token operator">=</span> data_in_reg<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据位宽转换"><a href="#数据位宽转换" class="headerlink" title="数据位宽转换"></a>数据位宽转换</h2><h3 id="宽到窄传输"><a href="#宽到窄传输" class="headerlink" title="宽到窄传输"></a>宽到窄传输</h3><p>​    假设数据从模块A传入到模块B，模块A的<strong>输出数据为32位</strong>，模块B的<strong>输入数据位宽为16位</strong>，那么如何能把数据从A传入B<strong>而不损失数据</strong>呢。</p><p>思路：<strong>通过时钟分频和倍频</strong></p><p>宽数据是慢时钟，窄数据是快时钟；</p><p>Input：快时钟+宽数据</p><p>Output：窄数据（快时钟输出）</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Wide_Narror</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>           clk_2x<span class="token punctuation">,</span>    <span class="token keyword">input</span>           nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>    data_in<span class="token punctuation">,</span>        <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> clk_1x<span class="token punctuation">;</span><span class="token keyword">reg</span> flag<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_2x <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_1x <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_1x <span class="token operator">&lt;=</span> <span class="token operator">~</span>clk_1x<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_1x <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        data_in_reg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         data_in_reg <span class="token operator">&lt;=</span> data_in<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> data_out <span class="token operator">=</span> clk_1x <span class="token operator">?</span> data_in_reg<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> data_in_reg<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="窄到宽传输"><a href="#窄到宽传输" class="headerlink" title="窄到宽传输"></a>窄到宽传输</h3><p>宽数据是慢时钟，窄数据是快时钟；</p><p>Input：快时钟 + 窄数据</p><p>Output：宽数据（慢时钟输出）</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Narror_Wide</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>           clk_2x<span class="token punctuation">,</span>    <span class="token keyword">input</span>           nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>    data_in<span class="token punctuation">,</span>        <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> clk_1x<span class="token punctuation">;</span><span class="token keyword">reg</span> flag<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_2x <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_1x <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_1x <span class="token operator">&lt;=</span> <span class="token operator">~</span>clk_1x<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_1x <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        data_in_reg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         data_in_reg <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span>data_in_reg<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data_in<span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> data_out <span class="token operator">=</span> clk_1x <span class="token operator">?</span> data_in_reg <span class="token punctuation">:</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="握手解决流水线断流、反压问题"><a href="#握手解决流水线断流、反压问题" class="headerlink" title="握手解决流水线断流、反压问题"></a>握手解决流水线断流、反压问题</h2><p>通过三级流水线实现以下组合逻辑的计算；包含握手和反压的处理。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y <span class="token operator">=</span> <span class="token punctuation">(</span>c1<span class="token operator">+</span>c2<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>c3<span class="token operator">+</span>c4<span class="token punctuation">)</span> <span class="token operator">+</span> a2<span class="token operator">*</span>b2 <span class="token operator">+</span> a3<span class="token operator">*</span>b3 <span class="token operator">+</span> a4<span class="token operator">*</span>b4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>思路：第一级流水完成 (c1+c2)，(c3+c4)的计算<br>        第二级流水完成乘法运算<br>        第三级流水加法运算</p><p>每一级的上下游都要有握手和反压信号的处理；</p><p><img src="/2024/022637133/image-20240228153148536.png" alt="image-20240228153148536"></p><ul><li><p><strong>ready信号的处理</strong></p><p><strong>以ready_r1为例，当r1寄存器为空（valid_r1&#x3D;&#x3D;0）或者ready_2为1时，r1都有能力接收数据；</strong><br>如果ready_r2为1，valid_r1也为1，则将该结果保存在r2寄存器中；下一个周期r1可以接收新数据；<br>如果ready_r2为0，valid_r1为1，下级无法握手成功传输，所以r1无法接收新数据；</p></li><li><p><strong>valid信号的处理</strong></p><p><strong>对于r1来说，valid_r1可以作为握手的结果信号；当valid_i和ready_r1握手成功后，r1输出valid_r1为1和有效的data_a。</strong></p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">handshake_pipline</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span>       valid_i<span class="token punctuation">,</span>           <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c1<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c2<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c3<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c4<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a2<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b2<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a3<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b3<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a4<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b4    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> result<span class="token punctuation">,</span>    <span class="token keyword">output</span>      valid_o<span class="token punctuation">,</span>    <span class="token keyword">input</span>       ready_i<span class="token punctuation">,</span>    <span class="token keyword">output</span>      ready_o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a1_r<span class="token punctuation">,</span> b1_r<span class="token punctuation">;</span><span class="token keyword">wire</span> ready_r1<span class="token punctuation">,</span> ready_r2<span class="token punctuation">,</span> ready_r3<span class="token punctuation">;</span><span class="token comment">// first stage</span><span class="token keyword">assign</span> ready_r1 <span class="token operator">=</span> ready_r2 <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_r1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        valid_r1 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ready_r1<span class="token punctuation">)</span>        valid_r1 <span class="token operator">&lt;=</span> valid_i<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>valid_i <span class="token operator">&amp;</span> ready_r1<span class="token punctuation">)</span> <span class="token keyword">begin</span>        a1_r <span class="token operator">&lt;=</span> c1 <span class="token operator">+</span> c2<span class="token punctuation">;</span>        b1_r <span class="token operator">&lt;=</span> c3 <span class="token operator">+</span> c4<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a2_r<span class="token punctuation">,</span> b2_r<span class="token punctuation">,</span> a3_r<span class="token punctuation">,</span> b3_r<span class="token punctuation">,</span> a4_r<span class="token punctuation">,</span> b4_r<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>valid_i <span class="token operator">&amp;</span> ready_r1<span class="token punctuation">)</span> <span class="token keyword">begin</span>        a2_r <span class="token operator">&lt;=</span> a2<span class="token punctuation">;</span>        b2_r <span class="token operator">&lt;=</span> b2<span class="token punctuation">;</span>        a3_r <span class="token operator">&lt;=</span> a3<span class="token punctuation">;</span>        b3_r <span class="token operator">&lt;=</span> b3<span class="token punctuation">;</span>        a4_r <span class="token operator">&lt;=</span> a4<span class="token punctuation">;</span>        b4_r <span class="token operator">&lt;=</span> b4<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// second stage</span><span class="token keyword">assign</span> ready_r2 <span class="token operator">=</span> ready_r3 <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_r2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        valid_r2 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ready_r2<span class="token punctuation">)</span>        valid_r2 <span class="token operator">&lt;=</span> valid_r1<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> mul_1<span class="token punctuation">,</span> mul_2<span class="token punctuation">,</span> mul_3<span class="token punctuation">,</span> mul_4<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>valid_r1 <span class="token operator">&amp;</span> ready_r2<span class="token punctuation">)</span> <span class="token keyword">begin</span>         mul_1 <span class="token operator">&lt;=</span> a1_r <span class="token operator">*</span> b1_r<span class="token punctuation">;</span>        mul_2 <span class="token operator">&lt;=</span> a2_r <span class="token operator">*</span> b2_r<span class="token punctuation">;</span>        mul_3 <span class="token operator">&lt;=</span> a3_r <span class="token operator">*</span> b3_r<span class="token punctuation">;</span>         mul_4 <span class="token operator">&lt;=</span> a4_r <span class="token operator">*</span> b4_r<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// third stage</span><span class="token keyword">assign</span> ready_r3 <span class="token operator">=</span> ready_i <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid_r3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        valid_r3 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ready_r3<span class="token punctuation">)</span>        valid_r3 <span class="token operator">&lt;=</span> valid_r2<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>valid_r2 <span class="token operator">&amp;</span> ready_r3<span class="token punctuation">)</span> <span class="token keyword">begin</span>        result <span class="token operator">&lt;=</span> mul_1 <span class="token operator">+</span> mul_2 <span class="token operator">+</span> mul_3 <span class="token operator">+</span>mul_4<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">assign</span> valid_o <span class="token operator">=</span> valid_r3<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速计算one-hot码中“1”所对应的下标"><a href="#快速计算one-hot码中“1”所对应的下标" class="headerlink" title="快速计算one-hot码中“1”所对应的下标"></a>快速计算one-hot码中“1”所对应的下标</h2><p>题目：找一个多bit信号最高位的1或最低位的1所对应的下标</p><p>思路：根据独热码和对应坐标的真值表，写出逻辑表达式；</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">One_Hot_position</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span>    <span class="token keyword">output</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> position<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> data_in<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> position<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> data_in<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> position<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> data_in<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//    one_hotindex</span><span class="token comment">// 8'b0000_00013'b000</span><span class="token comment">// 8'b0000_00103'b001</span><span class="token comment">// 8'b0000_01003'b010</span><span class="token comment">// 8'b0000_10003'b011</span><span class="token comment">// 8'b0001_00003'b100</span><span class="token comment">// 8'b0010_00003'b101</span><span class="token comment">// 8'b0100_00003'b110</span><span class="token comment">// 8'b1000_00003'b111</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="找到序列第一个1和最后一个1"><a href="#找到序列第一个1和最后一个1" class="headerlink" title="找到序列第一个1和最后一个1"></a>找到序列第一个1和最后一个1</h2><p>思路：找出多bit数据中第一个1和最后一个1的位置，将其转换成独热码，根据独热码得到位置；</p><p>通过”按位”操作</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// MAX</span>pre<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pre<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>pre<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">~</span>pre <span class="token operator">&amp;</span> data_in <span class="token operator">=></span> One_Hot<span class="token comment">// MIN</span><span class="token comment">// 利用补码的特性，原码和补码”与“操作后，得到独热码，1的位置为原码最低位为1的位置</span>data_in <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>data_in <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=></span> One_Hot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Find_Max_1</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span>    <span class="token keyword">output</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pre<span class="token punctuation">;</span><span class="token keyword">assign</span> pre<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> pre<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">|</span> data_in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">assign</span> data_out <span class="token operator">=</span> <span class="token operator">~</span>pre <span class="token operator">&amp;</span> data_in<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Find_Min_1</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span>    <span class="token keyword">output</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> data_out <span class="token operator">=</span> data_in <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>data_in <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="跨时钟域传输"><a href="#跨时钟域传输" class="headerlink" title="跨时钟域传输"></a>跨时钟域传输</h2><p>已知data a为a时钟域0-15范围内的顺序数，现需要将它的值传递至b时钟域(设b的时钟频率高于a)，请便用verilog设计合适的跨时钟域处理逻辑、模块端口定义如下:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">data_sync</span><span class="token punctuation">(</span>  <span class="token keyword">input</span>         nrst<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   data_a<span class="token punctuation">,</span>  <span class="token keyword">input</span>         aclk<span class="token punctuation">,</span>  <span class="token keyword">output</span>        bclk<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  data_b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于计数值是连续变化的，采用格雷码实现。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">data_sync</span><span class="token punctuation">(</span>  <span class="token keyword">input</span>         nrst<span class="token punctuation">,</span>  <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   data_a<span class="token punctuation">,</span>  <span class="token keyword">input</span>         aclk<span class="token punctuation">,</span>  <span class="token keyword">output</span>        bclk<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  data_b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_a_gray<span class="token punctuation">;</span> <span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_a_gray_r<span class="token punctuation">;</span> <span class="token keyword">assign</span> data_a_gray <span class="token operator">=</span> data_a <span class="token operator">^</span> <span class="token punctuation">(</span>data_a <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> aclk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>    data_a_gray_r <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    data_a_gray_r <span class="token operator">&lt;=</span> data_a_gray<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> bclk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    data_b_gray <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    data_b_gray_r <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>    data_b_gray <span class="token operator">&lt;=</span> data_a_gray<span class="token punctuation">;</span>    data_b_gray_r <span class="token operator">&lt;=</span> data_b_gray<span class="token punctuation">;</span>  <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">assign</span> data_b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> data_b_gray_r<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> data_b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> data_b_gray_r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">^</span> data_b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> data_b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> data_b_gray_r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^</span> data_b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> data_b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> data_b_gray_r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^</span> data_b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="模3-模7检测器"><a href="#模3-模7检测器" class="headerlink" title="模3 模7检测器"></a>模3 模7检测器</h1><p>使用verilog代码，设计电路，判断输入序列能否被三整除，能的时候输出1，不能的时候输出0</p><p>思路：本质是一个序列检测器，通过现态和输入决定输出和下一个状态。余数只有三种可能，00,01,10。输入从右面进，之前的状态需要向左移1比特。状态机如下。</p><table><thead><tr><th align="center">当前态余数</th><th align="center">输入</th><th align="center">次态余数</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">2</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">2</td><td align="center">0</td></tr></tbody></table><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">mod3</span><span class="token punctuation">(</span>  <span class="token keyword">input</span>       clk<span class="token punctuation">,</span>  <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>  <span class="token keyword">input</span>       data_in<span class="token punctuation">,</span>  <span class="token keyword">output</span> <span class="token keyword">reg</span>  data_out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">parameter</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0 <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">,</span>                S1 <span class="token operator">=</span> <span class="token number">2'b01</span><span class="token punctuation">,</span>                S2 <span class="token operator">=</span> <span class="token number">2'b10</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> state<span class="token punctuation">,</span> next_state<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>      state <span class="token operator">&lt;=</span> S0<span class="token punctuation">;</span>  <span class="token keyword">end</span>      state <span class="token operator">&lt;=</span> next_state<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">case</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token keyword">begin</span>    S0<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>data_in<span class="token punctuation">)</span> next_state <span class="token operator">=</span> S1<span class="token punctuation">;</span> <span class="token keyword">else</span> next_state <span class="token operator">=</span> S0<span class="token punctuation">;</span>    S1<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>data_in<span class="token punctuation">)</span> next_state <span class="token operator">=</span> S0<span class="token punctuation">;</span> <span class="token keyword">else</span> next_state <span class="token operator">=</span> S2<span class="token punctuation">;</span>    S2<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>data_in<span class="token punctuation">)</span> next_state <span class="token operator">=</span> S2<span class="token punctuation">;</span> <span class="token keyword">else</span> next_state <span class="token operator">=</span> S1<span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span> next_state <span class="token operator">=</span> S0<span class="token punctuation">;</span>  <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>state <span class="token operator">==</span> S0<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>data_in<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>state <span class="token operator">==</span> S1<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>data_in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    data_out <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>     data_out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模7检测器是同样的道理。状态跳转如下表所示</p><table><thead><tr><th align="center">当前态余数</th><th align="center">输入</th><th align="center">次态余数</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center"></td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">2</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">1</td><td align="center">3</td><td align="center">0</td></tr><tr><td align="center">2</td><td align="center">0</td><td align="center">4</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">1</td><td align="center">5</td><td align="center">0</td></tr><tr><td align="center">3</td><td align="center">0</td><td align="center">6</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">4</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">1</td><td align="center">2</td><td align="center">0</td></tr><tr><td align="center">5</td><td align="center">0</td><td align="center">3</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">1</td><td align="center">4</td><td align="center">0</td></tr><tr><td align="center">6</td><td align="center">0</td><td align="center">5</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">1</td><td align="center">6</td><td align="center">0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-AXI总线及仲裁设计</title>
      <link href="/2024/022546524.html"/>
      <url>/2024/022546524.html</url>
      
        <content type="html"><![CDATA[<h2 id="AXI-Lite总线设计"><a href="#AXI-Lite总线设计" class="headerlink" title="AXI-Lite总线设计"></a>AXI-Lite总线设计</h2><p>采用AXI-Lite协议，只支持单次传输，不支持突发传输，接口信号简单。由于dcache既需要读操作，也需要写操作，以dcache为例进行说明；</p><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>读操作的依赖关系：先完成读地址通道的握手，再进行读数据的握手，得到读数据。</p><img src="/2024/022546524/image-20240226100402535.png" alt="image-20240226100402535" style="zoom:50%;"><ul><li><strong>master</strong></li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// AR</span><span class="token keyword">assign</span> axi_araddr <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> RADDR<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span>addr<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">3'b000</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span> <span class="token punctuation">:</span> <span class="token number">64'h0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> axi_arvalid <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> RADDR<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// R</span><span class="token keyword">assign</span> axi_rready <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> RDATA<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><ul><li>slave</li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// read operation</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>     rvalid <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>rvalid <span class="token operator">&amp;</span> rready<span class="token punctuation">)</span>    rvalid <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>arvalid <span class="token operator">&amp;</span> arready<span class="token punctuation">)</span>    rvalid <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">reg</span> flag<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    flag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>arvalid<span class="token punctuation">)</span>    flag <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    flag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> counter<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    counter <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>    counter <span class="token operator">&lt;=</span> counter <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    counter <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>     arready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>arvalid <span class="token operator">&amp;</span> arready<span class="token punctuation">)</span>    arready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>counter <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span>    arready <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    data <span class="token operator">=</span> <span class="token number">64'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>arvalid<span class="token punctuation">)</span>    data <span class="token operator">=</span> <span class="token function">paddr_read</span><span class="token punctuation">(</span>araddr<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>     data <span class="token operator">=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> rdata <span class="token operator">=</span> rvalid <span class="token operator">?</span> data <span class="token punctuation">:</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// counter 用来模拟salve提供数据所需要的周期数，延迟握手。</span></code></pre><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a><strong>写操作</strong></h3><p>写操作中，写地址和写数据通道没有明确的握手依赖关系，但是写响应通道需要写地址和写数据握手后才可以握手，由于AXI-Lite只支持单次数据传输，所以没有wlast参与。本设计中，先进行写地址握手，再进行写数据握手，最后写响应通道握手，完成写操作。</p><ul><li>master</li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// AW</span><span class="token keyword">assign</span> axi_awaddr  <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WADDR<span class="token punctuation">)</span> <span class="token operator">?</span> addr <span class="token punctuation">:</span> <span class="token number">64'h0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> axi_awvalid <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WADDR<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// W</span><span class="token keyword">assign</span> axi_wdata  <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WDATA<span class="token punctuation">)</span> <span class="token operator">?</span> wdata <span class="token punctuation">:</span> <span class="token number">64'h0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> axi_wstrb  <span class="token operator">=</span> <span class="token punctuation">(</span>flash_flag<span class="token operator">&amp;</span>dirty<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b11111111</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>flash_flag<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b0000_0000</span> <span class="token punctuation">:</span> byte_enable<span class="token punctuation">;</span><span class="token keyword">assign</span> axi_wvalid <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WDATA<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// B</span><span class="token keyword">assign</span> axi_bready <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WRESP<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><ul><li>slave</li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// write operation</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> waddr<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>     waddr <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>awvalid<span class="token punctuation">)</span>    waddr <span class="token operator">&lt;=</span> awaddr<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> wdata_r<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>     wdata_r <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>wvalid<span class="token punctuation">)</span>    wdata_r <span class="token operator">&lt;=</span> wdata<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    awready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>awvalid <span class="token operator">&amp;&amp;</span> awready<span class="token punctuation">)</span>    awready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>awvalid<span class="token punctuation">)</span>    awready <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    wready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>wvalid <span class="token operator">&amp;&amp;</span> wready<span class="token punctuation">)</span>    wready <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>wvalid<span class="token punctuation">)</span>    wready <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>wvalid <span class="token operator">&amp;&amp;</span> wready<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"write addr:%x, data:%x"</span><span class="token punctuation">,</span> waddr<span class="token punctuation">,</span> wdata_r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">case</span><span class="token punctuation">(</span>wstrb<span class="token punctuation">)</span>       <span class="token number">8'b00000001</span><span class="token punctuation">:</span> <span class="token function">paddr_write</span><span class="token punctuation">(</span>waddr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> wdata_r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token number">8'b00000011</span><span class="token punctuation">:</span> <span class="token function">paddr_write</span><span class="token punctuation">(</span>waddr<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> wdata_r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token number">8'b00001111</span><span class="token punctuation">:</span> <span class="token function">paddr_write</span><span class="token punctuation">(</span>waddr<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> wdata_r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token number">8'b11111111</span><span class="token punctuation">:</span> <span class="token function">paddr_write</span><span class="token punctuation">(</span>waddr<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> wdata_r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">endcase</span>  <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    bvalid <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>bvalid <span class="token operator">&amp;&amp;</span> bready<span class="token punctuation">)</span>    bvalid <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>wready <span class="token operator">&amp;</span> wvalid<span class="token punctuation">)</span>    bvalid <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> bresp <span class="token operator">=</span> bvalid <span class="token operator">?</span> <span class="token number">2'b00</span> <span class="token punctuation">:</span> <span class="token number">2'b00</span><span class="token punctuation">;</span></code></pre><h3 id="AXI仲裁器"><a href="#AXI仲裁器" class="headerlink" title="AXI仲裁器"></a>AXI仲裁器</h3><p>SRAM一般只有一个，Icache和Dcache可能出现同时访问SRAM的情况，产生了冲突，需要设计Arbiter来决定哪个master的优先级更高。当发生仲裁时，本设计中设计Dcache优先级更高。</p><img src="/2024/022546524/image-20240226102945089.png" alt="image-20240226102945089" style="zoom: 50%;"><p>Icache没有写操作的需要，不需要仲裁。只有Icache和Dcache同时发生读操作时才进行仲裁。</p><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>lsu_arvalid<span class="token punctuation">)</span> <span class="token keyword">begin</span>    arvalid <span class="token operator">=</span> lsu_arvalid<span class="token punctuation">;</span>    araddr  <span class="token operator">=</span> lsu_araddr<span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>    arvalid <span class="token operator">=</span> if_arvalid<span class="token punctuation">;</span>    araddr  <span class="token operator">=</span> if_araddr<span class="token punctuation">;</span>  <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>lsu_arvalid<span class="token punctuation">)</span>    if_arready <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>     if_arready <span class="token operator">=</span> arready<span class="token punctuation">;</span><span class="token keyword">end</span>  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>lsu_arvalid<span class="token punctuation">)</span>    if_rvalid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>     if_rvalid <span class="token operator">=</span> rvalid<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">// 当lsu_arvalid为1时，反压if_arready和if_rvalid，延迟Icache读地址通道和读数据通道的握手</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时钟切换设计</title>
      <link href="/2024/022513924.html"/>
      <url>/2024/022513924.html</url>
      
        <content type="html"><![CDATA[<h2 id="时钟切换"><a href="#时钟切换" class="headerlink" title="时钟切换"></a>时钟切换</h2><blockquote><p>某些时钟切换的场景下，需要选择信号来选择某一个时钟信号</p></blockquote><h3 id="组合逻辑选通"><a href="#组合逻辑选通" class="headerlink" title="组合逻辑选通"></a>组合逻辑选通</h3><p>电路对时钟信号非常敏感，如果采用组合逻辑选通时钟，很有可能在时钟上产生毛刺，导致功能错误，或者不满足时序要求，造成亚稳态。</p><img src="/2024/022513924/image-20240225231635368.png" alt="image-20240225231635368" style="zoom: 25%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> clk1_t <span class="token operator">=</span> clk1 <span class="token operator">&amp;</span> sel_clk1<span class="token punctuation">;</span><span class="token keyword">assign</span> clk2_t <span class="token operator">=</span> clk2 <span class="token operator">&amp;</span> <span class="token operator">!</span>sle_clk1<span class="token punctuation">;</span><span class="token keyword">assign</span> clk_out <span class="token operator">=</span> clk1_t <span class="token operator">|</span> clk2_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2024/022513924/8f134e7b11982eb43608e728782d78da.png" alt style="zoom: 33%;"><h3 id="时序逻辑选通"><a href="#时序逻辑选通" class="headerlink" title="时序逻辑选通"></a>时序逻辑选通</h3><p><strong>产生毛刺的本质原因是sel信号是异步的，无法保证输出的时钟在低电平时切换。</strong></p><p><strong>通过添加一级寄存器</strong>，使得sel选通信号在时钟切换在下降沿才发生变化，这样不会产生毛刺，因为是“相与”的关系。<br><strong>增加了反馈的好处</strong>：即使select信号改变了，时钟的切换需要等待切换前时钟为低电平时才可以 发生切换，保证了之前时钟信号的完整性（不会斩波）。<br>通过以上两种优化，就可以输出没有毛刺的时钟信号。这是一种非常安全的时钟切换方案。</p><img src="/2024/022513924/1bee2a8c32b64dd050b86e103ad3462d.jpeg" style="zoom:50%;"><p>此外，由于sel信号是异步输入，为了降低亚稳态，可以打两拍，再进行时钟切换。</p><img src="/2024/022513924/12ba42985f38e4091d39bc8bae8d191e.jpeg" style="zoom:50%;"><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">&#x2F;********************************************************************* * Author           : liu * Last modified    : 2023-05-30 15:25 * Filename         : switch_clock.v * Description      :  * ******************************************************************&#x2F;module switch_clock(  input clk1,  input rstn1,  input clk2,  input rstn2,  input select,  output clkout);  wire clk1_select;  wire clk2_select;  reg clk1_reg_r, clk1_reg_rr;  reg clk2_reg_r, clk2_reg_rr;  reg clk1_reg_rrr;  reg clk2_reg_rrr;    always @(posedge clk1 or negedge rstn1)beginif(!rstn1) begin  clk1_reg_r &lt;&#x3D; 0;  clk1_reg_rr &lt;&#x3D; 0;endelse begin  clk1_reg_r &lt;&#x3D; clk1_select;  clk1_reg_rr &lt;&#x3D; clk1_reg_r;end  end  always @(posedge clk2 or negedge rstn2)beginif(!rstn2) begin  clk2_reg_r &lt;&#x3D; 0;  clk2_reg_rr &lt;&#x3D; 0;endelse begin  clk2_reg_r &lt;&#x3D; clk2_select;  clk2_reg_rr &lt;&#x3D; clk2_reg_r;end  end  assign clk1_select &#x3D; select &amp; (~clk2_reg_rrr);  assign clk2_select &#x3D; ~select &amp; (~clk1_reg_rrr);  always @(negedge clk1 or negedge rstn1) beginif(!rstn1)  clk1_reg_rrr &lt;&#x3D; 0;else  clk1_reg_rrr &lt;&#x3D; clk1_reg_rr;  end  always @(negedge clk2 or negedge rstn2) beginif(!rstn2)  clk2_reg_rrr &lt;&#x3D; 0;else  clk2_reg_rrr &lt;&#x3D; clk2_reg_rr;  end  assign clkout &#x3D; (clk1 &amp; clk1_reg_rrr ) || (clk2 &amp; clk2_reg_rrr);endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/022513924/48bccb9764f34ae5948dd826d5dcb0f5.png" alt="测试结果"></p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2024/022548230.html"/>
      <url>/2024/022548230.html</url>
      
        <content type="html"><![CDATA[<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">压缩成.tar文件： <span class="token function">tar</span> <span class="token parameter variable">-cvf</span> file.tar files解压.tar文件： <span class="token function">tar</span> <span class="token parameter variable">-xvf</span> file.tar压缩成.tar.gz文件： <span class="token function">tar</span> <span class="token parameter variable">-czvf</span> file.tar.gz files解压.tar.gz文件： <span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> file.tar.gz压缩.tar.bz2文件： <span class="token function">tar</span> <span class="token parameter variable">-cjvf</span> file.tar.bz2 files解压.tar.bz2文件： <span class="token function">tar</span> <span class="token parameter variable">-xjvf</span> file.tar.bz2压缩成.gz 文件 <span class="token function">gzip</span> <span class="token function">file</span>解压 <span class="token function">gzip</span> <span class="token parameter variable">-d</span> file.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><p>​&#x2F; ——根目录<br>​&#x2F;bin ——存放必要的命令<br>​&#x2F;boot ——存放内核以及启动所需的文件<br>​&#x2F;dev ——存放设备文件<br>​&#x2F;etc ——存放系统配置文件<br>​&#x2F;home ——普通用户的宿主目录，用户数据存放在其主目录中<br>​&#x2F;lib ——存放必要的运行库<br>​&#x2F;mnt ——存放临时的映射文件系统，通常用来挂载使用。<br>​&#x2F;proc ——存放存储进程和系统信息<br>​&#x2F;root ——超级用户的主目录<br>​&#x2F;sbin ——存放系统管理程序<br>​&#x2F;tmp ——存放临时文件<br>​&#x2F;usr ——存放应用程序，命令程序文件、程序库、手册和其它文档。<br>​&#x2F;var ——-系统默认日志存放目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> <span class="token builtin class-name">:</span> 显示系统的hostname<span class="token function">ifconfig</span> <span class="token parameter variable">-a</span> <span class="token builtin class-name">:</span> 显示网络的配置信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查看文件内容情况："><a href="#查看文件内容情况：" class="headerlink" title="查看文件内容情况："></a>查看文件内容情况：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> <span class="token function">file</span> <span class="token builtin class-name">:</span> 计算文件的行数和字节数<span class="token function">wc</span> <span class="token parameter variable">-w</span> <span class="token function">file</span> <span class="token builtin class-name">:</span> 计算文件的字数<span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token function">file</span> <span class="token builtin class-name">:</span> 计算文件的行数<span class="token function">find</span> 查找文件或目录命令格式为: <span class="token function">find</span> 后接查找的目录，-name指定需要查找的文件名称，名称可以使用“* ”表示所有。<span class="token function">find</span> /home <span class="token parameter variable">-name</span> “test.txt”,<span class="token function">find</span> /home <span class="token parameter variable">-name</span> “*.txt” :查找/home目录下，所有以.txt结尾的文件或者目录。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><p>在&#x2F;home&#x2F;usr目录中查找文件名中包括”<strong>Montage</strong>“或者<strong>montage</strong>的文件名，并打印出来；</p><p>A：</p><pre class="line-numbers language-none"><code class="language-none">grep -rli &quot;Montage\|montage&quot; &#x2F;home&#x2F;usr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​<code>grep</code> 命令用于在文件中搜索指定的模式。 </p><ul><li><p><code>-r</code> 选项用于在指定的目录和其子目录中递归搜索。 </p></li><li><p><code>-l</code> <strong>选项用于只输出包含模式的文件名，而不是匹配的行。(字母L的小写，如果没有这个，则会输出所有含有字段的文件名及对应行)</strong></p></li><li><p><code>-i</code> 选项用于忽略大小写。 </p></li><li><p><code>&#39;montage&#39;</code> 是要搜索的模式。 </p></li><li><p><code>/home/user/</code> 是要搜索的目录。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-Cache设计(二)</title>
      <link href="/2024/022536323.html"/>
      <url>/2024/022536323.html</url>
      
        <content type="html"><![CDATA[<h2 id="Cache实现"><a href="#Cache实现" class="headerlink" title="Cache实现"></a>Cache实现</h2><p>根据上述的理论知识，确定cache的设计要求如下</p><ol><li><p><strong>采用直接映射缓存的方式，cache size为2KB，cache line为8Bytes</strong></p></li><li><p><strong>当访问cache缺省时，采用读分配Read allocate和写分配Write allocate策略，</strong></p></li><li><p><strong>cache的更新策略为写回Write Back</strong></p></li></ol><h3 id="Icache实现"><a href="#Icache实现" class="headerlink" title="Icache实现"></a>Icache实现</h3><p>​icache在流水线中的位置以及接口信号如下</p><img src="/2024/022536323/image-20240225165626395.png" style="zoom: 33%;"><p>​包含两组握手信号，第一个是ifu和PC寄存器的握手，只有ifpc_valid &amp; ifpc_ready&#x3D;1握手后，才可以更新ifu阶段的取值地址pc_i。第二个是ifu和icache的握手，只有cache_rdy &amp;  cache_vld 握手成功后，ifu阶段才可以拿到pc对应的指令，并通过inst_valid信号指示，给到IF_ID寄存器。Icache和SRAM通过AXI协议完成读取指令。</p><p>​由于icache只有对内存读取数据的需求，所以AXI协议中的写地址、写数据和写响应通道可以忽略，icache的整个状态跳转如下</p><img src="/2024/022536323/image-20240225171812056.png" alt="image-20240225171812056" style="zoom:33%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> allocate <span class="token operator">=</span> state <span class="token operator">==</span> ALLOCATE<span class="token punctuation">;</span><span class="token keyword">assign</span> wstrb <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> ALLOCATE<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b11111111</span> <span class="token punctuation">:</span> <span class="token number">8'b00000000</span><span class="token punctuation">;</span><span class="token keyword">assign</span> wdata <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> ALLOCATE<span class="token punctuation">)</span> <span class="token operator">?</span> ram_data <span class="token punctuation">:</span> <span class="token number">64'h0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> ready <span class="token operator">=</span> hit <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> IDLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">case</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>        IDLE <span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>hit<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span>            next_state <span class="token operator">=</span> RADDR<span class="token punctuation">;</span>                <span class="token keyword">else</span>                          next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>        RADDR<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>axi_arvalid <span class="token operator">&amp;&amp;</span> axi_arready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>                <span class="token keyword">else</span>                          next_state <span class="token operator">=</span> RADDR<span class="token punctuation">;</span>        RDATA<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>axi_rvalid <span class="token operator">&amp;&amp;</span> axi_rready<span class="token punctuation">)</span>   next_state <span class="token operator">=</span> ALLOCATE<span class="token punctuation">;</span>                <span class="token keyword">else</span>                          next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>        ALLOCATE<span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>         <span class="token keyword">default</span> <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有在IDLE状态才会读取cache的数据，如果hit，直接输出有效的指令；如果miss，则通过AXI读取内存，首先跳转到RADDR状态，进行读地址通道的握手，然后跳转到读数据状态。读地址通道握手后，得到指令数据，然后跳转到读分配状态，将读出的指令加载到cachemem中。最终在IDLE状态，hit该cacheline，读出数据。</p><p>cachemem中对于hit的判断和cacheline的更新如下</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>flash<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token function">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>DATA_SIZE<span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>   v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  d<span class="token punctuation">[</span>i<span class="token punctuation">]</span>   <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  tag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>      mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>en <span class="token operator">&amp;</span> allocate<span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token function">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token function">if</span><span class="token punctuation">(</span>wen<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> wdata<span class="token punctuation">[</span><span class="token number">8</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    d<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    tag<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> addr_tag<span class="token punctuation">;</span>   <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">assign</span> addr_index <span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> addr_tag <span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> offset<span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">assign</span> hit <span class="token operator">=</span> en <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>addr_tag <span class="token operator">==</span> tag<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> rdata <span class="token operator">=</span> offset<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">?</span><span class="token operator">&#123;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">&#125;</span> <span class="token punctuation">:</span> <span class="token operator">&#123;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于inst指令是32bit的，cacheline是64bit，通过判断offset[2]确定读取命中cacheline的高32bit还是低32bit。</p><p><strong>在cache miss时，通过AXI访问内存时，通常需要多个周期。这个过程中，需要将流水线停顿下来，发出stall信号给PC寄存器，输出给IF_ID寄存器为nop指令。</strong></p><hr><h3 id="Dcache实现"><a href="#Dcache实现" class="headerlink" title="Dcache实现"></a>Dcache实现</h3><p>​dcache在流水线中的位置以及接口信号如下</p><img src="/2024/022536323/image-20240225202346217.png" alt style="zoom:33%;"><p>​只包含一组握手信号，lus和dcache之间；对dcache进行读操作的过程跟icache差不多。<br>​<strong>最大区别</strong>在于写操作，写缺省时，执行写分配，将写入地址的数据读取到cachemem中(这个过程和读分配差不多)，在IDLE状态将待更新的数据写入到cacheline中，并将对应的dirty位置1。在替换该cacheline时，判断dirty位为1，需要先将数据写入到内存中；因此，相比icache，多了很多状态。</p><img src="/2024/022536323/image-20240225205639538.png" alt="image-20240225205639538" style="zoom:33%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>IDLE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> dirty <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> WRITEBACK <span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> RADDR <span class="token punctuation">:</span> IDLE<span class="token punctuation">;</span>WRITEBACK <span class="token punctuation">:</span> next_state <span class="token operator">=</span> WADDR<span class="token punctuation">;</span>ALLOCATE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>RADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_arvalid <span class="token operator">&amp;&amp;</span> axi_arready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>RDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_rvalid  <span class="token operator">&amp;&amp;</span> axi_rready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> ALLOCATE<span class="token punctuation">;</span>WADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_awvalid <span class="token operator">&amp;&amp;</span> axi_awready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> WDATA<span class="token punctuation">;</span>WDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_wvalid  <span class="token operator">&amp;&amp;</span> axi_wready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> WRESP<span class="token punctuation">;</span>        WRESP <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_bvalid  <span class="token operator">&amp;&amp;</span> axi_bready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> RADDR<span class="token punctuation">;</span><span class="token keyword">default</span> <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span><span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>针对读写指令是字节&#x2F;半字&#x2F;字&#x2F;双字</p><p>在读写cacheline时需要根据地址的后三位使用offset来限制，保证读出的数据都是对齐的，写入数据对cacheline的数据更新也是对齐的。</p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> offset <span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// Read</span><span class="token important">always @</span><span class="token operator">*</span> <span class="token keyword">begin</span>  <span class="token function">case</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span> <span class="token number">3'b000</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">3'b001</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">8'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b010</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">16'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b011</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">24'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b100</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b101</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">40'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b110</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">48'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">48</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token number">3'b111</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">56'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> we_offset<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">case</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token number">3'b000</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">3'b001</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">3'b010</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3'b011</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">3'b100</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token number">3'b101</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token number">3'b110</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token number">3'b111</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">default</span> <span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we<span class="token punctuation">;</span>  <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> wdata_offset<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">case</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token number">3'b000</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">3'b001</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">3'b010</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3'b011</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token number">3'b100</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token number">3'b101</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token number">3'b110</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">6</span><span class="token punctuation">;</span><span class="token number">3'b111</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">default</span> <span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata<span class="token punctuation">;</span>  <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> tag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>en <span class="token operator">&amp;&amp;</span> hit<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span>we_offset<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> wdata_offset<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">end</span>  <span class="token keyword">end</span>  d<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>en <span class="token operator">&amp;&amp;</span> allocate<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span>we<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> wdata<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">end</span>  <span class="token keyword">end</span>  d<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  v<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  tag<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> addr_tag<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// lsu.v</span><span class="token comment">// 针对不同的指令，将输出的结果进行符号位扩展。</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>lden_i<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token function">case</span><span class="token punctuation">(</span>lsfunc3_i<span class="token punctuation">)</span>  <span class="token number">3'b000</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;&#123;</span><span class="token number">56</span><span class="token operator">&#123;</span>temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b001</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;&#123;</span><span class="token number">48</span><span class="token operator">&#123;</span>temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b010</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;&#123;</span><span class="token number">32</span><span class="token operator">&#123;</span>temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b100</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">56'b0</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b101</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">48'b0</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b110</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>  <span class="token number">3'b011</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token keyword">default</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">endcase</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> lsres <span class="token operator">=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在dcache读写内存时，需要多个周期，这时流水线需要停顿下来，发出stall信号，将前面各个阶段寄存器的数据保持不变。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-Cache设计（一）</title>
      <link href="/2024/022542394.html"/>
      <url>/2024/022542394.html</url>
      
        <content type="html"><![CDATA[<h2 id="Cache基础知识"><a href="#Cache基础知识" class="headerlink" title="Cache基础知识"></a>Cache基础知识</h2><blockquote><p>部分参考网上的学习资料，侵删。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>时间局部性：在程序中，某个数据在短时间内会被频繁用到。<br>空间局部性：访问某个数据时，通过附近数据的概率也很大，比如循环访问数组数据。</p><p>Cache：用一块小而块的存储设备（采用SRAM实现），作为大而慢的存储设备的缓冲区，提高访存的速度，并降低功耗。考虑到时间、空间局部性原理，cache的作用就显而易见了。</p><p>cache的大小: cache size，cache平分成很多块称为cacheline，大小是 cache line size。比如，一个64Bytes的cache，平分成8个cache line，每个cache line大小是8Bytes</p><h4 id="分配策略-针对cacheline，读写缺省"><a href="#分配策略-针对cacheline，读写缺省" class="headerlink" title="分配策略(针对cacheline，读写缺省)"></a>分配策略(针对cacheline，读写缺省)</h4><ul><li><p>读分配：读取cache时，发生cache缺省，分配一个cache line缓存，用于读取数据。(天然满足)</p></li><li><p>写分配：写cache时，发生缺省时，从主存中加载数据到cacheline，更新该cacheline数据，将dirty位置1，等到替换时，再写入主存。</p></li></ul><h4 id="Cache更新策略（写cache命中）"><a href="#Cache更新策略（写cache命中）" class="headerlink" title="Cache更新策略（写cache命中）"></a>Cache更新策略（写cache命中）</h4><ul><li>写直通</li></ul><p>​当CPU执行store指令，在cache中命中时，既更新cache中数据也更新主存中的数据，保证数据一致性。</p><ul><li>写回</li></ul><p>​当CPU执行store指令并在cache命中时，我们只更新cache中的数据。并且每个cache line中会有一个bit位记录数据是否被修改过，称之为dirty bit。我们会将dirty bit置1。主存中的数据只会在cache line被替换或者显示的clean操作时更新。因此，主存中的数据可能是未修改的数据，而修改的数据躺在cache中。cache和主存的数据可能不一致。更新cacheline时，要根据dirty位，决定是否将数据写回内存。然后再进行其他操作。</p><ul><li><h5 id="dirty-bit"><a href="#dirty-bit" class="headerlink" title="dirty bit"></a>dirty bit</h5></li></ul><p>​在写回的更新策略中，cache命中，首先会更新cacheline的数据，导致内存和cache中数据不一致，当该cache line被替代时，将替换的数据写到内存中。dirty bit是标记要写回到内存的cache line。</p><p><strong>通常写分配和写回策略一起使用</strong></p><hr><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射  "></a>直接映射  <img src="/2024/022542394/image-20240722104817022.png" alt="image-20240722104817022"></h4><p>优点：实现简单，运算组合逻辑延迟小。<br>缺点：hit rate较低，容易颠簸。</p><h4 id="两路组相连"><a href="#两路组相连" class="headerlink" title="两路组相连"></a>两路组相连</h4><p>将cache平均分成多份，每一份就是一路，两路组相连缓存就是将cache分为2份，每份32Bytes。一个index可以对应多个cacheline。</p><img src="/2024/022542394/image-20240225153918193.png" alt style="zoom: 33%;"><p>直接映射缓存每个地址只有一个cacheline的tag进行比较。</p><p>index也称为 组索引，相比于直接映射缓存，两路组相连映射缓存的index要少1bit，因为cache的个数少了一半，相当于一个addr地址对应于两个cacheline，然后通过tag比对两次，命中一个即cache命中。</p><p>优点：降低cache的颠簸可能性；<br>缺点：硬件成本高；</p><img src="/2024/022542394/image-20240722105457813.png" alt="image-20240722105457813" style="zoom:67%;"><h4 id="全相连"><a href="#全相连" class="headerlink" title="全相连"></a>全相连</h4><p>没有index，将addr的tag与所有的cacheline作比较。</p><p><img src="/2024/022542394/1665648129223.png" alt="img"></p><ul><li>一般TLB采用这种结构，size很小</li><li>缺点：面积、功耗代价很大。优点：很高的命中率，灵活性高。</li></ul><h4 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h4><p>替换发生在某个cache set中所有的cacheline都满了的情况。</p><ol><li><p><strong>LRU（Least Recently Used）</strong>最近最少使用替换算法</p><p>为每个cacheline设置一个使用次数计数部分，每当way被访问就累加1，计数值最小的就是要替换的cacheline。</p><p><img src="/2024/022542394/image-20240722134726409.png" alt="image-20240722134726409"></p><p>LRU指示最近最少使用的cacheline，MRU指示最近最多使用的cacheline。</p><p>当cacheline hit时，需要更改计数器的值，hit 的cacheline设置为0，低于hit cacheline的计数值加1。相当于设置了MRU的优先级。</p><p>当cacheline 没有hit时，需要替换cacheline，将最近最少使用的cacheline设置为替换后的cacheline，并将计数值设置为0，其他没有替换的cacheline都要加1。</p></li><li><p>随机替换</p></li><li><p>Round robin，first in first out</p></li></ol><h3 id="更新策略总结"><a href="#更新策略总结" class="headerlink" title="更新策略总结"></a>更新策略总结</h3><ul><li><strong>CPU读cache时</strong></li></ul><p>​若hit，CPU直接从cache读取数据即可<br>​若miss，<br>​Read allocate读分配：先从内存中读取数据到cache，再从cache中读数据。</p><ul><li><strong>CPU写cache时</strong></li></ul><p>​若hit，有两种处理方式<br>​Write thorough：把数据同时更新cache和内存中<br>​Write back ：先更新cacheline数据，设置dirty位，被替换时再通过flush方式写入内存</p><p>​若miss，有两种方式<br>​Write allocate：先把数据读取到cache中，更新该cacheline，被替换时再通过flush方式写入内存<br>​No Write allocate：只更新主存数据</p><h3 id="Multi-level-Caches"><a href="#Multi-level-Caches" class="headerlink" title="Multi-level Caches"></a>Multi-level Caches</h3><p><img src="/2024/022542394/image-20240722141434334.png" alt="image-20240722141434334"></p><p>Inclusive和Exclusive Cache</p><p><img src="/2024/022542394/image-20240722142442377.png" alt="image-20240722142442377"></p><p>inclusive cache中，L1的数据一定包含在L2中，当L1的cacheline被替换时，L2的数据也要替换掉。</p><p>exclusive cache中，L1数据被替换时，放在L2 Cache中。 </p><h3 id="Cache-Performance"><a href="#Cache-Performance" class="headerlink" title="Cache Performance"></a>Cache Performance</h3><p><strong>AMAT（Average memory access time）&#x3D; cache hit time + cache_miss_rate * cache_miss_latency；</strong></p><p><img src="/2024/022542394/image-20240722143323292.png" alt="image-20240722143323292"></p><p>降低cache miss rate方法：</p><p><img src="/2024/022542394/image-20240722143524701.png" alt="image-20240722143524701"></p><p>软件编译去减小miss rate</p><p><img src="/2024/022542394/image-20240722143848234.png" alt="image-20240722143848234"></p><p>降低hit time（tag look up+cache access）</p><p><strong>PIPT(Physically indexed and physically tagged cache)</strong></p><ul><li>hit time &#x3D; TLB latency + cache latency</li></ul><p><img src="/2024/022542394/image-20240722145855659.png" alt="image-20240722145855659"></p><p><strong>VIVT(Virtually indexed Virtually Tagged cache)</strong></p><p><img src="/2024/022542394/image-20240722150128840.png" alt="image-20240722150128840"></p><p><strong>VIPT(Virtuall indexed Physically tagged cache)</strong></p><p><img src="/2024/022542394/image-20240722150443695.png" alt="image-20240722150443695"></p><p>降低cache miss的延迟</p><p><img src="/2024/022542394/image-20240722151009627.png" alt="image-20240722151009627"></p><p><img src="/2024/022542394/image-20240722151228022.png" alt="image-20240722151228022"></p><h4 id="Prefetch"><a href="#Prefetch" class="headerlink" title="Prefetch"></a>Prefetch</h4><p><img src="/2024/022542394/image-20240722151309597.png" alt="image-20240722151309597"></p><h3 id="Cache-MESI"><a href="#Cache-MESI" class="headerlink" title="Cache MESI"></a>Cache MESI</h3><p><img src="/2024/022542394/image-20240722164009399.png" alt="image-20240722164009399"></p><p>将transition 序列串行化，通过interconnect network来实现，否则会有内存一致性问题。</p><p>MESI cache一致性协议是write-invalidate的。</p><p>保证cache一致性的提前是 <strong>写传播和事务串行化</strong>，写传播表示 在对某一个cacheline进行修改时，需要让其他核心的cache知道该修改。</p><p><img src="/2024/022542394/image-20240722164508794.png" alt="image-20240722164508794"></p><p><img src="/2024/022542394/image-20240722164553808.png" alt="image-20240722164553808"></p><p>系统里面只能有一个cacheline是modified</p><p> <img src="/2024/022542394/image-20240722164932903.png" alt="image-20240722164932903"></p><p>cacheline只存在当前cache里面，memory中其他cache里面没有。</p><p><img src="/2024/022542394/image-20240722165020653.png" alt="image-20240722165020653"></p><p>cacheline在多个cache里面都有。</p><p><img src="/2024/022542394/image-20240722165055916.png" alt="image-20240722165055916"></p><p><img src="/2024/022542394/image-20240722165352888.png" alt="image-20240722165352888"></p><p><img src="/2024/022542394/image-20240722170305260.png" alt="image-20240722170305260"></p><p><img src="/2024/022542394/image-20240722170448079.png" alt="image-20240722170448079"></p><p>软件可以配置将内存数据写入到Scratchpad Mmeory中。没有tag的比较，速度非常快，一个周期就可以得到数据。</p><h4 id="内存一致性和缓存一致性的区别"><a href="#内存一致性和缓存一致性的区别" class="headerlink" title="内存一致性和缓存一致性的区别"></a>内存一致性和缓存一致性的区别</h4><p>缓存一致性有两个角度，纵向：cache和内存中的数据不一致。横向：不同cache的同一个cacheline数据不一致。</p><p>内存一致性：从多个核心角度看待内存数据不一致，如果不同核心发出读写任务，且乱序，如果不做内存一致性处理，容易导致读写数据不一致的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C基础</title>
      <link href="/2024/02248418.html"/>
      <url>/2024/02248418.html</url>
      
        <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>堆栈</li></ul><p>stack堆是操作系统在编译时分配的，有一定的限制，是个定值；<br>heap栈是动态内存，由编程者自行决定；</p><img src="/2024/02248418/wps3.jpg" style="zoom:50%;"><p>eg. 存在函数返回值为指针时，由于返回的是地址，当stack内存被覆盖时，会引起读取数据错误，所以在返回值的地方要申请一块heap内存.</p><img src="/2024/02248418/wps4.jpg" style="zoom:50%;"><p>函数返回值为局部变量时，需要将变量设置为static静态变量，因为执行玩该函数,就会释放内存。如果返回值的是一个地址，那么后面再使用到该地址可能就不对了，因为他已经释放掉了。（static int *Add(int*a, int*b) ）</p><ul><li><p>内存泄露</p><p>内存泄漏指的是申请的动态内存heap，使用结束后没有释放，导致内存不足。</p></li></ul><h3 id="变量指针"><a href="#变量指针" class="headerlink" title="变量指针"></a>变量指针</h3><img src="/2024/02248418/wps1.jpg" style="zoom:50%;"><img src="/2024/02248418/wps2.jpg" alt="img" style="zoom:50%;"><pre class=" language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>c<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只允许读，不允许写</span></code></pre><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">*</span>a <span class="token operator">+</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> sum<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token operator">&amp;</span>add<span class="token punctuation">;</span>    sum <span class="token operator">=</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="static-extern关键字"><a href="#static-extern关键字" class="headerlink" title="static&#x2F;extern关键字"></a>static&#x2F;extern关键字</h2><p>Static可以用来修饰局部变量，保证在规定范围内，变量一直有效；</p><pre class=" language-C"><code class="language-C">#include<stdio.h>void test()&#123;    Static int a = 1;    a++;    printf("%d ", a);&#125;int main(void)&#123;    int i = 0;    while (i <= 10)    &#123;        test();        i++;    &#125;    return 0;&#125;// a的值只在函数内有效// Static修饰局部变量，修改了变量的生命周期，本质上改变了变量的存储范围，变成了静态存储区</code></pre><img src="/2024/02248418/wps6.png" alt="img" style="zoom:50%;"><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>Static修饰全局变量时，其他文件不可以访问该变量。<br>Extern声明的函数和变量，可以被其他文件访问。</p><img src="/2024/02248418/wps7.jpg" alt style="zoom: 67%;"><h2 id="全局结构体变量定义"><a href="#全局结构体变量定义" class="headerlink" title="全局结构体变量定义"></a>全局结构体变量定义</h2><p>​结构体是一种变量类型，最好方式是在.h文件定义，其他地方想用这个结构体，只需包含此.h文件即可，但是定义结构体变量的话，最好在.c文件定义，然后.h里面extern声明，其他.c文件想用只需包含.h文件即可。（为了防止重复定义，所以不建议在.h文件中直接定义变量）</p><pre class=" language-C"><code class="language-C">// a.ctemptype temp1,temp2,temp3;// 必须在函数里面使用才可以// a.htypedef struct &#123;    u8 disp_int;        //整数部分    u8 disp_flo;        //小数部分    u8 disp_flag;       //符号部分&#125;temptype; extern temptype temp1,temp2,temp3;// extern是一种“外部声明”的关键字，字面意思就是在此处声明某种变量或函数，在外部定义。// b.c#include “a.h”u8 data;data = temp1.disp_int;</code></pre><p>函数 extern &#x2F;&#x2F;不使用include</p><pre class=" language-C"><code class="language-C">a.c //定义extern int fun(int a, int b)&#123;    return a + b;&#125;b.c //声明#include<stdio.h>extern int fun(int a, int b);int main()&#123;    int result = fun(1, 3);    return 0;&#125;</code></pre><h2 id="ELF文件解析"><a href="#ELF文件解析" class="headerlink" title="ELF文件解析"></a>ELF文件解析</h2><p>程序中的段和节是真正的程序体，段包括代码段和数据段，多个节经过链接合并成一个段</p><p>段和节的信息都是通过header描述的，程序头是program header， 节头是section header；<br>段和节的大小都是不固定的，需要专门的数据结构来描述，即程序头表（program header table）和节头表（section header table）<br>这是两个数组，程序头表的元素全是程序头，节头表的元素全是节头。<br>程序头表是描述段的。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">get_syscall_name</span><span class="token punctuation">(</span>uintptr_t type<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> SYS_exit  <span class="token punctuation">:</span> <span class="token function">strcpy</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"SYS_exit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> SYS_gettimeofday<span class="token punctuation">:</span><span class="token function">strcpy</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"SYS_gettimeofday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Unhandled syscall"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> name<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>program break 是用户程序的数据段data segment结束的位置，链接的时候ld会默认添加一个名为_end的符号，指示程序的数据段结束位置。用户程序开始运行的时候, program break会位于_end所指示的位置, 意味着此时堆区的大小为0<br>通过访问end的地址即可得到program break，用户程序申请内存时，需要将递增后的program break作为地址传给系统调用，然后返回原来的program地址，供程序使用。</p><h3 id="C语言语法"><a href="#C语言语法" class="headerlink" title="C语言语法"></a>C语言语法</h3><h4 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h4><p><code>##(预处理器粘合剂)</code>：表示连接作用，比如，#define CON(x,y) x##y，表示 x和y接在一起<br><code>变参宏</code> ：比如 #define PR(…)  printf(_<em>VA_ARGS</em>_)</p><h4 id="位结构体"><a href="#位结构体" class="headerlink" title="位结构体"></a>位结构体</h4><p>​实现C中变量长度截断+符号位扩展，code如下</p><pre class=" language-C"><code class="language-C">#define SEXT(x, len) (&#123; struct &#123; int64_t n : len; &#125; __x = &#123; .n = x &#125;; (uint64_t)__x.n; &#125;)#define SEXT(x, len) (&#123;   struct &#123;     int64_t n : len;   &#125; __x = &#123;     .n = x   &#125;;   (uint64_t)__x.n; &#125;)</code></pre><p>可以整理成下面的形式进行分析，首先采用宏定义的形式，#define 关键一句在于‘int64_t n : len 表示只取n的后len位，对应于verilog变量的[len-1:0]位.<br>通过‘(uint64_t)__x.n; ，将len位的数据进行符号位扩展，符号位为n[len-1]的数据。</p><blockquote><p> 如果不采用这种方式进行符号位扩展的话，就会按照最高位为1的进行扩展，得到所有高位都是1，这种并不是我们想要的，比如一个10为的二进制数据：0010010101，扩展成16位，就会得到1111111110010101。这种不是我们要的结果。<br>如果按照上文提供的位结构体实现，就会得到0000000010010101，这才是我们想要的结果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-乘除法器设计</title>
      <link href="/2024/022240394.html"/>
      <url>/2024/022240394.html</url>
      
        <content type="html"><![CDATA[<h2 id="乘法器设计"><a href="#乘法器设计" class="headerlink" title="乘法器设计"></a>乘法器设计</h2><p>本设计采用基于4 Booth和华莱士树乘法器相结合的方式实现乘法；<br>一般乘法运算采用移位累加的方式实现，当乘法位数较大时，组合逻辑很大，且中间结果不易插入寄存器。在本设计的乘法中，<strong>Booth算法减小了部分积的个数，华莱士树算法提高了计算累加和的速度，且可以在中间插入寄存器，进一步提高主频和数据吞吐量</strong></p><h4 id="Booth算法"><a href="#Booth算法" class="headerlink" title="Booth算法"></a>Booth算法</h4><h5 id="booth乘法算法的条件"><a href="#booth乘法算法的条件" class="headerlink" title="booth乘法算法的条件"></a>booth乘法算法的条件</h5><ol><li>乘数和被乘数都是偶数，如果不是需要扩展符号位</li><li>补码运算，如果想要实现无符号数运算，需要在乘数和被乘数前面扩展两个0，然后按照补码运算</li></ol><p>编码的计算需要将乘数后面补0，一次完整的乘法共有N&#x2F;2个码元</p><img src="/2024/022240394/Booth_multiplication with shifter.png" alt="使用移位加实现Booth乘法" style="zoom: 33%;"><h5 id="key-point"><a href="#key-point" class="headerlink" title="key point"></a>key point</h5><ul><li><p>扩展符号位成偶数时，需要根据有无符号位进行扩展，如果是无符号，扩展0，如果有符号位，扩展符号位</p></li><li><p>在进行部分积累加中，每个cycle需要将累加寄存器右移两位，为的是对齐，得到真实的部分和，在下次加法时，保证是对齐的</p></li><li><p>在累加器右移过程中，需要扩展两位符号位，因为右移了2位，在下次操作时就要用到这两位符号位</p></li><li><p>booth两位运算规则</p></li></ul><table><thead><tr><th>yi+1</th><th>yi</th><th>yi-1</th><th>操作</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>+0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>+X补</td></tr><tr><td>0</td><td>1</td><td>0</td><td>+X补</td></tr><tr><td>0</td><td>1</td><td>1</td><td>+2X补</td></tr><tr><td>1</td><td>0</td><td>0</td><td>-2X补</td></tr><tr><td>1</td><td>0</td><td>1</td><td>-X补</td></tr><tr><td>1</td><td>1</td><td>0</td><td>-X补</td></tr><tr><td>1</td><td>1</td><td>1</td><td>+0</td></tr></tbody></table><p>本设计中乘法运算为 64bit * 64bit，booth算法本身是带符号的补码运算，如果要兼容无符号运算，需要在符号位前面扩展1bit，但是算法又规定乘数和被乘数都是偶数，所以还需要扩展1bit 符号位0，总共扩展2bit，exp_B为(66+1)bit，代码如下</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> exp_B <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">1'b0</span><span class="token punctuation">,</span> unsigned_flag<span class="token punctuation">,</span> B<span class="token punctuation">,</span> <span class="token number">1'b0</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 最后补0是必须的，unsigned_flag = 1 => 表示无符号运算</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>按照有符号补码运算，64bit的乘数，产生32个部分积；考虑无符号运算，还需要产生一个部分积，该部分积的产生规则如下：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token keyword">case</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token number">3'b000</span><span class="token punctuation">,</span> <span class="token number">3'b111</span><span class="token punctuation">,</span> <span class="token number">3'b001</span> <span class="token punctuation">:</span>   P <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token number">3'b010</span> <span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>unsigned_flag<span class="token punctuation">)</span> P <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>   P <span class="token operator">=</span> X<span class="token punctuation">;</span>    <span class="token number">3'b110</span><span class="token punctuation">,</span> <span class="token number">3'b101</span> <span class="token punctuation">:</span> P <span class="token operator">=</span> <span class="token operator">~</span>X <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>                                 <span class="token number">3'b011</span> <span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>unsigned_flag<span class="token punctuation">)</span> P <span class="token operator">=</span> X<span class="token punctuation">;</span>            <span class="token keyword">else</span> P <span class="token operator">=</span> X <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token number">3'b100</span> <span class="token punctuation">:</span> P <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>X <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>                                               <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token comment">// 无符号数运算，如果乘数的最高位为0，部分积为0；如果乘数的最高位为1，部分积为被乘数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>最后，将部分积进行移位累加即可（每次累加和 移位2bit）</strong></p><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><pre class="line-numbers language-none"><code class="language-none">原码+补码&#x3D;模;负数+模&#x3D;补码;   -2的原码4’b1010, 补码为-2+16&#x3D;14(4&#39;b1110)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在verilog中的算术右移操作<code>&gt;&gt;&gt;</code>需要声明要移位的变量为<code>signed</code>类型。</p><h3 id="华莱士树算法"><a href="#华莱士树算法" class="headerlink" title="华莱士树算法"></a>华莱士树算法</h3><p><strong>本质是</strong> <strong>对累加的各个部分积进行压缩，最终压缩到单个C和S，通过加法器计算得到结果</strong></p><h4 id="进位保存加法器"><a href="#进位保存加法器" class="headerlink" title="进位保存加法器"></a><strong>进位保存加法器</strong></h4><ul><li>CAS （carry save adder）</li></ul><p>基本思想：将3个加数和减少为2个加数的和，将进位C和结果S分别计算保存，每个比特可以独立计算C和S，速度极快，一位的全加器相当于进位保留加法器 &#x3D;&gt; 3:2 压缩器。</p><p>比如一个算式如：Sum &#x3D; A + B + C + D，可以设计N bit的CAS结构，将多个数合并，经过两级CSA，最后将进位C[N-1:0]和Sum[N-1:0]通过一个加法器相加（<strong>注意将进位传给下面的CAS计算时，需要将C左移一位</strong>），得到最终结果。</p><img src="/2024/022240394/2.8_walloc_tree.4b50192e.png" alt style="zoom: 67%;"><p>上图是17bit的华莱士树，因为进位和输出结果都是同一个方向的，所以可以在每层之间插入寄存器打拍，提高主频。</p><p>相同bit的华莱士树有多种实现方式，如下图所示</p><img src="/2024/022240394/WORONG_exaxple of walllace tree.png" alt="两种错误的8个数相加的一位华莱士树" style="zoom: 33%;"><p>完成的功能相同，但是两者之间存在区别。<strong>关键点在于延迟</strong>，假设每个CSA部件的延迟为1，左面结构的结果延迟为5，右面为4。左面结构插入寄存器时，就会导致结果错误。</p><img src="/2024/022240394/image-20230811215003860.png" alt style="zoom: 33%;"><p>在设计华莱士树时，<strong>保证华莱士树的数据流是单向的，不会在该层之前进行操作，比如左图的进位C3，导致整个数据流发生了交叠</strong>。</p><h3 id="Booth算法×华莱士树算法"><a href="#Booth算法×华莱士树算法" class="headerlink" title="Booth算法×华莱士树算法"></a>Booth算法×华莱士树算法</h3><p>32位的乘法器结构如下，其中Switch模块完成将booth模块输出的结果打一拍，避免组合逻辑的延迟较长。</p><img src="/2024/022240394/image-20240222231842246.png" alt style="zoom: 33%;"><p>其中，booth输出的部分积，需要进行移位加才能进入到CSA模块中。代码如下</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// phase 1</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_1<span class="token punctuation">,</span> S1_1<span class="token punctuation">,</span> S2_1<span class="token punctuation">,</span> S3_1<span class="token punctuation">,</span> S4_1<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> C0_1<span class="token punctuation">,</span> C1_1<span class="token punctuation">,</span> C2_1<span class="token punctuation">,</span> C3_1<span class="token punctuation">,</span> C4_1<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa1</span><span class="token punctuation">(</span>in0<span class="token punctuation">,</span> in1<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">,</span> in2<span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">,</span> S0_1<span class="token punctuation">,</span> C0_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa2</span><span class="token punctuation">(</span>in3<span class="token operator">&lt;&lt;</span><span class="token number">6</span><span class="token punctuation">,</span> in4<span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">,</span> in5<span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">,</span> S1_1<span class="token punctuation">,</span> C1_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa3</span><span class="token punctuation">(</span>in6<span class="token operator">&lt;&lt;</span><span class="token number">12</span><span class="token punctuation">,</span> in7<span class="token operator">&lt;&lt;</span><span class="token number">14</span><span class="token punctuation">,</span> in8<span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">,</span> S2_1<span class="token punctuation">,</span> C2_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa4</span><span class="token punctuation">(</span>in9<span class="token operator">&lt;&lt;</span><span class="token number">18</span><span class="token punctuation">,</span> in10<span class="token operator">&lt;&lt;</span><span class="token number">20</span><span class="token punctuation">,</span> in11<span class="token operator">&lt;&lt;</span><span class="token number">22</span><span class="token punctuation">,</span> S3_1<span class="token punctuation">,</span> C3_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa5</span><span class="token punctuation">(</span>in12<span class="token operator">&lt;&lt;</span><span class="token number">24</span><span class="token punctuation">,</span> in13<span class="token operator">&lt;&lt;</span><span class="token number">26</span><span class="token punctuation">,</span> in14<span class="token operator">&lt;&lt;</span><span class="token number">28</span><span class="token punctuation">,</span> S4_1<span class="token punctuation">,</span> C4_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase 2</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> C0_2<span class="token punctuation">,</span> C1_2<span class="token punctuation">,</span> C2_2<span class="token punctuation">,</span> C3_2<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_2<span class="token punctuation">,</span> S1_2<span class="token punctuation">,</span> S2_2<span class="token punctuation">,</span> S3_2<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa6</span><span class="token punctuation">(</span>S0_1<span class="token punctuation">,</span> S1_1<span class="token punctuation">,</span> S2_1<span class="token punctuation">,</span> S0_2<span class="token punctuation">,</span> C0_2<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa7</span><span class="token punctuation">(</span>S3_1<span class="token punctuation">,</span> S4_1<span class="token punctuation">,</span> in15<span class="token operator">&lt;&lt;</span><span class="token number">30</span><span class="token punctuation">,</span> S1_2<span class="token punctuation">,</span> C1_2<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa8</span><span class="token punctuation">(</span><span class="token punctuation">(</span>C0_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C2_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S2_2<span class="token punctuation">,</span> C2_2<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa9</span><span class="token punctuation">(</span><span class="token punctuation">(</span>C3_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C4_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> in16<span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">,</span> S3_2<span class="token punctuation">,</span> C3_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase 3</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_3<span class="token punctuation">,</span> C0_3<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S1_3<span class="token punctuation">,</span> C1_3<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa10</span><span class="token punctuation">(</span>S0_2<span class="token punctuation">,</span> S1_2<span class="token punctuation">,</span> S2_2<span class="token punctuation">,</span> S0_3<span class="token punctuation">,</span> C0_3<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa11</span><span class="token punctuation">(</span>S3_2<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S1_3<span class="token punctuation">,</span> C1_3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase 4</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_4<span class="token punctuation">,</span> C0_4<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S1_4<span class="token punctuation">,</span> C1_4<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa12</span><span class="token punctuation">(</span>S0_3<span class="token punctuation">,</span> S1_3<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_3 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S0_4<span class="token punctuation">,</span> C0_4<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa13</span><span class="token punctuation">(</span><span class="token punctuation">(</span>C2_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C3_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_3 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S1_4<span class="token punctuation">,</span> C1_4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase 5</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_5<span class="token punctuation">,</span> C0_5<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa14</span><span class="token punctuation">(</span>S0_4<span class="token punctuation">,</span> S1_4<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_4 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S0_5<span class="token punctuation">,</span> C0_5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase 6</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa15</span><span class="token punctuation">(</span>S0_5<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_5 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_4 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> OUT <span class="token operator">=</span> S <span class="token operator">+</span> <span class="token punctuation">(</span>C <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="除法器设计"><a href="#除法器设计" class="headerlink" title="除法器设计"></a>除法器设计</h2><p>被除数Dividend &#x2F; 除数Divisor &#x3D; 商Quotient ······ 余数Remainder</p><p>简单的迭代除法是 <strong>试商法</strong>，迭代过程中，如果不够减，商0，根据是否恢复余数，分为恢复余数法（循环减法）、不恢复余数法（加减交替）。</p><p><strong>区别</strong>：逐位计算商的时候，不够减商0；如果是恢复余数算法，需要将余数加上除数；如果是不恢复余数算法，不需要加上余数，在下个周期时加上除数。</p><h3 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h3><p>64bit 绝对值 恢复余数除法运算结构如下</p><img src="/2024/022240394/image-20240223154401784.png" alt style="zoom:50%;"><p>优点：面积小，节省资源。缺点：速度慢</p><p>计算过程：被除数前面补64个0，记为A，除数为B，每个周期执行减法运算，判断ALU输出的符号，如果为负，寄存器A左移1bit且右面补0，不需要将ALU结果写入寄存器A；如果为正，寄存器A左移1bit，右面补1，将ALU计算结果写入寄存器A的高64位；以此类推，经过64个周期，从寄存器A中得到商和余数。最终，根据是否是 有符号计算，对输出结果进行处理。</p><p>其中，ALU采用补码进行减法运算。**[X - Y]补 &#x3D; [X]补 + [-Y]补**，  <strong>[-Y]补 &#x3D; [Y]补码 取反 + 1</strong></p><p>如果要同时支持无符号和有符号除法运算，需要对输入的数据进行预处理。根据被除数和除数的符号，决定 <strong>商和余数的符号</strong>；将有符号除法转换成无符号除法。</p><table><thead><tr><th align="center">被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td align="center">正</td><td>正</td><td>正</td><td>正</td></tr><tr><td align="center">正</td><td>负</td><td>负</td><td>正</td></tr><tr><td align="center">负</td><td>正</td><td>负</td><td>负</td></tr><tr><td align="center">负</td><td>负</td><td>正</td><td>负</td></tr></tbody></table><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> dividend_unsigned <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                            dividend<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">?</span>                           <span class="token operator">&#123;</span><span class="token number">1'b0</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token punctuation">(</span><span class="token operator">~</span>dividend<span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&#125;&#125;</span> <span class="token punctuation">:</span> dividend                            <span class="token punctuation">:</span> dividend<span class="token punctuation">;</span><span class="token keyword">assign</span> divisor_unsigned <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                           divisor<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">?</span>                          <span class="token operator">&#123;</span><span class="token number">1'b0</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token punctuation">(</span><span class="token operator">~</span>divisor<span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&#125;&#125;</span> <span class="token punctuation">:</span> divisor                          <span class="token punctuation">:</span> divisor<span class="token punctuation">;</span><span class="token keyword">assign</span> merchant   <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                     <span class="token punctuation">(</span>dividend<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">^</span> divisor<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span>                    <span class="token operator">-</span>merchant_t <span class="token punctuation">:</span> merchant_t                    <span class="token punctuation">:</span> merchant_t<span class="token punctuation">;</span><span class="token comment">//最后一次商结果作为最终的商</span><span class="token keyword">assign</span> remainder  <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                     dividend<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">?</span>                     <span class="token operator">-</span>remainder_t <span class="token punctuation">:</span> remainder_t                    <span class="token punctuation">:</span> remainder_t<span class="token punctuation">;</span> <span class="token comment">//最后一次余数作为最终的余数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="乘除法器-接入流水线CPU"><a href="#乘除法器-接入流水线CPU" class="headerlink" title="乘除法器 接入流水线CPU"></a>乘除法器 接入流水线CPU</h2><p>乘除法器都是多个周期才出结果，因此，需要握手信号。当乘除法指令到执行阶段时，Div&#x2F;Mul模块发出stall信号，等待valid和ready信号握手，输出计算结果，撤销stall信号，继续执行后续指令。</p><img src="/2024/022240394/image-20240222232209980.png" alt style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-Cache设计（三）</title>
      <link href="/2024/022113792.html"/>
      <url>/2024/022113792.html</url>
      
        <content type="html"><![CDATA[<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><h4 id="Fence指令"><a href="#Fence指令" class="headerlink" title="Fence指令"></a>Fence指令</h4><p>在前续集合predecessor执行到FENCE指令前的任何操作前，处于FENCE指令后的后续集合（successor）中的任何操作，都不能被其他任何RISC-V线程或者外部设备看到。即FENCE就像一个栅栏，FENCE之前所有的存储器操作、IO操作必须完成后，在FENCE指令之后的指令才能看到结果。 </p><h4 id="fence-i"><a href="#fence-i" class="headerlink" title="fence.i"></a>fence.i</h4><p>原因：store指令可能会对内存中的程序区进行修改，而icache可能看不到程序的修改，而读取错误的指令，导致程序运行错误。<br>目的：为了解决数据与指令的一致性问题，即icache和dcache的一致性。当执行fence.i指令时，fence之前的所有存储操作，io操作必须完成后，fence指令后面的指令才能访问内存。</p><h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><p>译码阶段遇到fence.i指令，icache和dcache的具体操作：</p><ol><li>对icache中的cachemem进行刷新，完成初始化，保证后面的所有取指令操作都是从内存中获取。</li><li>对dcache中cachemem的所有dirty置1的cacheline写到内存中，保证内存中代码区和数据区的一致性。</li></ol><h3 id="icache"><a href="#icache" class="headerlink" title="icache"></a>icache</h3><p>fence模块发出flash，stall和nop使能信号，将取指令的pc地址保持不变，将进入if阶段的fence指令通过nop冲刷掉，也就是说icache的cachemem一个周期就要完成冲刷。</p><img src="/2024/022113792/image-20240222105149731.png" alt style="zoom:50%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>flash <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>fence_i<span class="token punctuation">)</span>flash <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>flash_done<span class="token punctuation">)</span>flash <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> stall <span class="token operator">=</span> flash <span class="token operator">|</span> fence_i<span class="token punctuation">;</span><span class="token keyword">assign</span> nop <span class="token operator">=</span> stall<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dcache"><a href="#dcache" class="headerlink" title="dcache"></a>dcache</h3><p>设置FLASH和FLASH_DONE状态，等待到fence.i指令流水到访存阶段，进入FLASH状态，遍历所有cacheline，将所有脏（dirty）块写到内存中；cachesize为4k，cacheline为8byte，共需要进行512次写数据传输，判断dirty位是否为1，并通过wstrb确定有效字节，将wdata写入内存。</p><p>遍历结束后，flash_finish拉高，进入FLASH_DONE状态，拉高flash_done，pc重新从内存中取指令，流水线继续执行，完成了指令和数据的一致性。</p><img src="/2024/022113792/image-20240222112053777.png" alt style="zoom: 50%;"><img src="/2024/022113792/image-20240226100157943.png" alt style="zoom:50%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>IDLE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> flash <span class="token operator">?</span> FLASH <span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> dirty <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> WRITEBACK <span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> RADDR <span class="token punctuation">:</span> IDLE<span class="token punctuation">;</span>WRITEBACK <span class="token punctuation">:</span> next_state <span class="token operator">=</span> WADDR<span class="token punctuation">;</span>ALLOCATE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>RADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_arvalid <span class="token operator">&amp;&amp;</span> axi_arready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>RDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_rvalid  <span class="token operator">&amp;&amp;</span> axi_rready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> ALLOCATE<span class="token punctuation">;</span>WADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_awvalid <span class="token operator">&amp;&amp;</span> axi_awready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> WDATA<span class="token punctuation">;</span>WDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_wvalid  <span class="token operator">&amp;&amp;</span> axi_wready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> WRESP<span class="token punctuation">;</span>WRESP <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_bvalid  <span class="token operator">&amp;&amp;</span> axi_bready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> <span class="token punctuation">(</span>flash_flag <span class="token operator">&amp;&amp;</span> flash_finish<span class="token punctuation">)</span> <span class="token operator">?</span> FLASH_DONE <span class="token punctuation">:</span> flash_flag <span class="token operator">?</span> WADDR <span class="token punctuation">:</span> RADDR<span class="token punctuation">;</span>FLASH <span class="token punctuation">:</span> next_state <span class="token operator">=</span> WADDR<span class="token punctuation">;</span>FLASH_DONE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span><span class="token keyword">default</span> <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span><span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>flash_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>state <span class="token operator">==</span> WDATA<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>axi_wready<span class="token operator">&amp;&amp;</span>axi_wready<span class="token operator">&amp;&amp;</span>flash_flag<span class="token punctuation">)</span>flash_cnt <span class="token operator">&lt;=</span> flash_cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> flash_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>flash_finish <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>flash_flag <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>flash_cnt <span class="token operator">==</span> CACHE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>flash_finish <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> flash_finish <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>flash_flag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>state <span class="token operator">==</span> FLASH_DONE<span class="token punctuation">)</span>flash_flag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>state <span class="token operator">==</span> FLASH<span class="token punctuation">)</span>flash_flag <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> axi_wstrb  <span class="token operator">=</span> <span class="token punctuation">(</span>flash_flag<span class="token operator">&amp;</span>dirty<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b11111111</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>flash_flag<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b0000_0000</span> <span class="token punctuation">:</span> byte_enable<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><p>分页机制，虚拟地址划分以 <strong>页</strong>为单位（page），典型大小为4KB；<br>物理地址也有页，与虚拟页大小相同，称为 <strong>帧frame</strong></p><p>VA和PA都有两部分组成，一个是用来索引虚拟页或者物理帧，一个是页&#x2F;帧偏移</p><p>MMU内存管理单元负责虚拟内存到物理内存的映射。</p><p><img src="/2024/022113792/1666059846816.png" alt="img"></p><h5 id="单级页表"><a href="#单级页表" class="headerlink" title="单级页表"></a>单级页表</h5><p><strong>页表</strong> 用来存储VA到PA的映射关系，VA的一个页就可以放在物理地址的任何一个帧上了。</p><p>页表放在物理内存中，每个进程都有自己的页表。页表寄存器（PTR）用来索引页表。</p><p>单级页表访问内存（两次访问物理内存）</p><ol><li>根据PTR定位物理内存中的页表</li><li>根据VPN访问页表中的PFN</li><li>根据PFN访问物理内存</li></ol><h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><p>单级页表一张就需要4MB的巨大空间。多级页表将单级页表进行划分，实现更小的子页，也不需要巨大的连续地址空间。</p><img src="/2024/022113792/1666060401537.png" alt="img" style="zoom: 80%;"><ul><li>一个一级和二级页表都有2^10个表项, 因为物理内存是32位, 所以大小均为4KB, 正好可以放进物理内存的一个页内</li><li>一级页表4KB大小一般是不可避免的, 而二级页表则是根据需求逐步创建的, 操作系统会尽量让虚拟地址集中, 减少二级页表的开辟</li><li>多级页表的优势：易于扩展，当地址位宽增加到64位时，通过增加级数减少页表的占用。</li></ul><p><img src="/2024/022113792/1666077064529.png" alt="img"></p><p>虚拟内存的优点：</p><ol><li>每个进程都独占连续的地址空间</li><li>可以将连续的虚拟内存地址映射到不连续的物理地址，减小物理内存的碎片</li><li>为所有进程分配的总物理内存之和可以大于实际的物理内存大小，有些页在磁盘的swap区</li><li>可以实现每个页的访问权限</li></ol><h4 id="TLB的设计"><a href="#TLB的设计" class="headerlink" title="TLB的设计"></a>TLB的设计</h4><p>对于两级页表，需要访问两次物理内存才可以得到物理地址，延时太长。</p><p>增加一个 <strong>页表Cache</strong>加速这一进程，将页表中最近使用的PTE缓存起来，称为TLB（transition lookaside buffer）TLB是MMU的高速缓存，提高虚拟地址转换速度。TLB在MMU里面。</p><p>TLB只有时间相关性，一般TLB是全相连的，容量不会很大，采用全相连映射。</p><p>Cache存储实际的数据，TLB存储地址映射关系，存储的是MMU的映射关系。</p>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分频器设计</title>
      <link href="/2024/022118538.html"/>
      <url>/2024/022118538.html</url>
      
        <content type="html"><![CDATA[<p>分频器主要有以下几种设计</p><ol><li>偶分频（50%占空比）</li><li>奇分频（非50%占空比）</li><li>奇分频（50%占空比）</li><li>半整数（x.5）分频（非50%占空比）</li><li>任意小数分频（非50%占空比）</li></ol><h3 id="1-偶分频（50-占空比）"><a href="#1-偶分频（50-占空比）" class="headerlink" title="1. 偶分频（50%占空比）"></a>1. 偶分频（50%占空比）</h3><p>假设偶分频系数为N， 共有两种方式实现50%的偶分频。<br>方式1：计数到 N&#x2F;2-1，将clk_out翻转。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span>posedeg clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;=</span> N<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        clkout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> N<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        clkout <span class="token operator">&lt;=</span> <span class="token operator">~</span>clkout<span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方式2：计数到N-1，小于 N&#x2F;2 - 1，clkout输出0，否则输出1；(可实现不同占空比)</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        clk_out <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;=</span> N<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        clk_out <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_out <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-奇分频（非50-占空比）"><a href="#2-奇分频（非50-占空比）" class="headerlink" title="2. 奇分频（非50%占空比）"></a>2. 奇分频（非50%占空比）</h3><p>不需要使用双边沿逻辑，和偶分频的第二种方式类似。</p><h3 id="3-奇分频（50-占空比）"><a href="#3-奇分频（50-占空比）" class="headerlink" title="3. 奇分频（50%占空比）"></a>3. 奇分频（50%占空比）</h3><p>假设实现7分频时钟，需要3个完整周期+半个周期的电平翻转，可以通过两个3分频时钟 or 在一起得到，两个时钟相差半个周期，通过上升沿和下降沿触发得到。</p><p>需要双边沿逻辑；假设实现占空比50%的5分频，实现方法：</p><ol><li>采用正沿和负沿分别实现5分频</li><li>占空比为（5-1）&#x2F;2个源时钟周期</li><li>正沿和负沿产生的时钟信号做 <strong>或</strong></li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> Odd_div_50p #<span class="token punctuation">(</span>    <span class="token keyword">parameter</span> N <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk_in<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>        <span class="token keyword">output</span>      clk_out <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> clk_pos<span class="token punctuation">,</span> clk_neg<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt_pos<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt_neg<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        cnt_pos <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_pos <span class="token operator">==</span> N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cnt_pos <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        cnt_pos <span class="token operator">&lt;=</span> cnt_pos <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        cnt_neg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_neg <span class="token operator">==</span> N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cnt_neg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        cnt_neg <span class="token operator">&lt;=</span> cnt_neg <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment">// clk_pos clk_neg</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_pos <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_neg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> clk_out <span class="token operator">=</span> clk_pos <span class="token operator">|</span> clk_neg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有第二种方式实现占空比为50%的奇分频，N为奇数</p><ol><li>设计一个计数器，计数0 - N-1</li><li>设计两个使能信号，ttf1_en：当counter计数到0时拉高。ttf2_en：当counter计数到 N&#x2F;2时拉高。</li><li>时钟正沿控制div1的输出，当ttf1_en拉高时，div1翻转。时钟负沿控制div2输出，当ttf2_en拉高时，div2翻转</li><li>最终取div1和div2的异或结果，作为输出。</li></ol><h3 id="4-半整数（x-5）分频（非50-占空比）"><a href="#4-半整数（x-5）分频（非50-占空比）" class="headerlink" title="4. 半整数（x.5）分频（非50%占空比）"></a>4. 半整数（x.5）分频（非50%占空比）</h3><p>假设实现3.5分频，正沿计数器循环计数到7，分别交替产生分频比为4和3的时钟信号，平均下来得到的时钟信号为（4+3）&#x2F; 2 &#x3D; 3.5分频。但是每个分频时钟不是严格的3.5分频。<strong>因此，需要对不均匀的分频比进行调整，采用负沿计数器计数到7，分别交替产生分频比为3和4的时钟信号</strong>，将正沿和负沿产的时钟信号做 <strong>与</strong>操作，得到均匀的3.5分频的时钟信号。（注意，保证正沿计数器先产生分频比为4的信号）</p><img src="/2024/022118538/image-20240221164423487.png" alt style="zoom:67%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> Half_Int_div #<span class="token punctuation">(</span>    <span class="token keyword">parameter</span> N <span class="token operator">=</span> <span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>           clk_in<span class="token punctuation">,</span>    <span class="token keyword">input</span>           nrst<span class="token punctuation">,</span>    <span class="token keyword">output</span>          clk_out                      <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">localparam</span> Naddp5 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> Nsubp5 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pos_vth<span class="token punctuation">,</span> neg_vth<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pos_cnt<span class="token punctuation">,</span> neg_cnt<span class="token punctuation">;</span><span class="token keyword">reg</span> clk_pos<span class="token punctuation">,</span> clk_neg<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        pos_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>pos_cnt <span class="token operator">&lt;=</span> pos_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        pos_cnt <span class="token operator">&lt;=</span> pos_cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         pos_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         pos_vth <span class="token operator">&lt;=</span> Naddp5<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>pos_cnt <span class="token operator">==</span> pos_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>pos_vth <span class="token operator">==</span> Naddp5<span class="token punctuation">)</span>            pos_vth <span class="token operator">&lt;=</span> Nsubp5<span class="token punctuation">;</span>        <span class="token keyword">else</span>            pos_vth <span class="token operator">&lt;=</span> Naddp5<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>pos_cnt <span class="token operator">==</span> <span class="token number">'h0</span><span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        neg_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>neg_cnt <span class="token operator">&lt;=</span> neg_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        neg_cnt <span class="token operator">&lt;=</span> neg_cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         neg_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         neg_vth <span class="token operator">&lt;=</span> Nsubp5<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>neg_cnt <span class="token operator">==</span> neg_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>neg_vth <span class="token operator">==</span> Nsubp5<span class="token punctuation">)</span>            neg_vth <span class="token operator">&lt;=</span> Naddp5<span class="token punctuation">;</span>        <span class="token keyword">else</span>            neg_vth <span class="token operator">&lt;=</span> Nsubp5<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>neg_cnt <span class="token operator">==</span> <span class="token number">'h0</span><span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> clk_out <span class="token operator">=</span> clk_pos <span class="token operator">|</span> clk_neg<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>半整数分频还有另外一种实现方式，以4.5分频为例，步骤如下</p><ol><li>设计一个9bit的移位寄存器，初始值为9’b0000_00001，每个时钟上升沿右移1位。</li><li>生成第一个时钟脉冲，将移位寄存器的第一位右移半个周期（采用下降沿触发的寄存器产生），将该信号与移位寄存器的第一位和第二位进行”或”操作</li><li>生成第二个时钟脉冲，将移位寄存器的第五、六位右移半个周期（下降沿寄存器产生），将该信号与移位寄存器的第六位进行”或”操作。</li></ol><p><img src="/2024/022118538/image-20240527093457853.png" alt="image-20240527093457853"></p><h3 id="5-任意小数分频（非50-占空比）"><a href="#5-任意小数分频（非50-占空比）" class="headerlink" title="5. 任意小数分频（非50%占空比）"></a>5. 任意小数分频（非50%占空比）</h3><p>同样不能做到50%的占空比。基于可变分频和平均分频得到，在长时间内，得到小数分频比。<br>比如7.6分频，保证76个源时钟周期时间内，目的时钟经过10个周期的时间。即对源时钟进行 <strong>6次8分频，4次7分频（6*8+4*7&#x3D;76）。</strong>5.76分频，对源时钟进行 <strong>76次6分频，24次5分频</strong></p><p>以 7.6 倍分频为例，7 分频和 8 分频的实现顺序一般有以下 4 种：</p><p>(1) 先进行 4 次 7 分频，再进行 6 次 8 分频；<br>(2) 先进行 6 次 8 分频，再进行 4 次 7 分频；<br>(3) 将 4 次 7 分频平均的插入到 6 次 8 分频中；<br>(4) 将 6 次 8 分频平均的插入到 4 次 7 分频中。</p><p>前两种方法时钟频率不均匀，相位抖动较大，所以一般会采用后两种平均插入的方法进行小数分频操作。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-CPU流水线设计（一）</title>
      <link href="/2024/021950375.html"/>
      <url>/2024/021950375.html</url>
      
        <content type="html"><![CDATA[<p>将整个结构划分为五级，相比于单周期的CPU，在流水线设计过程中主要解决数据冒险和结构冒险和结构冒险。</p><h2 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h2><p>将数据旁路模块bypass放在译码阶段（id），与教材中放在执行阶段不同，原因是可以减少寄存器堆的一个读端口（译码to执行阶段 写寄存器的时候，Write back阶段已经将数据写入到寄存器堆中，所以要单独设置一个读端口读取写入寄存器堆的数据）</p><p>数据旁路的数据来源有四个：</p><ol><li>id译码阶段的寄存器堆输出 </li><li>exe执行阶段的结果 </li><li>ls访存阶段的结果 </li><li>wb写回阶段的结果</li></ol><img src="/2024/021950375/image-20240220111048796.png" alt style="zoom: 33%;"><p>判断条件:  </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>rs1_id <span class="token operator">==</span> xx_rdid<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>xx_rdwen<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs1_id <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>发生数据旁路<span class="token keyword">else</span>     不发生数据旁路<span class="token comment">// 如果源寄存器的id为0时，不能进行数据旁路，因为默认寄存器堆的0号寄存器值常0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>特别：如果在exe阶段的指令是load指令，且发生了数据冒险，需要将流水线停顿一拍，等待进入访问阶段才能得到真正的数据</strong>。 这种情况称为” load use”型指令，需要发出stall和nop使能。</p><p><img src="/2024/021950375/image-20240220134957838.png"></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> stall <span class="token operator">=</span> <span class="token punctuation">(</span>rs1id <span class="token operator">==</span> ex_rdid<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>rs2id <span class="token operator">==</span> ex_rdid<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ex_rdwen <span class="token operator">&amp;&amp;</span> ex_lden<span class="token keyword">assign</span> nop <span class="token operator">=</span> stall<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h2><p>控制冒险的处理放在译码阶段，而不是执行阶段，这样做可以提前决定指令执行顺序；</p><p>采用静态分支预测方式，当预测失败时，PC地址发生跳转，跳转地址在bru中计算得到；否则，执行PC+4。</p><img src="/2024/021950375/image-20240220144307189.png" alt style="zoom: 50%;"><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> nop <span class="token operator">=</span> jalr <span class="token operator">||</span> jal <span class="token operator">||</span> brch<span class="token punctuation">;</span><span class="token keyword">assign</span> jump_en <span class="token operator">=</span> nop<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2024/021950375/image-20240220150606788.png" alt style="zoom: 50%;"><p>针对跳转指令后的冲刷，如果没有取指令单元是组合逻辑，IF_ID寄存器直接冲刷即可。 如果取指令是时序逻辑，在冲刷IF_ID时，有可能指令还没得到，导致无法及时冲刷，在下个周期写入到IF_ID寄存器中，导致错误。所以在写入到IF_ID时需要判断PC出来的addr和写入IF_ID的地址是不是一致的，如果是一致的，就可以写入。</p><p>对于带cache的方案，当时hit没有命中时，会进行读分配操作，在IDLE时进行hit判断，即使发生了跳转，addr发生了变化，也不会hit，所以无需担心，不能彻底冲刷流水线的问题。</p><p>对于只有axi的方案，需要在写入IF_ID时，判断来自pc的地址和 ifu模块锁存的地址是否一致，只有一致才写入。</p><h2 id="数据冒险-控制冒险-冲突"><a href="#数据冒险-控制冒险-冲突" class="headerlink" title="数据冒险+控制冒险 冲突"></a>数据冒险+控制冒险 冲突</h2><p>当译码阶段的指令是jalr时，rs1发生了数据冒险，且是load-use类型，bypass模块发出stall和nop信号；bru模块发出jump和nop信号。对于IF_ID寄存器，同时收到了bypass的stall和bru的nop信号。<strong>此时，产生了冒险冲突</strong></p><p>解决办法：<strong>先stall处理完数据冒险，再nop处理控制冒险保证处理控制冒险时，跳转地址的计算是正确的。</strong></p><pre class="line-numbers language-systemverilog" data-language="systemverilog"><code class="language-systemverilog">&#x2F;&#x2F; exauipc a5 0x0ld   a5 595(a5)jalr  a5 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/021950375/image-20240220152550379.png"></p><h2 id="代码调试-DiffTest"><a href="#代码调试-DiffTest" class="headerlink" title="代码调试-DiffTest"></a>代码调试-DiffTest</h2><p>思路：找一个正确的版本作为参考，自己的设计每条指令执行后的结果（寄存器堆和内存的状态）进行对比，不一致就停止执行，报告错误。为了实现Difftest，需要在DUT和REF之间定义一些接口函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 在DUT host memory的`buf`和REF guest memory的`addr`之间拷贝`n`字节,</span><span class="token comment">// `direction`指定拷贝的方向, `DIFFTEST_TO_DUT`表示往DUT拷贝, `DIFFTEST_TO_REF`表示往REF拷贝</span><span class="token comment">// 完成将程序的bin文件拷贝到nemu中，大块内存的拷贝</span><span class="token keyword">void</span> <span class="token function">difftest_memcpy</span><span class="token punctuation">(</span><span class="token class-name">paddr_t</span> addr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">,</span> bool direction<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// `direction`为`DIFFTEST_TO_DUT`时, 获取REF的寄存器状态到`dut`;</span><span class="token comment">// `direction`为`DIFFTEST_TO_REF`时, 设置REF的寄存器状态为`dut`;</span><span class="token comment">// dut的数据顺序 npc和nemu需要一致。</span><span class="token keyword">void</span> <span class="token function">difftest_regcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dut<span class="token punctuation">,</span> bool direction<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 让REF执行`n`条指令</span><span class="token keyword">void</span> <span class="token function">difftest_exec</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化REF的DiffTest功能</span><span class="token keyword">void</span> <span class="token function">difftest_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在nemu中配置相关参数，生成动态库文件<code>ref_so_file</code></p><p>在npc中，需要对动态库文件进行初始化。通过 <strong>动态链接对动态库中的API符号进行解析和重定位，返回他们的函数地址</strong>，调用接口函数对REF进行初始化，将DUT的内存拷贝到REF中，将DUT的寄存器状态也拷贝到REF中，保证REF和DUT处于同样的状态。</p><p>在合适的位置调用REF的步进函数<code>ref_difftest_exec(1)</code>，然后将REF的寄存器堆数据传递到npc中，完成数据的对比，如果一致，则表示执行正确，否则停止执行，并打印错误的结果。</p><p>上面的数据比对是在c一侧，需要将verilog声明的数组通过DPI-C传递到C侧。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token keyword">void</span> <span class="token function">set_gpr_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> svOpenArrayHandle r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  cpu_gpr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>VerilatedDpiOpenVar<span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">datap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h2><p>由于只有一个内存空间，在取指阶段和访存阶段同时需要访问SRAM时，发生控制冒险。<br>解决措施：流水线停顿stall，Dcache优先级高于Icache，保证取数据优先，取数据完成后继续取指令。</p><p>在译码和写回阶段时，需要读取和写入寄存器的值，当访问的地址一样时，发生结构冒险。<br>解决措施：判断读出和将要写入的地址一致时，直接将写入的结果旁路给读出的变量。</p><h2 id="流水线-思考"><a href="#流水线-思考" class="headerlink" title="流水线-思考"></a>流水线-思考</h2><p>发出反压信号stall时，会让整个流水线停顿下来；<br>原因是每级流水的上下游没有握手和反压，当需要反压时，只能跨级反压，并且让所有的寄存器保持不变；</p><p><strong>如果每级流水都有响应的握手信号，就可以进行逐级反压，上面流水线不一定全部停顿下来，可以进一步提高效率</strong></p><h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>实现srlw指令出现的问题：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> srlw<span class="token punctuation">;</span> <span class="token important">always</span> srlw <span class="token operator">=</span> <span class="token operator">&#123;&#123;</span><span class="token number">32</span><span class="token operator">&#123;</span>data_A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span> <span class="token operator">&#123;</span>data_A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>></span> data_B<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span> <span class="token comment">// right</span><span class="token important">always</span> srlw <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> <span class="token operator">&#123;</span>data_A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>></span> data_B<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span>  <span class="token comment">// wrong</span><span class="token comment">// 存在特殊情况，如果data_A[31]为1，且data_B为0，srlw的高32位应该全为1.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果srlw指令中的data_B &gt;&#x3D; 1，srlw结果高32bit都为0，两种方式的结果一致；<br>如果srlw指令中的data_B &#x3D; 0，data_A的第32bit为0，两种方式结果一致；<br>如果srlw指令中的data_B &#x3D; 0，data_A的第32bit为1，两种方式结果不一致；第一种是正确的。</p><h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><h3 id="静态分支预测"><a href="#静态分支预测" class="headerlink" title="静态分支预测"></a>静态分支预测</h3><p>认为分支跳转或者不跳转，有50%的命中率。</p><img src="/2024/021950375/image-20240722200708161.png" alt="image-20240722200708161" style="zoom: 50%;"><h3 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h3><h4 id="两位饱和计数器"><a href="#两位饱和计数器" class="headerlink" title="两位饱和计数器"></a>两位饱和计数器</h4><p>连续两次跳转或者不跳转，下次才可以判断出 <strong>跳转或者不跳转</strong></p><p><img src="/2024/021950375/image-20240722201032850.png" alt="image-20240722201032850"></p><p>缺点</p><p><img src="/2024/021950375/image-20240722201703859.png" alt="image-20240722201703859"></p><h4 id="PHT（Pattern-History-Table）"><a href="#PHT（Pattern-History-Table）" class="headerlink" title="PHT（Pattern History Table）"></a>PHT（Pattern History Table）</h4><p>有很多两位饱和计数器，选择部分pc值（某些比特位）作为索引。</p><p><img src="/2024/021950375/image-20240722233858059.png" alt="image-20240722233858059"></p><p><img src="/2024/021950375/image-20240722201409392.png" alt="image-20240722201409392"></p><p><img src="/2024/021950375/image-20240722201420902.png" alt="image-20240722201420902"></p><h4 id="基于局部历史的分支预测"><a href="#基于局部历史的分支预测" class="headerlink" title="基于局部历史的分支预测"></a>基于局部历史的分支预测</h4><p>引入BHR（Branch History Register），使用BHR寄存器来记录有一条指令在过去的历史状态。首先，用指令（beq）的PC中的K位去寻找一个n位的BHR，n表示记录一个指令的n个历史结果。将BHR中n bits值和PC中t bits做一定的操作，查找PHT得到预测值。</p><p><img src="/2024/021950375/image-20240723003728648.png" alt="image-20240723003728648"></p><h4 id="基于全局历史的分支预测"><a href="#基于全局历史的分支预测" class="headerlink" title="基于全局历史的分支预测"></a>基于全局历史的分支预测</h4><p>引入GHR（Global History Register），记录所有跳转指令的结果。将GHR的数据和PC中某些bits做一定操作，索引PHT，得到预测值。</p> <img src="/2024/021950375/image-20240723003842439.png" alt="image-20240723003842439" style="zoom:50%;"><blockquote><p>参考</p><p><a href="https://yufoo1.github.io/docs/superscalar-processor-architecture/branch-prediction/#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E6%9B%B4%E6%96%B0">https://yufoo1.github.io/docs/superscalar-processor-architecture/branch-prediction/#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E6%9B%B4%E6%96%B0</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk用法</title>
      <link href="/2024/021721611.html"/>
      <url>/2024/021721611.html</url>
      
        <content type="html"><![CDATA[<h3 id="Awk处理文本数据"><a href="#Awk处理文本数据" class="headerlink" title="Awk处理文本数据"></a><strong>Awk处理文本数据</strong></h3><p>格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> ‘匹配规则和处理规则’  <span class="token punctuation">[</span>处理文本路径<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>处理规则：</p><p>BEGIN{}: BEGIN是在awk处理文本之前运行</p><p><strong>&#x2F; &#x2F; ： 使用的匹配原则</strong></p><p>{}：循环（每次处理一行）</p><p>END{}: 当所有行执行完毕后，执行END的操作</p></li></ul><p>原理：</p><ol><li><p>awk会接收一行作为输入，将这一行赋给awk的内部变量$0，行的边界是以换行符作为结束的。</p></li><li><p>刚刚读入的行被以:为分隔符分解成若干字段（或域），每个字段存储在已编号的变量中，编号从$1开始，最多达100个字段，-F 指定分隔符，默认是空格。</p></li><li><p>使用print打印，如果$1$3之间没有逗号，输出时贴在一起，如果添加”,”，$1和$3之间默认用空格分开，通过OFS修改输出的间隔符   ‘BEGIN{OFS&#x3D;”-“}{print $1,$3}’</p></li><li><p>输出后，获取下一行，执行上述操作</p></li></ol><h5 id="awk变量"><a href="#awk变量" class="headerlink" title="awk变量"></a><strong>awk变量</strong></h5><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">$<span class="token variable">0</span>:当前行的内容NR：行号NF: 总字段数FS：输入字段分隔符，默认空格OFS：输出字段分隔符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'&#123;if(NR > 7)&#123;print NR,$0&#125;&#125;'</span> /etc/passwd<span class="token operator">==</span> <span class="token function">awk</span> -F: <span class="token string">'NR > 7 &#123;print NR,$0&#125;'</span> /etc/passwd// 输出第7行之后的内容指定<span class="token string">','</span>作为分隔符，-F<span class="token string">','</span>-F:  ：表示以<span class="token string">':'</span>作为分隔符<span class="token function">awk</span> -F<span class="token string">':'</span> <span class="token string">'BEGIN&#123;FS=","&#125;&#123;print $1,$2&#125;'</span> FS的优先级大于-F指定的输出指定分隔符<span class="token function">awk</span> -F<span class="token string">':'</span> <span class="token string">'BEGIN&#123;OFS=" >>> "&#125;&#123;print $1,$2&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>正则表达式</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'/^xxx/'</span> /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>条件模式</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'NR > 7'</span> /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>算数运算</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'&#123;print $1,$2+1&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>if判断</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">单分支：<span class="token function-name function">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>双分支：<span class="token function-name function">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>多分支：<span class="token function-name function">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token function-name function">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> * <span class="token operator">|</span> <span class="token function">uniq</span>   剔除重复行<span class="token function">ls</span> * <span class="token operator">|</span> <span class="token function">sort</span> <span class="token parameter variable">-u</span> <span class="token function">wc</span> 行数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sed处理文本数据"><a href="#Sed处理文本数据" class="headerlink" title="Sed处理文本数据"></a><strong>Sed处理文本数据</strong></h3><p>非交互式的，流编译器sed。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token string">"command"</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>sed和grep不同，不管是否找到匹配的模式，退出都返回0.只有命令存在语法错误时返回1.<br>sed在文件查找模式中时，也可以使用正则表达式RE和各种元字符。正则表达式在斜杠&#x2F;&#x2F;之间。</p><p>扩展元字符集： ？，+，{}，|，()</p><img src="/2024/021721611/image-20240521094609655.png" alt="image-20240521094609655" style="zoom:50%;"><h6 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>-r<span class="token punctuation">]</span> 支持扩展元字符<span class="token punctuation">[</span>-i<span class="token punctuation">]</span> 修改源文件<span class="token punctuation">[</span>-n<span class="token punctuation">]</span> 取消默认输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"3&#123;d;&#125;"</span> filename <span class="token comment"># ;用来隔开命令 </span><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"/root/&#123;n;d&#125;"</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"s/root/alice/gi"</span> filename<span class="token comment"># g:global, i:ingore 大小写</span><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"s/[0-9]\&#123;2\&#125;$/#&amp;/"</span> filename<span class="token comment"># &amp;表示查找串中匹配到的内容  </span><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"s/root/&amp;LIU/g"</span>filename<span class="token comment"># 在root后面加LIU</span><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"s/^/#/"</span>filename <span class="token comment"># 在开头加 #</span><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"/root/&#123;n;s/bin/uuu/g&#125;"</span> filename <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"/root/d"</span> filename<span class="token comment">#d 删除</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h6><pre class="line-numbers language-none"><code class="language-none">sed -r &quot;2a111111&quot; filename #第二行后面追加111111 sed -r &quot;2i111111&quot; filename #第二行前面追加111111 sed -r &quot;2c111111&quot; filename #第二行替换·111111 sed -r &quot;2a111111\111111&quot;#第二行追加多行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="反向选择"><a href="#反向选择" class="headerlink" title="反向选择"></a>反向选择</h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"3d"</span> filename <span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"3!d"</span> filename <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-ri</span> <span class="token string">"<span class="token variable">$a123456789</span>"</span> filename<span class="token function">sed</span> <span class="token parameter variable">-ri</span> <span class="token string">"/^SELINUX=/cSELINUX=disaled"</span> filename  <span class="token comment">#查找SELINUX开头的行，并替换</span><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"2,6s/.*/#$/"</span> filename 添加注释<span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"2,6s/(.*)/#<span class="token entity" title="\1">\1</span>/"</span> filename 添加注释<span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"1,5s/^#*/#/"</span> filename 添加注释<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">决定对哪些行处理<span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"/root/,5d"</span> filename<span class="token comment">#root后，删除到第5行 </span><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"/root/,+5d"</span> filename  <span class="token comment">#root后，删除5行</span><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"/root/!5d"</span> filename  <span class="token comment">#取反删除</span><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"1,4d"</span> filename<span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"1~2d"</span> filename <span class="token comment">#删除奇数行</span><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"0~2d"</span> filename <span class="token comment">#删除偶数行以0行开始，间隔2行删除。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="模式空间和暂存空间"><a href="#模式空间和暂存空间" class="headerlink" title="模式空间和暂存空间"></a>模式空间和暂存空间</h4><p><img src="/2024/021721611/image-20240521135320324.png" alt="image-20240521135320324"></p><p>小写g和h是覆盖。小写G和H是追加。  暂存空间只有一个。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"1h;<span class="token variable">$G</span>"</span> filename<span class="token function">sed</span> <span class="token parameter variable">-r</span> <span class="token string">"1h;2,<span class="token variable">$g</span>"</span> filename <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="正则表达式RE"><a href="#正则表达式RE" class="headerlink" title="正则表达式RE"></a>正则表达式RE</h3><p>处理文本，做匹配。正则表达式放在两个双斜杠之间<code>//</code></p><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>^ ：匹配行开头<br>[0-9]：匹配数字<br>+：至少一个<br>$：匹配行结尾<br>. ：匹配任意单个字符<br>*：前导符出现0次或多次，*b &#x3D;&gt;    b, bb<br>.*：任意多个字符<br>[]：匹配指定范围内的一个字符，[Aa]<br>[ - ]：匹配指定范围内的一个字符，[a-z]<br>[ ^ ]：匹配不在指定范围内的一个字符，[^a-z]<br>\：转义元字符<br><strong>\&lt;：词首定位符**<br>**\&gt;：词尾定位符</strong><br>x\{m\}：字符重复出现m次   o\{5\}<br>x\{m,\}：字符重复出现m次以上<br>x\{m,n\}：字符重复出现（m,n）次<br>\(..\) ：后面匹配时所用到的标签 %s#\(10.2\).3#\1.4# </p><p>扩展正则表达式元字符</p><p>+：匹配一个或者多个前导字符<br>？：匹配零个或一个前导字符<br>a|b：匹配a或b<br>()：组字符 </p><img src="/2024/021721611/image-20240520220050065.png" alt="image-20240520220050065" style="zoom:33%;"><p>shell中的通配符 * ：任意多个字符，由shell来解析；shell中的<code>.</code>相当于正则中的<code>?</code>，匹配单个字符。<br>正则表达式元字符：由各种模式匹配操作的程序来解析，比如grep，sed，awk</p><p>grep中，匹配模式在“ ”之间指出，可以匹配多个文件。</p><h3 id="grep-文本处理"><a href="#grep-文本处理" class="headerlink" title="grep 文本处理"></a>grep 文本处理</h3><p>grep [选项] PATTERN filename1 filename2grep “\-v” filename<br>打印出匹配模式的行</p><p>返回值：0表示找到，1表示没找到，2表示找不到指定的文件</p><p>ps aux| grep “sshd”</p><p>\w  所有字母和数字 [0-9a-zA-Z]<br>\W 所有字母和数字之外的字符，非字符<br>\b  词边界\&lt;  &#x3D;&gt; \b</p><p>[-v] 取反<br>[-q] 静默<br>[-i]   忽略大小写<br>[-r]  递归文件夹的文件<br>[-o]  只显示匹配的内容<br>[-c]  匹配的上下文两行<br>[-a]  匹配的后两行<br>[-b]  匹配的前两行</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk文本处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机体系结构</title>
      <link href="/2024/012760393.html"/>
      <url>/2024/012760393.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>reference</p><p><a href="https://blog.csdn.net/qq_57502075/article/details/131935482?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_57502075/article/details/131935482?spm=1001.2014.3001.5502</a></p><p><a href="https://zhuanlan.zhihu.com/p/601688983">https://zhuanlan.zhihu.com/p/601688983</a></p></blockquote><h3 id="流水线类型"><a href="#流水线类型" class="headerlink" title="流水线类型"></a>流水线类型</h3><p>超流水线：<br>    通过增加流水线级数来缩短指令执行速度。细化流水，提高主频。用时间换空间。超流水线技术对芯片的工作速度要求比较高，同时硬件系统比较复杂，需要占用较大的芯片的面积，因此超流水线结构在嵌入式RISC处理器中很少采用。</p><p>超标量：<br>    一个时钟周期可以获取、译码多条指令，CPU中有一条以上的流水线，每个周期可以完成一条以上的指令。用硬件来换速度。分支预测会预测分支指令的结果，保证获取指令的过程不被中断。进入后续流水段的指令彼此之间有数据相关，需要对指令译码后，先用 <strong>寄存器重命名</strong>消除假相关关系，然后把命名过后的指令分配到”待发射区”（也叫保留站）。</p><p>处理器会同时“监视”待发射区&#x2F;保留站内所有指令的源数据的准备情况，只要源数据可用，指令就会被<strong>“发射”</strong>到功能单元开始执行。一般把处理器这种“监视然后择机发射”的行为称为<strong>“动态调度”</strong>。</p><p>指令执行完后，结果会被按照指令原始顺序排入一个FIFO队列中（也叫做ReOrder Buffer，ROB），这个过程会把乱序执行的指令恢复成原始顺序，被称为“重排序”，处理器每周期提交队头若干条指令的结果，通过这种方式可以实现<strong>“精确中断”</strong>。</p><p>相对于标量流水线，超标量最大的优点的提高了指令并行度，每个周期可以执行多条指令，提高指令的吞吐量。</p><h3 id="数据相关性"><a href="#数据相关性" class="headerlink" title="数据相关性"></a>数据相关性</h3><p>CPU中，一段程序会被编译成一连串的汇编指令，指令与指令之间具有相关性。一条指令的结果会影响或依赖于上条指令的结果。</p><ol><li>写后写 WAW</li></ol><p>​两条指令都将结果写入同一个目的寄存器。</p><ol start="2"><li><p>读后写 WAR</p><p>读指令和写指令的目的寄存器是一样的。</p></li><li><p>写后读RAW</p></li></ol><p>​真相关，一条指令的源寄存器来自于上条指令写的结果。</p><p><strong>处理器内部实际存在的寄存器称为物理寄存器（Physical Register）</strong>，<strong>指令集中定义的寄存器称为逻辑寄存器（Logical Register）或者架构寄存器（Architecture Register）</strong>，解决相关性的目的是为了程序的并行性。</p><p>对于写后写和读后写相关， 解决办法就是用硬件来管理寄存器的重命名。逻辑寄存器和物理寄存器之间，通过重命名映射表保存映射关系，对于程序中的指令，源寄存器通过映射表找到对应的物理寄存器。</p><p>e.g.</p><img src="/2024/012760393/ef7954cbfc134075922c6745ab44f752.png" alt="img" style="zoom: 33%;"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> 在R2=R1+R0执行时，重命名映射表将R2映射到了物理寄存器p2上，将R1+R0的结果写到p2中。<span class="token list punctuation">2.</span> 在执行第二行指令，对R2逻辑寄存器进行WAW的时候，更新重命名映射表，将R2映射到物理寄存器p4上，然后将R1×R0的结果写到p4中。<span class="token list punctuation">3.</span> 执行第三行指令，需要读取R2逻辑寄存器做加法，此时就会去查询重命名映射表，发现R2映射到了p4物理寄存器，所以其实就会去读取p4寄存器的值（R1×R0），然后再做加法。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>icc_flow</title>
      <link href="/2024/012139355.html"/>
      <url>/2024/012139355.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>decap cell的插入</p><p>解决IR drop的，为逻辑单元提供稳定的电压。去耦电容，提供稳定的电源和地，降低电源噪声和提高电噪声免疫性的特殊电路元件。<br>Decap cell是小电容器，位于整个布局的VDD和GND之间。当逻辑电路汲取大量电流时，该电容器为该电路提供额外的电荷当逻辑电路不吸收任何电流时，decap cell被充电至最大电容利用decap cell来降低动态IR drop。<br>decap cell是带金属层的，建议routing结束后再加，否则影响route走线。</p></li></ul><img src="/2024/012139355/image-20240121233331816.png" alt style="zoom:50%;"><ul><li><p>filler cell</p><p>为确保所有VDD和VSS rail连接正常，我们需要使用filler cell填充标准单元row中的空白区域。filler cell没有逻辑连接，同时还包含衬底nwell连接以改善衬底偏置。</p></li></ul><p>​在routing后进行的，先插入decap cell，再插入filler cell</p><p>​插完decap cell和filler cell之后，我们可以发现整个设计都被cell给填充了，可以把芯片的表面做平，<strong>在stdcell区域是不允许有间隙的存在的</strong>，也可以用命令checkFiller来检查。</p><p>​<strong>作用：</strong></p><ol><li><p><strong>平整表面</strong>：在后续的工艺步骤中，便于后续工艺的抛光。</p></li><li><p><strong>获得连续的VDD和VSS</strong></p></li><li><p>保证版图连续性和均匀性，保证掺杂均匀性，减小工艺变异，增强结构稳健性。</p></li><li><p><strong>优化功耗和性能</strong>：通过在空白区域添加 Filler Cells，电流路径可能会更均匀，有助于减少电磁干扰和功耗。</p></li></ol><ul><li><p>dummy</p><p>主要有以下几种用途：</p><ol><li>保证可制造性，DFM。tapeout时会检查芯片的密度，插入dummy mental，dummy poly，dummy diff</li><li>在关键器件旁边加入dummy 器件，比如cap，res，mos等</li><li>避免芯片中的noise对关键信号的影响，在关键信号的周围加上dummy routing layer或者dummy元器件，shielding。</li></ol></li><li><p>获取整个design的instance个数和面积</p><p>report_qor</p><img src="/2024/012139355/image-20240123212321424.png" alt style="zoom:67%;"><img src="/2024/012139355/abc207bf21bdcaa65b8339f664292df.jpg" alt style="zoom: 33%;"></li></ul><p>​gate count计算：等效的门数，只是一个粗略的计算，不是精确值。将两输入与非门的面积作为等效参考，即一个gate的面积。用所有std cell的面积除以2输入与非门的面积，得到是数值为用到的总门数。总门数*4得到的是晶体管数目。</p><blockquote><p>DC综合两输入与非门的面积为1.44，所有cell的总面积为41.2w平方微米。等效门数为41.2&#x2F;1.44 &#x3D; 28.61w逻辑门。</p></blockquote><ul><li><p>查看clock skew的值</p><ol><li><p>通过report_timing</p><p>得到的skew会偏大一些，因为skew经过derate。</p></li><li><p>通过report clcok tree</p></li></ol></li><li><p>clock skew的设置</p><p>在长时钟树时，要设置targe skew，告诉工具clock skew期望值多少，一般设置为50-80ps，100ps以内都正常。</p></li></ul><p>ICC cts的相关设置</p><p><a href="https://www.cnblogs.com/IClearner/p/6606360.html">https://www.cnblogs.com/IClearner/p/6606360.html</a></p><ul><li><p>wire spreading（连线扩展）</p><p>也成为critical area analysis关键区域分析的地方</p><p>bg：制造过程中可能会出现随机的颗粒缺陷导致短路或者开路<br>最小间距的连线最容易造成短路，最小宽度的连线最容易造成开路。</p><p>解决办法：容易短路的地方，增加间距。容易断路的地方，增加线宽。</p><img src="/2024/012139355/20200729093453667.png" alt style="zoom: 67%;">icc_tcl:  spread_zrt_wires / widen_zrt_wires</li><li><p>检查placement是否合法</p></li></ul><p>​placement后，执行<code>check_legality</code></p><ul><li>ICC 在导入网表后，没有tie cell是正常的，因为是在placement才加入tie cell；High Fanout Net也是正常的，还没有插入buffer进行优化。</li></ul><img src="/2024/012139355/image-20231224214002120.png" style="zoom: 67%;"><ul><li>后端流程</li></ul><img src="/2024/012139355/image-20231224215828226.png" alt style="zoom:67%;"><ul><li>时序库 （*.lib， *db）表征的2个模型</li></ul><p>​.NLDM (non linear delay model)，65nm 之前工艺 </p><p>​.CCS （composite current source）, 更精确，同时能描述crosstalk （信号干扰）的信息 </p><ul><li>max_transition &#x2F; input_transition</li></ul><p>​一般来说，sdc中关于max_transition的值参考lib库中给定的transition值，尽量取中间范围。transition设置的过小也不好，会导致工具插入很多cell，增大了芯片的面积。</p><p>​解决措施：在DC和ICC时设置max_transition为0.4，在PT时设置0.6</p><p><img src="/2024/012139355/3158545f6cb70988f94b0214218380a.jpg"></p><p>出现上述问题的原因是因为在做lvs时，网表与版图不匹配，可以将icc生成的网表导入到calibre里面做lvs。在icc pr后的网表中，在module里面并没有上述的Q端口，而是使用的Qn，接一个反相器输出的，这个是和版图对应的。</p><p>CCS的lib中有 crosstalk的信息；</p><p>物理信息库<br>     1. LEF(library exchange format): cadence 的物理信息库，只有布局布线要用到信息，pins…<br>     2. milkway：synopsys的物理库<br>     3. GDS：流片用的信息，所有的层次都有<br>     4. CDL：器件级spice网表，lvs和仿真</p><p><img src="/2024/012139355/wps2.jpg">（LEF GDS)</p><p>DC在做综合的时候，把DRC的约束优先级设置为最高，依次是：max_capacitance,max_transition, max_fanout</p><p>DC中报告的漏电功耗是准的，动态功耗不准。</p><ul><li><h4 id="Formality"><a href="#Formality" class="headerlink" title="Formality"></a><strong>Formality</strong></h4><p>只验证逻辑，不验证功能。比较的原理：formality将设计分为多个logic cone和compare point</p><img src="/2024/012139355/image-20240102224954497.png" alt style="zoom: 80%;"></li></ul><p><img src="/2024/012139355/image-20240102225055027.png"></p><ul><li><p>DC和PT分析时序路径的不同</p><p>DC</p><ol><li>过约束，留出一定的裕量给后续的步骤</li><li>时钟网络的延迟的不准确的，一定设置为ideal clock network</li><li>线延迟也是基于库中的wire load model估计出来的</li><li>通常在单一PVT的corner进行的，比如wc</li></ol><p>ICC</p><ol><li>不需要过约束，根据实际的电路计算</li><li>所有网络 clock，wire network均为实际的</li><li>可以从版图中抽取RC寄生参数，计算net delay</li><li>需要在多个PVT corner下验证</li></ol></li><li><p>修复setup违例</p><p>满足 Tskew + Tclk &gt; Tlogic + Tsetup + Tclk2q</p><ol><li>提高Tclk，降低频率</li><li>减小Tlogic，优化组合逻辑，划分流水线</li><li>减小Tclk2q，将HVT管换成LVT管子，速度变快</li></ol></li><li><p>修复hold违例</p><p>满足Tclk2q + Tlogic(min) &gt; Thold + Tskew</p><ol><li>增加组合逻辑延迟，插入buffer</li><li>降低Tskew，甚至用负的skew</li></ol></li></ul><p>SDF：标准延迟格式的文件，描述了设计中的时序信息，包括net delay和cell delay，sdf文件可以直接用于后仿</p><p>SPEF：标准寄生格式交换文件，提供具体的R和C参数，延时计算相对准确。</p><p><img src="/2024/012139355/image-20240103100523201.png"></p><p>在PT中设置clock约束时和DC的区别</p><p><img src="/2024/012139355/image-20240103100716030.png"></p><p><img src="/2024/012139355/image-20240103101023594.png"></p><p>ECO是在post layout上进行的。</p><p>PT自动进行ECO，PT工具主要通过resizing cells和插入buffer来完成ECO</p><ul><li><p>OCV</p><p><strong>只在post layout进行分析。</strong></p></li><li><p>约束输入端口</p><pre class="line-numbers language-none"><code class="language-none">set_drive_cellset_driveset_input_transition<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这三条语句都是约束输入端口的，但是适用场景不同。</p><ol><li><p>set_drive_cell</p><p>应用场景：Block level<br>从库中找一个cell来驱动这个模块的输入端口port，更贴近实际的情况。这种应用于模块级别的。</p></li><li><p>set_drive</p><p>应用场景：Chip level<br>通过为输入端口指定电阻值的方法来为其定义外部驱动强度，典型的值是0.05，单位取工艺库中电阻的单位，一般为kΩ；该值越小表示驱动能力越大</p></li><li><p>set_input_transition</p><p>应用场景：Chip level<br>为输入端口指定一个固定的transition时间，transition时间相对独立于当前设计中的电容。transition time越大，导致短路电流越大，功耗也越大。</p></li></ol></li><li><p><strong>课题组项目后端的细节处理</strong></p><ol><li>在版图布局中，由于SPI模块与数字芯片core的位置距离较远，需要对数字芯片CORE的输入端口进行约束，设置input_transition_time为0.5；并在SPI的输入端口添加模拟的buffer，提高驱动能力。</li><li>在之前的芯片测试时，发现控制字的输入有问题，有时候需要SPI写入两次才能起作用。后来怀疑是SPI模块给到数字core的时钟信号走线太长，到core时候，clk的驱动就比较弱了。再后面的流片时，在数字core的clk输入端口加了buffer，解决了这个问题。</li></ol></li><li><p>IR drop</p><p>电阻对电流有阻碍作用，而导致电压下降；<br>大电流或者长导线会带来IR drop，通常在芯片的电源和地中出现。</p></li></ul><p>ICC在global routing绕线期间，以GRC为为最小单位安排走线。</p><p>report_congestion报告会计算每个GRC的 # of available routing tracks（#1）和 # of nets crossing GRC edge（#2），如果#2大于#1，就存在overflow，即走线资源不足。而congestion报告会给出每个方向以及每一层存在overflow问题的GRC数量（及百分比），overflow总数和单个GRC max的overflow数量，根据这些数据可以判断congestion的情况。如果有GRC的overflow大于10，则可能走线走不通，如果有2%或者更多的GRC存在overflow，那么可能会出现SI和timing的问题。</p><h3 id="修复违例"><a href="#修复违例" class="headerlink" title="修复违例"></a>修复违例</h3><p>place_opt之后，如果有小的setup违例，可以使用<code>psynopt</code>命令修复</p><h4 id="Signoff-Items"><a href="#Signoff-Items" class="headerlink" title="Signoff Items"></a>Signoff Items</h4><ul><li>DRC</li><li>LVS</li><li>timing signoff</li></ul>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StarRC_flow</title>
      <link href="/2024/012044084.html"/>
      <url>/2024/012044084.html</url>
      
        <content type="html"><![CDATA[<p>根据TSMC signoff的标准</p><p><img src="/2024/012044084/image-20240120174002288.png"></p><p>整理如下：</p><table><thead><tr><th><strong>setup</strong></th><th>process</th><th>voltage</th><th>tempature</th><th>library db</th><th>spef</th></tr></thead><tbody><tr><td>wc+Cworst</td><td>ss</td><td>1.08v</td><td>125</td><td>tcbn65lpwc1d081d08_ccs</td><td>Cworst125</td></tr><tr><td>wcl+Cworst</td><td>ss</td><td>1.08v</td><td>-40</td><td>tcbn65lpwcl1d081d08_ccs</td><td>Cworstm40</td></tr><tr><td><strong>tc+Ctypical</strong></td><td><strong>tt</strong></td><td><strong>1.2v</strong></td><td><strong>-40</strong></td><td><strong>tcbn65lplt1d21d2_ccs</strong></td><td><strong>Ctypical25</strong></td></tr><tr><td><strong>hold</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>wc+Cworst</td><td>ss</td><td>1.08v</td><td>125</td><td>tcbn65lpwc1d081d08_ccs</td><td>Cworst125</td></tr><tr><td>wcl+Cworst</td><td>ss</td><td>1.08v</td><td>-40</td><td>tcbn65lpwcl1d081d08_ccs</td><td>Cworstm40</td></tr><tr><td><del>bc+Cworst</del></td><td><del>ff</del></td><td><del>1.32v</del></td><td><del>0</del></td><td><del>tcbn65lpbc1d321d32_ccs</del></td><td><del>Cworst0</del></td></tr><tr><td><del>bc+Cbest</del></td><td><del>ff</del></td><td><del>1.32v</del></td><td><del>0</del></td><td><del>tcbn65lpbc1d321d32_ccs</del></td><td><del>Cbest0</del></td></tr><tr><td>lt+Cworst</td><td>ff</td><td>1.32v</td><td>-40</td><td>tcbn65lplt1d321d32_ccs</td><td>Cworstm40</td></tr><tr><td><strong>lt+Cbest</strong></td><td>ff</td><td>1.32v</td><td>-40</td><td>tcbn65lplt1d321d32_ccs</td><td>Cbestm40</td></tr><tr><td><strong>tc+Ctypical</strong></td><td><strong>tt</strong></td><td><strong>1.2v</strong></td><td><strong>-40</strong></td><td><strong>tcbn65lplt1d21d2_ccs</strong></td><td><strong>Ctypical25</strong></td></tr></tbody></table><blockquote><p>删除的bc+Cbest&#x2F;Cworst，原因是这两种case位于wc和lt之间，没必须再去分析。</p></blockquote><p>Q：在检查hold违例时，lt+Cbest下已经保证了组合逻辑是最短的，为什么要进行Cworst的组合？</p><p>因此，lt仅仅是满足了路径上组合逻辑的延迟，而时钟网络的延迟带来的skew对hold检查也非常重要，所以要进行Cworst检查。</p>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StarRC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcl脚本</title>
      <link href="/2024/011824060.html"/>
      <url>/2024/011824060.html</url>
      
        <content type="html"><![CDATA[<p>set endp xxx&#x2F;D</p><p>set path [get_timing_path -to $endp -group reg2reg]</p><p>set points [get_attri $path points]</p><p>point有很多属性</p><img src="/2024/011824060/image-20240118232406988.png" alt style="zoom:50%;"><pre class=" language-tcl"><code class="language-tcl">foreach_in_coll point $<span class="token variable">points</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token keyword">set</span> <span class="token variable">obj</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">point</span> object<span class="token punctuation">]</span>     <span class="token keyword">set</span> <span class="token variable">objn</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">obj</span> full_name<span class="token punctuation">]</span>    <span class="token keyword">set</span> <span class="token variable">dir</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">obj</span> dir<span class="token punctuation">]</span>    <span class="token builtin">if</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;dir=="in"&amp;#125; &amp;#123;continue&amp;#125;</span>    <span class="token keyword">set</span> <span class="token variable">inst</span> <span class="token punctuation">[</span><span class="token keyword">file</span> dir $<span class="token variable">objn</span><span class="token punctuation">]</span>    <span class="token keyword">set</span> <span class="token variable">cell</span> <span class="token punctuation">[</span>get_cell $<span class="token variable">inst</span><span class="token punctuation">]</span>    <span class="token keyword">set</span> <span class="token variable">ref</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">cell</span> ref_name<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token builtin">proc</span> <span class="token function">is_hvt</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;ref&amp;#125; &amp;#123;</span>    <span class="token builtin">if</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;string match "*_HVT" $ref&amp;#125; &amp;#123;</span>        retrun 1    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125; else &amp;#123;retrun 0&amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token comment" spellcheck="true"># if &amp;#123;![is_hvt $ref] || ![is_lvt $ref]&amp;#125; &amp;#123;&amp;#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tcl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PT flow</title>
      <link href="/2024/011821871.html"/>
      <url>/2024/011821871.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>检查反标率</p><p>跑PT时，需要保证每个corner使用的lib和spef是对应的。读入设计的spef和网表netlist后，需要report_annotated_parasitics命令报出反标情况。</p></li></ul><p>​反标问题我们是看Pin to pin nets的反标，如果这一行的Not Annotated非0，那么就一定存在RC反标问题。常见反标问题原因：</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">spef正确，但netlist错误Netlist正确，spef错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2024/011821871/image-20240118192337980.png" alt style="zoom: 50%;"><p>手修timing</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">size_cell U324 INVD8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>setup </p><p>替换大驱动的cell。 x4 &#x3D;&gt; x16<br>(有时候替换了大cell，delay会增加，因为驱动能力的增加不足以抵消input transition和output load的增加)</p></li><li><p>max_capacitance </p><p>方法1：替换大的cell，提高阈值。<br>方法2：减小实际的capacitance，通过在ICC中插入buffer实现</p></li><li><p>max_transition</p><p>方法1：替换大的cell，提高阈值。<br>方法2：减小实际的transition，通过在ICC中插入buffer实现</p></li><li><p>hold</p><ul><li>get_lib_cell  *&#x2F;*BUF*</li><li>insert_buffer [通过report_timing -delay_type min 得到的] *BUF*</li></ul></li></ul><p> report_constraint  -all_violators：可以看出违例的endpoint  summary</p><p>syn off :关闭高亮显示</p><p>查看某个net连接的cell：all_fanout -from U503&#x2F;E -flat -endpoints_only</p><p>report_timing -transition -from U399 -delay_type max:可以查看具体的cell</p><h3 id="timing-eco"><a href="#timing-eco" class="headerlink" title="timing eco"></a>timing eco</h3><p>修违例的顺序：1. drc的错误 2. 再修setup hold</p><p>尽可能使用size_cell来修违例，而不用insert_buffer，因为RC是准确的，保证net delay是对的。</p><p>如果想运行dmsa，那么在启动pt的时候，必须加上-mul选项启动多线程，不然是无法进行dmsa优化的。</p><p>在icc中，摆放eco 的cell</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl"><span class="token keyword">source</span> iccpt.tcllegalize_placement <span class="token operator">-</span>eco <span class="token operator">-</span>incremental route_zrt_eco <span class="token operator">-</span>utilize_dangling_wires true <span class="token operator">-</span>reuse_existing_global_route true <span class="token operator">-</span>open_net_driven true save_mv_cel <span class="token operator">-</span>as eco_routed <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在ICC中打开mw_lib中的cell</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl"><span class="token keyword">source</span> xxx.setupopen_mw_lib ..<span class="token operator">/</span>..<span class="token operator">/</span>XXX.libopen_mw_cell FMCW_DCORE_TOP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>max_transition设置</strong></p><p>signoff的标准是0.6，在pr阶段一般会过约束，可以将data_path设置为0.5，clock上设置为0.45，而clock path的max transition在cts之前再约束sdc里面就不再单独设置。</p></li></ul><p>ICC中修复hold time</p><ol><li><p>cts之前</p><p>psynopt -only_hold_time</p></li><li><p>routing阶段<br>指定布线优化选项来修复<br>route_opt -incr -only_hold_time</p></li><li><p>chipfinish</p><p>3.1 可以用CCD来修复：</p><p>&gt;focal_opt -concurrent_clock_and_data -hold_endpoints all</p><p>3.2可以让软件自动对所有hold endpoints来修复：</p><p>&gt;focal_opt -hold_endpoints all -effort high</p><p>其实可以指定某些hold endpoints来单独对它们进行优化，但是自己尝试发现没有什么用，没有PT效果那么好。</p><p>3.3 指定REG2REG路径进行修复</p><p>如果违规都集中在REG2REG的路径上，那么用下面的命令更好：</p><p>&gt;focal_opt -hold_endpoints all -register_to_register</p></li></ol><p>​3.4 手工ECO修复</p><p>​如果上述方法都不行的话，就需要手动插入buffer或者delay cell来解决了，即采用ECO的方法来手工解决。在插入之前要确保没有插入Core filler，或者有Filler的话要remove，需要注意的是不用全部remove，在放置eco cell的命令的后边会有移除部分filler的选项哟，这个非常棒。</p><p>3.5 用PT进行ECO修复</p><p>​当然这些也是可以不用手工ECO的方法，而将整个设计的网表、spef导入PT，让PT自己修复，然后导出ECO的脚本，然后将脚本导入ICC进行修复，不过感觉这个过程挺麻烦的，还不如手工来的方便，具体方法可以参见ICCECO流程那一部分。</p><h5 id="记录修复timing-removal的错误"><a href="#记录修复timing-removal的错误" class="headerlink" title="记录修复timing-removal的错误"></a>记录修复timing-removal的错误</h5><p>2024&#x2F;1&#x2F;23<br>尝试使用pt的dmsa模式修复hold time时，发现有removal的违例，很是震惊。从来没遇到过</p><img src="/2024/011821871/image-20240123205008592.png" alt style="zoom: 67%;"><p>之前clock_uncertainty的值不太对，只是修改了这个地方。就出现了recovery的违例。以为是这里的问题，修改后，发现还是有removal的违例，然后一阵搜资料。最后查看了pt 违例的timing path，发现是pt的sdc里面的input&#x2F;output delay设置的太小。导致有大量的removal违例。（类比于hold）。相当于数据保持的时间太多，不满足removal检查。</p><p>将input output delay设置好后（之前是0.35，修改为3.5。在ICC中也是3.5），removal没有违例。</p><img src="/2024/011821871/image-20240123211117779.png" alt style="zoom:67%;"><img src="/2024/011821871/eb5a2b0dce25b2ed55c869128fdd6f0.jpg" alt style="zoom: 33%;"><ul><li><p>recovery</p><p>如果report_timing的path，-end指向的是DFF的D端，则是分析setup，如果是DFF的rst端，则是recovery。</p></li><li><p>电路后仿真</p></li></ul><p>​在后仿真时，需要吃sdf文件。sdf文件既可以是ICC产生的，也可以是PT生成的。在进行带有延迟反标的仿真时，需要注意两个延迟文件之间的区别。<br>​在仿真激励tb中，使用系统函数$annotated来完成延迟反标。<br>​延迟反标的参数，有三种类型：最大、最小和典型。在ICC和PT导出的sdf文件中，每一个gate同样有三个参数。<strong>注意的是，如果不设置延迟反标的类型，会中间的默认典型值，ICC导出的sdf里面典型值不为0，PT导出sdf文件典型值为0，因此如果在使用annotated时，不指定最大最小延迟，默认典型延迟，在波形图中就不会有组合逻辑造成的多次信号跳变，导致延迟参数反标不上去</strong></p><p>icc的sdf文件</p><p><img src="/2024/011821871/image-20240127193058698.png"></p><p>pt吐出的sdf文件</p><p><img src="/2024/011821871/image-20240127193134312.png"></p><p>​措施：在使用annotated函数时，指定max&#x2F;min延迟类型，其中max用于setup检查，min用于hold检查。</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">$<span class="token variable">sdf_annotate</span> <span class="token punctuation">(</span>“sdf_file”<span class="token punctuation">[</span>, “module_instance”<span class="token punctuation">]</span> <span class="token punctuation">[</span>,<span class="token operator">/</span><span class="token operator">/</span> 实例化“sdf_configfile”<span class="token punctuation">]</span><span class="token punctuation">[</span>,  <span class="token operator">/</span><span class="token operator">/</span> 一般缺省“sdf_logfile”<span class="token punctuation">]</span><span class="token punctuation">[</span>, <span class="token operator">/</span><span class="token operator">/</span> 指定vcs保存errors和warnings的log文件,<span class="token punctuation">(</span>modelsim没有这个选项<span class="token punctuation">)</span>“mtm_spec”<span class="token punctuation">]</span> <span class="token punctuation">[</span>,<span class="token operator">/</span><span class="token operator">/</span> 指定延迟类型，MINIMUM<span class="token punctuation">(</span>min<span class="token punctuation">)</span>, TYPICAL<span class="token punctuation">(</span>typ<span class="token punctuation">)</span>,MAXIMUM<span class="token punctuation">(</span>max<span class="token punctuation">)</span>“scale_factors”<span class="token punctuation">]</span><span class="token punctuation">[</span>,  <span class="token operator">/</span><span class="token operator">/</span> 缩放因子，默认1:1:1“scale_type” <span class="token operator">/</span><span class="token operator">/</span> 指定缩放之前延迟值得来源,“FROM_TYPICAL”,“FROM_MIMINUM”, <span class="token operator">/</span><span class="token operator">/</span> “FROM_MAXIMUM<span class="token string">"和"</span>FROM_MTM” <span class="token punctuation">(</span>default<span class="token punctuation">)</span>.<span class="token operator">/</span><span class="token operator">/</span> FROM_MINIMUX 选择SDF文件中mininum timing，组合逻辑的延时最小，侧重于hold time 的检查<span class="token operator">/</span><span class="token operator">/</span> FROM_TYPICAL 选择SDF文件中typical timing<span class="token operator">/</span><span class="token operator">/</span> FROM_MAXIMUM 选择SDF文件中maximum timing，组合逻辑的延时最大，侧重于setup time的检查<span class="token punctuation">]</span><span class="token punctuation">)</span>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在后仿过程中，需要care的点<ol><li>input 端口都要给定值，不能floating不给初值，否则内部出现x态。</li><li>激励中的时钟频率，不能超过STA时的。</li><li>有些信号是反逻辑，可能和前仿的信号不一致</li><li>如果出现了setup的违例导致功能错误，可以对比STA中path的delay与波形的delay是否一致</li></ol></li></ul><p>由于集成电路制造工艺的差异，实际电路中器件的延迟总会在一定范围内波动。Verilog 中，用户不仅可以指定 3 种类型的门延迟，还可以对每种类型的门延迟指定其最小值、典型值和最大值。</p><ul><li><p>后仿的各种组合情况</p><p>PVT_corner + fast&#x2F;typical&#x2F;slow SDF</p></li></ul><h4 id="后仿debug"><a href="#后仿debug" class="headerlink" title="后仿debug"></a>后仿debug</h4><p><code>2024/4/20 </code><br>现象：仿真开始没有x态，经过一次chirp后出现x态。<br>原因：在tb中，异步复位信号是直接给进去的，复位信号在释放时导致亚稳态的产生(上升沿和异步复位释放在同一时刻)，将该亚稳态传播下去，在某些特定条件下触发。<br>解决办法：<strong>同步复位，异步释放。</strong></p><ul><li><p>ECO</p><p>在芯片设计完成后，用于修复出现的问题。分为两个阶段：pre-mask ECO和post-mask ECO；</p></li></ul><p>​pre-mask ECO ：在设计完成后芯片还未进入工艺制造前所进行的修改。该流程的主要目的是解决设计中存在的问题，如电路逻辑不正确、功耗太高或者时序不满足等问题。</p><p>​ post-mask ECO ：设计团队需要将已制作的芯片样品反馈回来进行修改，从而修复设计中的问题。通常，post-mask ECO 采用物理层面上的修改来解决问题，例如通过引入金属连接或者改变物理结构等方式进行修复。</p>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步复位和同步复位</title>
      <link href="/2023/122543491.html"/>
      <url>/2023/122543491.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>常用的复位方式</p><ol><li>带同步复位的寄存器后紧跟一个不带复位的寄存器</li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>q1 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">begin</span>q1 <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span>q2 <span class="token operator">&lt;=</span> q1<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// 错误的复位方式    q2没有被正确的复位，并且综合生成的电路也非常奇怪。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/122543491/image-20231225203911890.png" alt style="zoom: 33%;"></li></ul><p>​因为在rst_n有效时，q2没有动作，所以rst_n作为第二级寄存器的ld_en信号，将q1的结果输出在q2上。</p><p><strong>正确的code style</strong></p><pre class="line-numbers language-none"><code class="language-none">always @(posedge clk) beginif(!nrst)q1 &lt;&#x3D; 0;else q1 &lt;&#x3D; d;endalways @(posedge clk)q2 &lt;&#x3D; q1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/122543491/image-20231225204528665.png" alt style="zoom: 33%;"><p><strong>同步复位</strong>：复位信号，只在clk的有效边沿才会发挥作用，参与输入信号d的组合逻辑，相当于做“与”逻辑。这种情况下，if-else的优先级就很重要。reset需要在if中发挥作用。</p><p>使用同步复位出现的问题：综合工具DC无法分辨复位信号和其他数据信号。<br>带同步复位的可加载触发器如下</p><img src="/2023/122543491/image-20240220164819082.png" alt style="zoom:50%;"><p>​综合工具也可能会综合成下面的结构，两者实现的功能相同。</p><img src="/2023/122543491/image-20240220164859844.png" alt style="zoom:50%;"><p>​第二种方式在门级仿真时，如果rst_n信号为低，mux的输入都是0，如果load是x态，导致触发器会输出x态，而不会复位。<strong>本质区别是 rst_n的优先级，第一种方式rst_n的优先级要高于第二种，第一种可以保证在仿真时复位的有效性</strong>，这两种方式在实际硬件中，都是可以正常复位的。因此，在仿真过程中，使用编译指令，告知综合工具，让复位信号rst_n尽可能靠近触发器，提高复位信号的优先级。</p><p><strong>优点：</strong></p><pre><code>1. 可以使用基于周期仿真的模拟器，比如verilator。2. 确保了所有的电路都是同步的。3. 由于是时钟有效时，才可以复位，所以可以过滤一些reset的毛刺。</code></pre><p><strong>缺点：</strong></p><ol><li>同步复位可能需要脉冲展宽器来保证复位脉冲足够宽</li><li>对于时钟门控的寄存器，同步复位无效。</li></ol><ul><li><strong>三态总线的复位</strong></li></ul><p>为了防止芯片上电时，内部三态总线上的总线竞争，就迫切需要时钟产生复位；</p><p>因此，芯片需要具有异步复位的功能。</p><img src="/2023/122543491/image-20231225235555437.png" alt style="zoom: 33%;"><p>也可以使用同步复位的方式实现，但是也必须使用复位信号直接撤销三态门的使能，寄存器的输出必须与rst_n做与；</p><img src="/2023/122543491/image-20231225235658088.png" alt style="zoom: 33%;"><h4 id="异步复位"><a href="#异步复位" class="headerlink" title="异步复位"></a>异步复位</h4><p>​异步复位可以保证 数据路径上没有复位信号的参与，在复位时，数据路径是干净的。</p><p>​异步复位最大的问题是 复位信号的释放。</p><p>​在DC阶段，对于clock和reset信号，通过设置输入驱动为0，表示驱动能力最强，<code>set_drive 0</code>。并设置<code>set_dont_touch_network</code>保护clk和reset信号不被修改。这样做的目的是 因为综合时，没有布局布线信息，在dc时即使插入buffer对clk和reset信号优化，也是没有意义的，到ICC阶段也会重新插buffer。反而，可能会对物理实现带来负面影响。所以最好的办法是不处理，在CTS时才真正的解决clk和reset。</p><p><strong>优点：</strong></p><pre><code> 1. 保证复位信号不会参与到数据路径中，保证数据路径是干净的。 2. 不需要时钟，就可以进行电路的复位。</code></pre><p><strong>缺点：</strong></p><ol><li>不能使用基于周期的仿真器</li><li>异步复位时，不会有亚稳态的影响，但是在释放时，很有可能clk是上升沿会采到rstn在变化，造成亚稳态。导致复位后的稳定状态丢失。</li><li>会受到毛刺的影响</li><li>异步复位 带来时序分析的困难</li></ol><ul><li><p>异步复位和异步置位寄存器</p><p>尽可能避免出现该类型的寄存器，否则，可能会造成综合前后结果不一致的问题。</p></li></ul><p>异步复位需要考虑recovery time和removal time的违例。</p><p>recovery time类似于setup time，在有效时钟沿上升之前，rst发生变化的最短时间。</p><p>removal time类似hold time，在有效时钟沿上升之后，rst发生变化所需要的最短时间。</p><ul><li><p>key points</p><p><strong>每个使用异步复位的ASIC电路，都应该包括复位同步器电路</strong>，也就是异步复位，同步释放。</p><p>异步复位同步器综合了两者的优点，</p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>nrst1 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>nrst2 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>nrst1 <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>nrst2 <span class="token operator">&lt;=</span> nrst1<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span>第二级的nrst2是为了消除，第一级异步复位信号释放带来的任何亚稳态。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/122543491/image-20231226100118399.png" alt style="zoom:50%;"><ul><li><p><strong>异步复位毛刺过滤器</strong></p><p>通过延迟电路，将延迟前后的信号做”与”，即可得到真正的复位信号。</p><img src="/2023/122543491/image-20240220172053034.png" alt style="zoom: 50%;"></li></ul><h5 id="容易出现的问题"><a href="#容易出现的问题" class="headerlink" title="容易出现的问题"></a>容易出现的问题</h5><ul><li>异步复位容易产生毛刺，导致整个电路发生复位；<br>解决办法：使用毛刺过滤电路；<br>对于时序逻辑的复位信号，当有连续周期的reset时才进行复位；<br>对于组合逻辑的复位信号，使用reset_delay &amp; reset_delay10ns判断复位；</li><li>复位信号的扇出很大，需要特殊考虑<br>解决办法：和cts一样处理；</li></ul><p>FPGA通常使用 “<strong>同步复位</strong>“处理，原因：异步复位占用更多的布线资源，导致难以满足时序性能要求。</p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><blockquote><p>《 硬件架构的艺术 数字电路的设计方法与技术》</p><p><a href="https://zhuanlan.zhihu.com/p/104550266">https://zhuanlan.zhihu.com/p/104550266</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="/2023/11277120.html"/>
      <url>/2023/11277120.html</url>
      
        <content type="html"><![CDATA[<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="Makefile的运行"><a href="#Makefile的运行" class="headerlink" title="Makefile的运行"></a>Makefile的运行</h3><p>make -f 文件名，执行特定的Makefile文件<br>Make 的默认行为是执行Makefile的第一个target，该目标一般会带起多个目标的执行。目标中有&#x3D;，或者-打头的不能指定为终极目标，因为这些字符的目标会被解析成命令行参数或者变量。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> all <span class="token target symbol">all</span><span class="token punctuation">:</span> prog1 prog2 prog3 prog4<span class="token comment"># 通过make all执行所有的target</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>检查规则(常用)</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-n</span> 打印命令，不执行<span class="token parameter variable">-s</span> ：全面禁止命令的显示<span class="token parameter variable">-q</span> 寻找目标，找到什么都不输出，找不到打印错误error<span class="token parameter variable">-B</span> 认为所有目标都需要重编译<span class="token parameter variable">-C</span> <span class="token operator">&lt;</span>dir<span class="token operator">></span> 指定读取Makefile的目录，如果有多个“-C”参数，make 的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。比如“make <span class="token parameter variable">-C</span> ~hchen/test <span class="token parameter variable">-C</span> prog”等价于“make <span class="token parameter variable">-C</span> ~hchen/test/prog”。<span class="token parameter variable">-I</span> <span class="token operator">&lt;</span>dir<span class="token operator">></span> 指定一个被包含Makefile的搜索目标。可以使用多个“-I”参数来指定多个目录<span class="token parameter variable">-t</span> 更新target的时间，组织生成目标的命令运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>命令执行顺序</li></ul><p>命令顺序执行，如果想要当前的命令在下一行使用，需要将下行命令放在当前行，并加上“；”<br>默认使用&#x2F;bin&#x2F;sh标准执行命令</p><ul><li>命令执行出错</li></ul><p>有可能会终止整个make的执行；但是有时候命令出错是允许的，所以要在命令前加上“-”，表示忽略命令的出错。<br>或者通过命令行参数的方式，<br>-i make会忽略所有出错的命令<br>-k 表示命令出错时，终止该命令执行，但是继续执行其他规则</p><ul><li>嵌套执行make</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">subsystem</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C subdir//进入子目录，执行make选项var <span class="token operator">=</span> 123<span class="token keyword">export</span> var <span class="token comment"># 声明该变量传递给子make文件</span>make -w 进入或者退出目录时会有提示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Makefile中的变量"><a href="#Makefile中的变量" class="headerlink" title="Makefile中的变量"></a>Makefile中的变量</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">Var <span class="token operator">=</span> value类似C的<span class="token keyword">define</span>，强烈建议变量的引用使用括号，比如 <span class="token variable">$</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span>等号右侧的变量可以是Makefile文件后面的内容，就有可能导致递归，所以要使用 <span class="token operator">:=</span>，表示只能使用前面的变量。Var <span class="token operator">:=</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#定义一个变量，值是一个空格</span>Nullstring <span class="token operator">:=</span>space <span class="token operator">:=</span> <span class="token variable">$Nullstring</span> <span class="token comment">#end of the line</span>dir <span class="token operator">:=</span> /foo/bar    <span class="token comment">#end</span>加了<span class="token comment">#后，表示这个dir变量最后会有4个空格导致错误。</span>Foo <span class="token operator">?=</span> valueFoo如果没有定义过，就在此处定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>高级用法</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">1. 变量值的替换  Foo <span class="token operator">:=</span> a.o b.o c.o  Bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>Foo<span class="token punctuation">:</span>.o<span class="token operator">=</span>.c<span class="token punctuation">)</span>2. 变量的值当成变量  Foo <span class="token operator">:=</span> \<span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>3. 追加变量值 <span class="token operator">+=</span>  Object <span class="token operator">:=</span> main.o foo.o  Object <span class="token operator">+=</span> another.o如果前一次的是 <span class="token operator">:=</span> ，那么 <span class="token operator">+=</span> 会以 <span class="token operator">:=</span> 作为其赋值符4. 多行变量使用<span class="token keyword">define</span>   <span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>环境变量</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">如果在命令行参数中代入该变量，环境变量的值会被覆盖。如果make时指定了-e，环境变量会覆盖Makefile中定义的变量。Makefile中定义的变量都是全局变量，<span class="token variable">$@</span> <span class="token variable">$^…</span> 都属于规则型变量也可以为某个目标target设置局部变量，该变量会作用到有这个目标所引发的所有规则区域。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">prog</span> <span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -g<span class="token target symbol">prog</span> <span class="token punctuation">:</span> prog.o foo.o bar.o<span class="token variable">$</span><span class="token punctuation">(</span>GCC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.o foo.o bar.o<span class="token variable">$</span><span class="token punctuation">(</span>addprefix src/,foo bar<span class="token punctuation">)</span> 为每个文件名添加前缀src/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Makefile中的函数"><a href="#Makefile中的函数" class="headerlink" title="Makefile中的函数"></a>Makefile中的函数</h3><h4 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>patsubst <span class="token operator">&lt;</span>pattern<span class="token operator">></span>,<span class="token operator">&lt;</span>replacement<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找&lt;text&gt; 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 &lt;pattern&gt;<br>返回被替换后的字符串</p><p>pattern：可以包含通配符%，表示任意长度的字符串。也可以是subst的&lt;from&gt;</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>objects:.o<span class="token operator">=</span>.c<span class="token variable">)</span></span> 和 <span class="token variable"><span class="token variable">$(</span>patsubst %.o,%.c,<span class="token punctuation">$(</span>objects<span class="token punctuation">)</span><span class="token variable">)</span></span> 是一样的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>strip <span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token variable">)</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>去掉string开头和结尾的空字符</p><h4 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>findstring <span class="token operator">&lt;</span>find<span class="token operator">></span>,<span class="token operator">&lt;</span>in<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果找到，那么返回 &lt;find&gt; ，否则返回空字符串<br>在字串 &lt;in&gt; 中查找&lt;find&gt; 字串</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>filter <span class="token operator">&lt;</span>pattern<span class="token punctuation">..</span>.<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，保留符合模式 &lt;pattern&gt; 的单词。可以 有多个模式。 返回符合模式 &lt;pattern&gt; 的字串。<br>filter-out 功能与filter相反</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">sort</span> <span class="token operator">&lt;</span>list<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>给字符串 &lt;list&gt; 中的单词排序（升序）。<br>返回排序后的字符串，sort 函数会去掉 &lt;list&gt; 中相同的单词。</p><h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>word <span class="token operator">&lt;</span>n<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>取字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。（从一开始）<br>返回字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。如果 &lt;n&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串。</p><h4 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h4><p>$(wordlist <ss>,<e>,<text>)<br>从字符串 &lt;text&gt; 中取从 &lt;ss&gt; 开始到 &lt;e&gt; 的单词串。&lt;ss&gt; 和 &lt;e&gt; 是一个数字</text></e></ss></p><h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><p>$(words <text>)<br>统计 &lt;text&gt; 中字符串中的单词个数。 如果我们要取 &lt;text&gt; 中最后的一个单词，我们可以这样：</text></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>word <span class="token punctuation">$(</span>words <span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token punctuation">)</span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span> 。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>firstword <span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>取字符串 &lt;text&gt; 中的第一个单词。 </p><h4 id="dir-文件名操作函数"><a href="#dir-文件名操作函数" class="headerlink" title="dir 文件名操作函数"></a>dir 文件名操作函数</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">dir</span> <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出目录部分。目录部分是指最后一个反斜杠（&#x2F; ）之前的部分。 如果没有反斜杠，那么返回 .&#x2F;</p><h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>notdir <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出非目录部分。非目录部分是指最后一个反斜杠（&#x2F; ）之后的部分。</p><h4 id="Suffix"><a href="#Suffix" class="headerlink" title="Suffix"></a>Suffix</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>suffix <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出各个文件名的后缀</p><h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出各个文件名的前缀部分。</p><h4 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>addsuffix <span class="token operator">&lt;</span>suffix<span class="token operator">></span>,<span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加后缀，把后缀 &lt;suffix&gt; 加到 <names> 中的每个单词后面。</names></p><h4 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h4><p>$(addprefix <prefix>,&lt;names…&gt;)<br>把前缀 &lt;prefix&gt; 加到 &lt;names&gt; 中的每个单词前面。 </prefix></p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">join</span> <span class="token operator">&lt;</span>list<span class="token operator"><span class="token file-descriptor important">1</span>></span>,<span class="token operator">&lt;</span>list<span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接list1 和list2</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">join</span> aaa bbb , <span class="token number">111</span> <span class="token number">222</span> <span class="token number">333</span><span class="token variable">)</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值是 aaa111 bbb222 333</p><h4 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach 函数"></a>foreach 函数</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>foreach <span class="token operator">&lt;</span>var<span class="token operator">></span>,<span class="token operator">&lt;</span>list<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中，然后再执行 &lt;text&gt; 所包含的表达式。每一次 &lt;text&gt; 会返回一个字符串，循环过程中，&lt;text&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值.   var是一个临时变量，作用域只在 foreach 函数</p><p>&lt;var&gt; 最好是一个变量名,&lt;list&gt; 可以是一个表达式，而 &lt;text&gt; 中一般会使用 &lt;var&gt; 这个 参数来依次枚举 &lt;list&gt; 中的单词</p><h4 id="if-函数"><a href="#if-函数" class="headerlink" title="if 函数"></a>if 函数</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token keyword">if</span> <span class="token operator">&lt;</span>condition<span class="token operator">></span>,<span class="token operator">&lt;</span>then-part<span class="token operator">></span><span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span><span class="token keyword">if</span> <span class="token operator">&lt;</span>condition<span class="token operator">></span>,<span class="token operator">&lt;</span>then-part<span class="token operator">></span>,<span class="token operator">&lt;</span>else-part<span class="token operator">></span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>即 if 函数的参数可以是两个，也可以是三个。&lt;condition&gt; 参数是 if 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，&lt;then-part&gt; 会被计算，否则 &lt;else-part&gt; 会被计算。</p><h4 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h4><p>操作系统 Shell 的命令<br>shell 函数把执行操作系统命令后的输出作为函数返回</p><h4 id="控制-make-的函数"><a href="#控制-make-的函数" class="headerlink" title="控制 make 的函数"></a>控制 make 的函数</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>error <span class="token operator">&lt;</span>text <span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>warning <span class="token operator">&lt;</span>text <span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>很像 error 函数，只是它并不会让 make 退出，只是输出一段警告信息，而 make 继续执行。</p><h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a><strong>wildcard</strong></h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#显示扩展名</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.v<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="readlink"><a href="#readlink" class="headerlink" title="readlink"></a>readlink</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">打印解析符号链接或符号链接的规范文件名-f 通过递归给出指定名称的符号链接当前脚本的绝对路径：readlink -m <span class="token variable">$0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="abspath"><a href="#abspath" class="headerlink" title="abspath"></a>abspath</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">abspath</span> ./src<span class="token punctuation">)</span> <span class="token comment"># 返回目录或者文件的绝对路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="用法"><a href="#用法" class="headerlink" title="$$ 用法"></a>$$ 用法</h4><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">SRC <span class="token operator">:=</span> A.c B.c<span class="token target symbol">process</span><span class="token punctuation">:</span>for i in <span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span class="token punctuation">;</span> do \readlink -f <span class="token variable">$$i</span> >> <span class="token variable">$file</span> \done使用两个<span class="token variable">$$，是因为i在shell的for循环中展开，属于shell的变量，相当于两层变量的嵌套。make读到$$i时候，会进行转义，展开成$i，然后交给shell解释程序。施加了$$的变量，需要两次展开，才能得到变量的值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Makefile中C编译、链接选项"><a href="#Makefile中C编译、链接选项" class="headerlink" title="Makefile中C编译、链接选项"></a>Makefile中C编译、链接选项</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">CFLAGS参数<span class="token operator">|</span><span class="token operator">|</span>编译<span class="token operator">|</span><span class="token operator">|</span>-c<span class="token comment"># 将C编译成.o目标文件，不链接</span>-o<span class="token comment"># 重命名</span>-Idir<span class="token comment"># 将新路径添加到include路径中，-I. -I/opt/usr...</span>-Wall   <span class="token comment"># 生成所有warning，并停止编译</span>-w<span class="token comment"># 关闭所有warning</span>-O<span class="token comment"># 优化编译选项</span>LDFLAGS参数<span class="token operator">|</span><span class="token operator">|</span>链接<span class="token operator">|</span><span class="token operator">|</span>-lxxx<span class="token comment"># 添加动态链接库，在搜索目录中找xxx.a，xxx.so的库文件</span>-static<span class="token comment"># 使用静态链接库生成目标文件，避免使用共享库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim/vscode配置和操作</title>
      <link href="/2023/112521332.html"/>
      <url>/2023/112521332.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h3 id="实现一列序号递增"><a href="#实现一列序号递增" class="headerlink" title="实现一列序号递增"></a>实现一列序号递增</h3><p>ctrl-v 选中列，然后 g + ctrl-a</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">my_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   my_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> my_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><ul><li>bash下使用vim</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> <span class="token parameter variable">-d</span> file1 file2vimdiff file1 file2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>已经打开一个文件，打开另外一个文件对比</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vert diffsplit file2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>打开两个文件</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">在两个文件中分别执行  diffthis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>vim filename +50   打开filename，并跳转到第50行</p><pre class="line-numbers language-none"><code class="language-none">:w new_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="生成递增递减序列（10进制，16进制）-vimincr插件"><a href="#生成递增递减序列（10进制，16进制）-vimincr插件" class="headerlink" title="生成递增递减序列（10进制，16进制）  vimincr插件"></a>生成递增递减序列（10进制，16进制）  vimincr插件</h3><p>按10进制递增：Ctrl+v选中，shift+；，输入命令II 或者 I</p><p>按10进制递减：Ctrl+v选中，shift+；，输入命令II-1或者 I-1   </p><p>按16进制递增：Ctrl+v选中，shift+；，输入命令IIX 或者 IX</p><p>按16进制递减：Ctrl+v选中，shift+；，输入命令IIX-1或者 IX-1 </p><h4 id="只查看文件"><a href="#只查看文件" class="headerlink" title="只查看文件"></a>只查看文件</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">less</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim Vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>add delay to verilog models</title>
      <link href="/2023/112317390.html"/>
      <url>/2023/112317390.html</url>
      
        <content type="html"><![CDATA[<h2 id="verilog中的延迟模型"><a href="#verilog中的延迟模型" class="headerlink" title="verilog中的延迟模型"></a>verilog中的延迟模型</h2><h4 id="block-assignment（always）-“-”-阻塞赋值"><a href="#block-assignment（always）-“-”-阻塞赋值" class="headerlink" title="block assignment（always） “&#x3D;” 阻塞赋值"></a>block assignment（always） “&#x3D;” 阻塞赋值</h4><p>分为两种方式：LHS、RHS</p><ul><li>LHS</li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment">//LHS always @(a) // RHS</span>  <span class="token number">#5</span> y <span class="token operator">=</span> <span class="token operator">~</span>a<span class="token punctuation">;</span>  y <span class="token operator">=</span> <span class="token number">#5</span> <span class="token operator">~</span>a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2023/112317390/image-20231123170149369.png" alt="LHS in always" style="zoom: 67%;"><img src="/2023/112317390/image-20231123170340908.png" alt="always 阻塞 LHS" style="zoom: 67%;"><p>​总结：LHS是在第一次变量发生变化后，延迟12ns才进行真正的计算，如上图所示15ns后其他变量发生了变化，输出在统一在27ns时会使用最新的输入数据。<strong>相当于先延迟再计算。</strong>这里，b，ci的输入到输出，并没有经过12ns的延迟。</p><ul><li>RHS</li></ul><img src="/2023/112317390/image-20231123193908804.png" alt="always RHS 阻塞" style="zoom: 67%;"><p>​如果延迟12ns的期间，a，b，ci发生了变化，则输出不会体现出来。<strong>相当于先计算，再延迟。</strong></p><p>​在任何阻塞赋值的语句上，尽可能不使用这种形式。</p><h4 id="noblocking-assignment-（always）“"><a href="#noblocking-assignment-（always）“" class="headerlink" title="noblocking assignment （always）“&lt;&#x3D;” 非阻塞赋值"></a>noblocking assignment （always）“&lt;&#x3D;” 非阻塞赋值</h4><img src="/2023/112317390/image-20231123204725158.png" alt="Nonblocking Assignments with Delays" style="zoom:67%;"><ul><li>LHS</li></ul><p>​这种情况和阻塞赋值的”LHS”具有一样的问题。 </p><ul><li>RHS</li></ul><p>​<strong>这种是延迟组合逻辑的正确方式</strong></p><p>​<img src="/2023/112317390/image-20231123212135502.png" alt="always 非阻塞" style="zoom:67%;"></p><p>​<img src="/2023/112317390/image-20231123212223383.png" alt="always 非阻塞" style="zoom: 50%;"></p><p>​15ns时，a发生变化，在此后的12ns如果a，ci，b发生变化，则在27ns不会使用最新的数据，而是每个变化点后的12ns才发生改变。符合预期效果。</p><h4 id="Continuous-assignment"><a href="#Continuous-assignment" class="headerlink" title="Continuous assignment"></a>Continuous assignment</h4><img src="/2023/112317390/image-20231123213602068.png" alt="continous assignments" style="zoom:50%;"><p>​RHS delay，存在和always同样的问题，间隔小于12ns的任何输入变化都不会被检测到。</p><img src="/2023/112317390/image-20231123213721809.png" alt="assign '=' delay " style="zoom:50%;"><img src="/2023/112317390/image-20231123213918097.png" alt="assign delay wave" style="zoom: 50%;"><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>只有always块的非阻塞赋值RHS才可以准确描述组合逻辑的延迟。</strong></p><h4 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h4><p>在tb测试时，如果输入信号是通过@(posedge clk)给出的，一定要 <strong>使用&lt;&#x3D;非阻塞赋值</strong>。否则，会导致，在上升沿时阻塞和非阻塞赋值冲突。</p><p>建模中，对于延迟的信号，需要 <strong>赋初始值</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> RTL仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTL延迟建模方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小谈case语句</title>
      <link href="/2023/112324934.html"/>
      <url>/2023/112324934.html</url>
      
        <content type="html"><![CDATA[<h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>​最近一直在写code，随着学习的深入，越来越想知道verilog 语法和对应的电路实现是什么样子的。</p><p>​首先，确定一点，完备的case，所有的分支都是并行的，且互斥，所以讨论有没有优先级是没有意义的，它对应的电路是一个MUX。（没有优先级）</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">完备的<span class="token keyword">case</span>分支，等价于 <span class="token keyword">if</span> <span class="token keyword">else</span><span class="token operator">-</span><span class="token keyword">if</span> <span class="token keyword">else</span><span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>缺省case</li></ul><p>​case的分支中，如果缺省，不进行其他操作，dc综合的时候<strong>会生成锁存器latch</strong></p><p>​这个时候如果添加原语 <strong>&#x2F;&#x2F;synopsys full_case</strong> ，目的是让综合器DC知道所有情况都已经列全了，不会生成latch。</p><ul><li><p>full case</p><p>每个可能的case expression的取值，都有与之相对应的分支。都列全了，即使没有default，也是full case synopsys的dc_shell把full_case解释为：如果case不是full，对于没有出现的分支条件，输出就当成“不关心”处理，在综合的时候，对于没有出现的分支，会根据逻辑优化赋个常数。<strong>这样会导致前仿和后仿的结果不一致，所以需要注意这个地方</strong>，如果case中有default，case_full会被忽略。</p></li><li><p>parallel case</p><p>parallel case是指case expression只能匹配一个分支，不能出现一对多的情况。</p><p>告诉DC，所有条件都是互斥的，且都是并行，不存在优先级。</p><p>优先级只会存在于多对一的情况下。</p><p><strong>在仿真的时候出现了多对一的情况，会导致仿真执行有一定的优先级，这样就不是parallel case。如果针对这种情况dc时，加上parallel case，会综合出没有优先级的编码器。</strong></p><p>通过<strong>遍历条件</strong>在case中是否<strong>只会被执行一次</strong>，我们可以判断case的综合结果为串行还是并行</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​当case 是full且是parallel的时候，综合出来的电路是没有优先级的MUX，多选一数据选择器；</p><p>​如果case不是full，又没有default，会综合出latch。</p><h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><p>if elseif 和case</p><p><img src="/2023/112324934/image-20240507185616364.png" alt="image-20240507185616364"></p><p><img src="/2023/112324934/image-20240507185631196.png" alt="image-20240507185631196"></p><p>使用case语句去除优先级，可以大大优化电路的逻辑</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高RTL仿真速度</title>
      <link href="/2023/11224275.html"/>
      <url>/2023/11224275.html</url>
      
        <content type="html"><![CDATA[<h2 id="如何提高仿真器的效率"><a href="#如何提高仿真器的效率" class="headerlink" title="如何提高仿真器的效率"></a>如何提高仿真器的效率</h2><p>了解仿真器的底层原理，合适的code style会节省仿真时间。</p><h4 id="仿真算法："><a href="#仿真算法：" class="headerlink" title="仿真算法："></a><strong>仿真算法：</strong></h4><ol><li><p>基于时间的（spice仿真器）</p><p>每个时间节点对所有元件都进行计算，效率低。</p></li><li><p>基于事件的（Verilog XL，NC verilog）</p><p>只有电路发生变化时，才进行处理。效率高。</p></li><li><p>基于周期的（Verilator ）</p><p>只在时钟边沿计算，不管时序，使用两值逻辑。仅适用于同步电路，效率高。比如CPU的仿真。</p></li></ol><p>​以下的测试都是基于Verilog-XL</p><ul><li><h4 id="case语句和多if-else-if语句"><a href="#case语句和多if-else-if语句" class="headerlink" title="case语句和多if else if语句"></a>case语句和多if else if语句</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// case                         // if else-if                    </span><span class="token important">always @</span>（<span class="token operator">*</span>）<span class="token keyword">begin</span>                <span class="token important">always @</span>（<span class="token operator">*</span>）<span class="token keyword">begin</span>                    <span class="token function">case</span><span class="token punctuation">(</span>sel<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                  <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span>                     <span class="token number">2'b00</span><span class="token punctuation">:</span> out <span class="token operator">=</span> a<span class="token punctuation">;</span>                 out <span class="token operator">=</span> a<span class="token punctuation">;</span>                        <span class="token number">2'b01</span><span class="token punctuation">:</span> out <span class="token operator">=</span> b<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span>                     <span class="token number">2'b10</span><span class="token punctuation">:</span> out <span class="token operator">=</span> c<span class="token punctuation">;</span>                 out <span class="token operator">=</span> b<span class="token punctuation">;</span>                        <span class="token number">2'b11</span><span class="token punctuation">:</span> out <span class="token operator">=</span> d<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span>                     <span class="token keyword">default</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> a<span class="token punctuation">;</span>              out <span class="token operator">=</span> c<span class="token punctuation">;</span>                    <span class="token keyword">endcase</span>                         <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b11</span><span class="token punctuation">)</span>             <span class="token keyword">end</span>                                     out <span class="token operator">=</span> d<span class="token punctuation">;</span>                                                   <span class="token keyword">end</span>      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试案例：8选1数据选择器，</p><p>仿真发现：基于case的多路选择器，CPU仿真时间更短。</p></li><li><h4 id="带有begin-end和不带begin-end"><a href="#带有begin-end和不带begin-end" class="headerlink" title="带有begin end和不带begin end"></a>带有begin end和不带begin end</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span><span class="token keyword">begin</span><span class="token function">if</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span><span class="token keyword">else</span>  c <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span><span class="token function">if</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span><span class="token keyword">else</span>  c <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​测试结果：nobegin表述的内存利用率和仿真时间要优一些。</p><ul><li><h4 id="define-和-parameters"><a href="#define-和-parameters" class="headerlink" title="&#96;define 和 parameters"></a>&#96;define 和 parameters</h4><img src="/2023/11224275/define1.jpg" alt="define&amp;parameters"></li></ul><p>​parameters要更好一些。</p><ul><li><h4 id="always-group和nogroup"><a href="#always-group和nogroup" class="headerlink" title="always group和nogroup"></a>always group和nogroup</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> <span class="token keyword">begin</span>        out1 <span class="token operator">&lt;=</span> a<span class="token punctuation">;</span>        out2 <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span>        out3 <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span>        out4 <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out1 <span class="token operator">&lt;=</span> a<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out2 <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out3 <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out4 <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/11224275/image-20231122100101428.png" alt="group&amp;nogroup"></p><p>group的仿真时间明显缩短了。</p></li><li><p>verilog可综合</p></li></ul><p>​左移，右移逻辑的操作数，可以是常数，也可以是变量，都是可以综合的，综合结果不一样。 常数的操作数，综合 出来是一个定值，变量的操作数综合出来是一个mux。</p><ul><li>DC时综合的原语</li></ul><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl"><span class="token operator">/</span><span class="token operator">/</span> synopsys translate_off忽略该部分的代码，DC时不会进行转移。<span class="token operator">/</span><span class="token operator">/</span> synopsys translate_on忽略的部分在前仿时是可以发挥作用的，如果错误使用translate_off on语句，会导致前仿和后仿的结果不一致。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// 小心使用translate off on</span>ex<span class="token punctuation">.</span>带两个异步复位信号的D触发器一般的实现方式如下：<span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst <span class="token keyword">or</span> <span class="token keyword">negedge</span> nset<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token comment">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nset<span class="token punctuation">)</span> <span class="token comment">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         q <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span>这种方式会导致前仿和后仿出现细微的区别。极端测试向量如下：如果nrst和nset同时拉低，则结果输出为<span class="token number">0</span><span class="token punctuation">.</span>经过半个周期后，nrst拉高了，输出结果依然为<span class="token number">0</span><span class="token punctuation">.</span>因为<span class="token important">always</span>块是边沿敏感触发的，但是nset和nrst都是异步的，nset此时为<span class="token number">0</span>，q输出结果应该为<span class="token number">1</span>；计算结果与实际电路不符。解决办法：    加入translate on off语句。配合<span class="token keyword">force</span> 和 relase正确code如下：<span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst <span class="token keyword">or</span> <span class="token keyword">negedge</span> nset<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token comment">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nset<span class="token punctuation">)</span> <span class="token comment">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         q <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment">// synopsys translate_off</span><span class="token important">always @</span><span class="token punctuation">(</span>nrst <span class="token keyword">or</span> nset<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>nrst <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nset<span class="token punctuation">)</span>   <span class="token keyword">force</span> q <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>                <span class="token keyword">release</span> q<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment">// synopsys translate_on</span>该代码可以保证，在nrst撤离时，nset如果为<span class="token number">0</span>，q输出结果为<span class="token number">1</span>；这是在前仿时需要加入的特殊语句，并加上原语。在实际综合过程中，不会被综合。保证了前仿和实际流片的结果完全一致。在工艺库中，有时钟，异步复位和异步置数的端口，也就是说<span class="token important">always</span>块中的敏感列表，最多可以有三个。但是不能是同时<span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> clk。一个信号不能依赖两个边沿。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>verilog调试</p><p>bg：verilog中的参数可以用 &#96;define和parameter指定，这种方式必须要求我们在编译前修改好，编译后就不能再修改了。但是为了节省编译时间，可以使用 $test$plusargs和$value$plusargs来指定。</p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps<span class="token keyword">module</span> tb<span class="token punctuation">;</span><span class="token keyword">reg</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> testname<span class="token punctuation">;</span><span class="token keyword">initial</span> <span class="token keyword">begin</span><span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">"**********************RESULT IS BELOW*********************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">if</span><span class="token punctuation">(</span><span class="token kernel-function property">$test</span><span class="token kernel-function property">$plusargs</span><span class="token punctuation">(</span><span class="token string">"TAISHAN"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">"****************TAISHAN is selected******************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">"**********************$test$plusargs FAIL**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token kernel-function property">$value</span><span class="token kernel-function property">$plusargs</span><span class="token punctuation">(</span><span class="token string">"TESTNAME=%s"</span><span class="token punctuation">,</span> testname<span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">begin</span>  <span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">"*****************Running test %0s.********************"</span><span class="token punctuation">,</span> testname<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">"**********************$value$plusargs FAIL**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token kernel-function property">$finish</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span>使用方式：<span class="token number">1</span><span class="token punctuation">.</span>simv<span class="token number">2</span><span class="token punctuation">.</span>simv<span class="token operator">+</span>TATSHAN<span class="token number">3</span><span class="token punctuation">.</span>simv<span class="token operator">+</span>TAISHAN<span class="token operator">+</span>TESTNAME<span class="token operator">=</span>HUASHAN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在仿真时，0时刻会执行一些系统函数，有些数据没有准备好，导致发生系统仿真错误，因此，可以在代码中初始化变量的值。</p><p><img src="/2023/11224275/image-20240203213035815.png"></p><p><img src="/2023/11224275/image-20240203213107944.png"></p>]]></content>
      
      
      <categories>
          
          <category> RTL仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 仿真器底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
