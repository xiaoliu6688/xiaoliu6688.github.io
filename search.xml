<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一生一芯-AXI总线及仲裁设计</title>
      <link href="/2024/022546524.html"/>
      <url>/2024/022546524.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>时钟切换设计</title>
      <link href="/2024/022513924.html"/>
      <url>/2024/022513924.html</url>
      
        <content type="html"><![CDATA[<h2 id="时钟切换"><a href="#时钟切换" class="headerlink" title="时钟切换"></a>时钟切换</h2><blockquote><p>某些时钟切换的场景下，需要选择信号来选择某一个时钟信号</p></blockquote><h3 id="组合逻辑选通"><a href="#组合逻辑选通" class="headerlink" title="组合逻辑选通"></a>组合逻辑选通</h3><p>电路对时钟信号非常敏感，如果采用组合逻辑选通时钟，很有可能在时钟上产生毛刺，导致功能错误，或者不满足时序要求，造成亚稳态。</p><img src="/2024/022513924/image-20240225231635368.png" alt="image-20240225231635368" style="zoom: 25%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">assign</span> clk1_t <span class="token operator">=</span> clk1 <span class="token operator">&amp;</span> sel_clk1<span class="token punctuation">;</span><span class="token keyword">assign</span> clk2_t <span class="token operator">=</span> clk2 <span class="token operator">&amp;</span> <span class="token operator">!</span>sle_clk1<span class="token punctuation">;</span><span class="token keyword">assign</span> clk_out <span class="token operator">=</span> clk1_t <span class="token operator">|</span> clk2_t<span class="token punctuation">;</span></code></pre><img src="/2024/022513924/8f134e7b11982eb43608e728782d78da.png" alt style="zoom: 33%;"><h3 id="时序逻辑选通"><a href="#时序逻辑选通" class="headerlink" title="时序逻辑选通"></a>时序逻辑选通</h3><p><strong>产生毛刺的本质原因是sel信号是异步的，无法保证输出的时钟在低电平时切换。</strong></p><p><strong>通过添加一级寄存器</strong>，使得sel选通信号在时钟切换在下降沿才发生变化，这样不会产生毛刺，因为是“相与”的关系。<br><strong>增加了反馈的好处</strong>：即使select信号改变了，时钟的切换需要等待切换前时钟为低电平时才可以 发生切换，保证了之前时钟信号的完整性（不会斩波）。<br>通过以上两种优化，就可以输出没有毛刺的时钟信号。这是一种非常安全的时钟切换方案。</p><img src="/2024/022513924/1bee2a8c32b64dd050b86e103ad3462d.jpeg" style="zoom:50%;"><p>此外，由于sel信号是异步输入，为了降低亚稳态，可以打两拍，再进行时钟切换。</p><img src="/2024/022513924/12ba42985f38e4091d39bc8bae8d191e.jpeg" style="zoom:50%;"><pre class=" language-Verilog"><code class="language-Verilog">/********************************************************************* * Author           : liu * Last modified    : 2023-05-30 15:25 * Filename         : switch_clock.v * Description      :  * ******************************************************************/module switch_clock(  input clk1,  input rstn1,  input clk2,  input rstn2,  input select,  output clkout);  wire clk1_select;  wire clk2_select;  reg clk1_reg_r, clk1_reg_rr;  reg clk2_reg_r, clk2_reg_rr;  reg clk1_reg_rrr;  reg clk2_reg_rrr;    always @(posedge clk1 or negedge rstn1)begin    if(!rstn1) begin      clk1_reg_r <= 0;      clk1_reg_rr <= 0;    end    else begin      clk1_reg_r <= clk1_select;      clk1_reg_rr <= clk1_reg_r;    end  end  always @(posedge clk2 or negedge rstn2)begin    if(!rstn2) begin      clk2_reg_r <= 0;      clk2_reg_rr <= 0;    end    else begin      clk2_reg_r <= clk2_select;      clk2_reg_rr <= clk2_reg_r;    end  end  assign clk1_select = select & (~clk2_reg_rrr);  assign clk2_select = ~select & (~clk1_reg_rrr);  always @(negedge clk1 or negedge rstn1) begin    if(!rstn1)      clk1_reg_rrr <= 0;    else      clk1_reg_rrr <= clk1_reg_rr;  end  always @(negedge clk2 or negedge rstn2) begin    if(!rstn2)      clk2_reg_rrr <= 0;    else      clk2_reg_rrr <= clk2_reg_rr;  end  assign clkout = (clk1 & clk1_reg_rrr ) || (clk2 & clk2_reg_rrr);endmodule</code></pre><p><img src="/2024/022513924/48bccb9764f34ae5948dd826d5dcb0f5.png" alt="测试结果"></p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2024/022548230.html"/>
      <url>/2024/022548230.html</url>
      
        <content type="html"><![CDATA[<ul><li>文件操作</li></ul><pre class=" language-bash"><code class="language-bash">压缩成.tar文件： <span class="token function">tar</span> -cvf file.tar files解压.tar文件： <span class="token function">tar</span> -xvf file.tar压缩成.tar.gz文件： <span class="token function">tar</span> -czvf file.tar.gz files解压.tar.gz文件： <span class="token function">tar</span> -xzvf file.tar.gz压缩.tar.bz2文件： <span class="token function">tar</span> -cjvf file.tar.bz2 files解压.tar.bz2文件： <span class="token function">tar</span> -xjvf file.tar.bz2压缩成.gz 文件 <span class="token function">gzip</span> <span class="token function">file</span>解压 <span class="token function">gzip</span> -d file.gz</code></pre><ul><li>系统配置</li></ul><p>​&#x2F; ——根目录<br>​&#x2F;bin ——存放必要的命令<br>​&#x2F;boot ——存放内核以及启动所需的文件<br>​&#x2F;dev ——存放设备文件<br>​&#x2F;etc ——存放系统配置文件<br>​&#x2F;home ——普通用户的宿主目录，用户数据存放在其主目录中<br>​&#x2F;lib ——存放必要的运行库<br>​&#x2F;mnt ——存放临时的映射文件系统，通常用来挂载使用。<br>​&#x2F;proc ——存放存储进程和系统信息<br>​&#x2F;root ——超级用户的主目录<br>​&#x2F;sbin ——存放系统管理程序<br>​&#x2F;tmp ——存放临时文件<br>​&#x2F;usr ——存放应用程序，命令程序文件、程序库、手册和其它文档。<br>​&#x2F;var ——-系统默认日志存放目录</p><pre class=" language-bash"><code class="language-bash"><span class="token function">hostname</span> <span class="token keyword">:</span> 显示系统的hostname<span class="token function">ifconfig</span> -a <span class="token keyword">:</span> 显示网络的配置信息</code></pre><p>查看文件内容情况：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">wc</span> <span class="token function">file</span> <span class="token keyword">:</span> 计算文件的行数和字节数<span class="token function">wc</span> -w <span class="token function">file</span> <span class="token keyword">:</span> 计算文件的字数<span class="token function">wc</span> -l <span class="token function">file</span> <span class="token keyword">:</span> 计算文件的行数<span class="token function">find</span> 查找文件或目录命令格式为:     <span class="token function">find</span> 后接查找的目录，-name指定需要查找的文件名称，名称可以使用“* ”表示所有。    <span class="token function">find</span> /home -name “test.txt”,    <span class="token function">find</span> /home -name “*.txt” :查找/home目录下，所有以.txt结尾的文件或者目录。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-Cache设计(二)</title>
      <link href="/2024/022536323.html"/>
      <url>/2024/022536323.html</url>
      
        <content type="html"><![CDATA[<h2 id="Cache实现"><a href="#Cache实现" class="headerlink" title="Cache实现"></a>Cache实现</h2><p>根据上述的理论知识，确定cache的设计要求如下</p><ol><li><p><strong>采用直接映射缓存的方式，cache size为2KB，cache line为8Bytes，</strong></p></li><li><p><strong>当访问cache缺省时，采用读分配Read allocate和写分配Write allocate策略，</strong></p></li><li><p><strong>cache的更新策略为写回Write Back</strong></p></li></ol><h3 id="Icache实现"><a href="#Icache实现" class="headerlink" title="Icache实现"></a>Icache实现</h3><p>​icache在流水线中的位置以及接口信号如下</p><img src="/2024/022536323/image-20240225165626395.png" style="zoom: 33%;"><p>​包含两组握手信号，第一个是ifu和PC寄存器的握手，只有ifpc_valid &amp; ifpc_ready&#x3D;1握手后，才可以更新ifu阶段的取值地址pc_i。第二个是ifu和icache的握手，只有cache_rdy &amp;  cache_vld 握手成功后，ifu阶段才可以拿到pc对应的指令，并通过inst_valid信号指示，给到IF_ID寄存器。Icache和SRAM通过AXI协议完成读取指令。</p><p>​由于icache只有对内存读取数据的需求，所以AXI协议中的写地址、写数据和写响应通道可以忽略，icache的整个状态跳转如下</p><img src="/2024/022536323/image-20240225171812056.png" alt="image-20240225171812056" style="zoom:33%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">assign</span> allocate <span class="token operator">=</span> state <span class="token operator">==</span> ALLOCATE<span class="token punctuation">;</span><span class="token keyword">assign</span> wstrb <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> ALLOCATE<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b11111111</span> <span class="token punctuation">:</span> <span class="token number">8'b00000000</span><span class="token punctuation">;</span><span class="token keyword">assign</span> wdata <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> ALLOCATE<span class="token punctuation">)</span> <span class="token operator">?</span> ram_data <span class="token punctuation">:</span> <span class="token number">64'h0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> ready <span class="token operator">=</span> hit <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> IDLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">case</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>        IDLE <span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>hit<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span>            next_state <span class="token operator">=</span> RADDR<span class="token punctuation">;</span>                <span class="token keyword">else</span>                          next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>        RADDR<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>axi_arvalid <span class="token operator">&amp;&amp;</span> axi_arready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>                <span class="token keyword">else</span>                          next_state <span class="token operator">=</span> RADDR<span class="token punctuation">;</span>        RDATA<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>axi_rvalid <span class="token operator">&amp;&amp;</span> axi_rready<span class="token punctuation">)</span>   next_state <span class="token operator">=</span> ALLOCATE<span class="token punctuation">;</span>                <span class="token keyword">else</span>                          next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>        ALLOCATE<span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>         <span class="token keyword">default</span> <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span></code></pre><p>只有在IDLE状态才会读取cache的数据，如果hit，直接输出有效的指令；如果miss，则通过AXI读取内存，首先跳转到RADDR状态，进行读地址通道的握手，然后跳转到读数据状态。读地址通道握手后，得到指令数据，然后跳转到读分配状态，将读出的指令加载到cachemem中。最终在IDLE状态，hit该cacheline，读出数据。</p><p>cachemem中对于hit的判断和cacheline的更新如下</p><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>flash<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>DATA_SIZE<span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>       v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>      d<span class="token punctuation">[</span>i<span class="token punctuation">]</span>   <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>      tag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>      mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>en <span class="token operator">&amp;</span> allocate<span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token function">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token function">if</span><span class="token punctuation">(</span>wen<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> wdata<span class="token punctuation">[</span><span class="token number">8</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    d<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    tag<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> addr_tag<span class="token punctuation">;</span>   <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">assign</span> addr_index <span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">+</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> addr_tag <span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> offset<span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">assign</span> hit <span class="token operator">=</span> en <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>addr_tag <span class="token operator">==</span> tag<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> rdata <span class="token operator">=</span> offset<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">?</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span> <span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>由于inst指令是32bit的，cacheline是64bit，通过判断offset[2]确定读取命中cacheline的高32bit还是低32bit。</p><p><strong>在cache miss时，通过AXI访问内存时，通常需要多个周期。这个过程中，需要将流水线停顿下来，发出stall信号给PC寄存器，输出给IF_ID寄存器为nop指令。</strong></p><hr><h3 id="Dcache实现"><a href="#Dcache实现" class="headerlink" title="Dcache实现"></a>Dcache实现</h3><p>​dcache在流水线中的位置以及接口信号如下</p><img src="/2024/022536323/image-20240225202346217.png" alt style="zoom:33%;"><p>​只包含一组握手信号，lus和dcache之间；对dcache进行读操作的过程跟icache差不多。<br>​<strong>最大区别</strong>在于写操作，写缺省时，执行写分配，将写入地址的数据读取到cachemem中(这个过程和读分配差不多)，在IDLE状态将待更新的数据写入到cacheline中，并将对应的dirty位置1。在替换该cacheline时，判断dirty位为1，需要先将数据写入到内存中；因此，相比icache，多了很多状态。</p><img src="/2024/022536323/image-20240225205639538.png" alt="image-20240225205639538" style="zoom:33%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        IDLE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> dirty <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> WRITEBACK <span class="token punctuation">:</span>                            <span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> RADDR <span class="token punctuation">:</span> IDLE<span class="token punctuation">;</span>        WRITEBACK <span class="token punctuation">:</span> next_state <span class="token operator">=</span> WADDR<span class="token punctuation">;</span>        ALLOCATE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>        RADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_arvalid <span class="token operator">&amp;&amp;</span> axi_arready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>        RDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_rvalid  <span class="token operator">&amp;&amp;</span> axi_rready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> ALLOCATE<span class="token punctuation">;</span>        WADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_awvalid <span class="token operator">&amp;&amp;</span> axi_awready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> WDATA<span class="token punctuation">;</span>        WDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_wvalid  <span class="token operator">&amp;&amp;</span> axi_wready <span class="token operator">&amp;&amp;</span> axi_wlast <span class="token punctuation">)</span> next_state <span class="token operator">=</span> WRESP<span class="token punctuation">;</span>        WRESP <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_bvalid  <span class="token operator">&amp;&amp;</span> axi_bready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> RADDR<span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span></code></pre><ul><li><p>针对读写指令是字节&#x2F;半字&#x2F;字&#x2F;双字</p><p>在读写cacheline时需要根据地址的后三位使用offset来限制，保证读出的数据都是对齐的，写入数据对cacheline的数据更新也是对齐的。</p></li></ul><pre class=" language-verilog"><code class="language-verilog">    <span class="token keyword">assign</span> offset <span class="token operator">=</span> addr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Read</span>    <span class="token important">always @</span><span class="token operator">*</span> <span class="token keyword">begin</span>      <span class="token function">case</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span>         <span class="token number">3'b000</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token number">3'b001</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">8'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token number">3'b010</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">16'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token number">3'b011</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">24'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token number">3'b100</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token number">3'b101</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">40'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token number">3'b110</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">48'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">48</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token number">3'b111</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">56'b0</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> rdata <span class="token operator">=</span> mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> we_offset<span class="token punctuation">;</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token function">case</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span>        <span class="token number">3'b000</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token number">3'b001</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token number">3'b010</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token number">3'b011</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token number">3'b100</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token number">3'b101</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token number">3'b110</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span>        <span class="token number">3'b111</span><span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token punctuation">:</span> we_offset <span class="token operator">=</span> we<span class="token punctuation">;</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> wdata_offset<span class="token punctuation">;</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token function">case</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span>        <span class="token number">3'b000</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token number">3'b001</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token number">3'b010</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token number">3'b011</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">;</span>        <span class="token number">3'b100</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">;</span>        <span class="token number">3'b101</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">;</span>        <span class="token number">3'b110</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">6</span><span class="token punctuation">;</span>        <span class="token number">3'b111</span><span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token punctuation">:</span> wdata_offset <span class="token operator">=</span> wdata<span class="token punctuation">;</span>      <span class="token keyword">endcase</span>    <span class="token keyword">end</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>                v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> tag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">end</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>en <span class="token operator">&amp;&amp;</span> hit<span class="token punctuation">)</span> <span class="token keyword">begin</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>we_offset<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>              mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> wdata_offset<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">end</span>          <span class="token keyword">end</span>          d<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>en <span class="token operator">&amp;&amp;</span> allocate<span class="token punctuation">)</span> <span class="token keyword">begin</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>we<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>              mem<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> wdata<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> i <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">end</span>          <span class="token keyword">end</span>          d<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>          v<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>          tag<span class="token punctuation">[</span>addr_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> addr_tag<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token comment" spellcheck="true">// lsu.v</span><span class="token comment" spellcheck="true">// 针对不同的指令，将输出的结果进行符号位扩展。</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span>lden_i<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">case</span><span class="token punctuation">(</span>lsfunc3_i<span class="token punctuation">)</span>          <span class="token number">3'b000</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">56</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span>temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>          <span class="token number">3'b001</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">48</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span>temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>          <span class="token number">3'b010</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">32</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span>temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>          <span class="token number">3'b100</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">56'b0</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>          <span class="token number">3'b101</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">48'b0</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>          <span class="token number">3'b110</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>          <span class="token number">3'b011</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> temp<span class="token punctuation">;</span>          <span class="token keyword">default</span><span class="token punctuation">:</span> lsres <span class="token operator">=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>      <span class="token keyword">endcase</span>  <span class="token keyword">end</span> <span class="token keyword">else</span>     lsres <span class="token operator">=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span></code></pre><p><strong>在dcache读写内存时，需要多个周期，这时流水线需要停顿下来，发出stall信号，将前面各个阶段寄存器的数据保持不变。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-Cache设计（一）</title>
      <link href="/2024/022542394.html"/>
      <url>/2024/022542394.html</url>
      
        <content type="html"><![CDATA[<h2 id="Cache基础知识"><a href="#Cache基础知识" class="headerlink" title="Cache基础知识"></a>Cache基础知识</h2><blockquote><p>部分参考网上的学习资料，侵删。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>时间局部性：在程序中，某个数据在短时间内会被频繁用到。<br>空间局部性：访问某个数据时，通过附近数据的概率也很大，比如循环访问数组数据。</p><p>Cache：用一块小而块的存储设备（采用SRAM实现），作为大而慢的存储设备的缓冲区，提高访存的速度，并降低功耗。考虑到时间、空间局部性原理，cache的作用就显而易见了。</p><p>cache的大小: cache size，cache平分成很多块称为cacheline，大小是 cache line size。比如，一个64Bytes的cache，平分成8个cache line，每个cache line大小是8Bytes</p><h4 id="分配策略-针对cacheline，读写缺省"><a href="#分配策略-针对cacheline，读写缺省" class="headerlink" title="分配策略(针对cacheline，读写缺省)"></a>分配策略(针对cacheline，读写缺省)</h4><ul><li><p>读分配：读取cache时，发生cache缺省，分配一个cache line缓存，用于读取数据。(天然满足)</p></li><li><p>写分配：写cache时，发生缺省时，从主存中加载数据到cacheline，更新该cacheline数据，将dirty位置1，等到替换时，再写入主存。</p></li></ul><h4 id="Cache更新策略（写cache命中）"><a href="#Cache更新策略（写cache命中）" class="headerlink" title="Cache更新策略（写cache命中）"></a>Cache更新策略（写cache命中）</h4><ul><li>写直通</li></ul><p>​当CPU执行store指令，在cache中命中时，既更新cache中数据也更新主存中的数据，保证数据一致性。</p><ul><li>写回</li></ul><p>​当CPU执行store指令并在cache命中时，我们只更新cache中的数据。并且每个cache line中会有一个bit位记录数据是否被修改过，称之为dirty bit。我们会将dirty bit置1。主存中的数据只会在cache line被替换或者显示的clean操作时更新。因此，主存中的数据可能是未修改的数据，而修改的数据躺在cache中。cache和主存的数据可能不一致。更新cacheline时，要根据dirty位，决定是否将数据写回内存。然后再进行其他操作</p><ul><li><h5 id="dirty-bit"><a href="#dirty-bit" class="headerlink" title="dirty bit"></a>dirty bit</h5></li></ul><p>​在写回的更新策略中，cache命中，首先会更新cacheline的数据，导致内存和cache中数据不一致，当该cache line被替代时，将替换的数据写到内存中。dirty bit是标记要写回到内存的cache line。</p><p><strong>通常写分配和写回策略一起使用</strong></p><hr><h4 id="两路组相连"><a href="#两路组相连" class="headerlink" title="两路组相连"></a>两路组相连</h4><p>将cache平均分成多份，每一份就是一路，两路组相连缓存就是将cache分为2份，每份32Bytes。</p><img src="/2024/022542394/image-20240225153918193.png" alt style="zoom: 33%;"><p>直接映射缓存每个地址只有一个cacheline的tag进行比较。</p><p>index也称为 组索引，相比于直接映射缓存，两路组相连映射缓存的index要少1bit，因为cache的个数少了一半，相当于一个addr地址对应于两个cacheline，然后通过tag比对两次，命中一个即cache命中。</p><p>优点：降低cache的颠簸可能性；<br>缺点：硬件成本高；</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>CPU读cache时</strong></li></ul><p>​若hit，CPU直接从cache读取数据即可<br>​若miss，<br>​Read allocate读分配：先从内存中读取数据到cache，再从cache中读数据。</p><ul><li><strong>CPU写cache时</strong></li></ul><p>​若hit，有两种处理方式<br>​Write thorough：把数据同时更新cache和内存中<br>​Write back ：先更新cacheline数据，被替换时再通过flush方式写入内存</p><p>​若miss，有两种方式<br>​Write allocate：先把数据读取到cache中，更新该cacheline，被替换时再通过flush方式写入内存<br>​No Write allocate：只更新主存数据</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA2.0</title>
      <link href="/2024/022437262.html"/>
      <url>/2024/022437262.html</url>
      
        <content type="html"><![CDATA[<h2 id="AMBA协议"><a href="#AMBA协议" class="headerlink" title="AMBA协议"></a>AMBA协议</h2><p>AHB协议：高性能总线，支持多主机，数据位宽可到32,64,128bit<br>APB协议：接口简单，适合低功耗。</p><ul><li><p>AHB信号说明</p><p>HADDR：地址总线<br>HTRANS[1:0]：传输类型，00：IDLE，01：BUSY，10：NONSEQ，11：SEQ<br>HWRITE：读写使能，高写低读<br>HSIZE[2:0]：描述数据的位宽，协议允许最大1024bit<br>HBURST[2:0]：突发类型，支持单拍传输，4,8,16拍增量、回环传输，以及不定义长度增量传输。（比axi多了不定长传输，少了fixed传输）</p><p>HWDATA：写数据总线</p><p>HSELx：slave选择信号</p><p>HRDATA：读数据总线</p><p>HREADY：传输完成信号，表示总线上的传输已经完成。</p><p>HRESEP：传输响应信号</p></li><li><p>仲裁信号</p><p>HBUSREQx：总线请求信号，master发出，最多16个master<br>HGRANTx：仲裁器发出，目前优先级最高的主机拉高。需要等待当前占用总线的slave传输完成，hready拉高且优先级最高的hgrantx拉高时，才会真正的切换总线 <strong>地址和控制信号</strong> 的所有权。<br>HMASTER[3:0]：仲裁器发出，表示当前哪个master正在占用总线；</p></li><li><p>APB信号</p><p>PADDR：APB地址总线<br>PSELx：从机选择信号<br>PENABLE：APB选通信号<br>PWRITE：读写使能信号，高写低读<br>PRDATA：读数据总线<br>PWDATA：写数据总线</p></li></ul><p><strong>等待状态的传输</strong></p><p>第一个地址周期，必须是从机的HREADY拉高，从机才可以采样到相应的地址和控制信息。后面的数据周期，同样需要从机HREADY拉高时才可以进行下面的操作。</p><img src="/2024/022437262/image-20240224173637302.png" alt="image-20240224173637302" style="zoom: 33%;"><p><strong>多重操作</strong></p><p>整个传输类似两级流水线，第一拍地址，第二拍数据。</p><img src="/2024/022437262/image-20240224174126020.png" alt="image-20240224174126020" style="zoom: 33%;"><ul><li><p><strong>AHB协议中最重要的两个信号：hreadyout和htrans</strong></p><p>隐含握手信号，htrans表示master输出数据的有效性，hreadyout表示slave准备好接收数据。类似axi4的valid和ready。</p><p>htrans：Busy是由于master没准备好，又想要占用总线而插在一个burst中的状态，如果采用了Idle，总线会重新仲裁，master对总线的占用权发生了变化（CPU中可能会出现）；Idle是插在两个burst之间，用来区分两次不同传输。</p></li><li><p>窄传输和宽传输</p><p>窄传输：从机的数据总线位宽 小于 主机的数据总线位宽，需要一定的外部逻辑就可以实现。比如64-&gt;32，通过地址的倒数第3bit选择高32bit还是低32bit给从机数据端口。</p><img src="/2024/022437262/image-20240224185833222.png" alt="image-20240224185833222" style="zoom: 33%;"><p>宽传输：从机的数据总线位宽 大于 主机的数据总线位宽。</p></li></ul><img src="/2024/022437262/image-20240224185855431.png" alt="image-20240224185855431" style="zoom:33%;"><ul><li><p>APB传输协议</p><img src="/2024/022437262/image-20240224191638563.png" alt style="zoom: 33%;"><img src="/2024/022437262/image-20240224192445131.png" style="zoom: 33%;"><img src="/2024/022437262/image-20240224192637732.png" alt="image-20240224192637732" style="zoom:33%;"><p>向apb的slave写数据，过程：首先向bridge写入地址和数据，需要两拍，然后继续向apb的从机写入数据，经过SetUp和Enable状态写入。</p><p>2.0协议中规定apb的slave没有响应信号。</p><p>为什么bridge的第一个写操作后需要等待一个周期，是因为ahb是pipline的，wdata的数据不能和setup同时到达，需要等待一个周期才可，如果是连续的写操作，则不需要这个等待状态。连续写操作不需要等待状态，是因为中间的缓存reg状态已经充满地址了，不需要等待一个周期了。</p></li><li><p>Retry和Split的区别</p><p>Retry和split都是ahb的slave在不能及时响应时发起的，retry后，不会影响此次master的优先级，并且会从头传输上次未传输完成的数据，split后，会影响master的优先级，并且会降低master的优先级，等待split的slave向arbiter发起准备好继续传输后，恢复master的优先级，重要的是恢复后的传输会从的split发生的位置继续传输，而不是从头传输。（在常见的soc系统中，slave的这两种传输一般不会发生）</p></li><li><p>数据和地址对齐</p><p>在APB中，地址和数据位宽是对齐的，如果PRDATA位宽是32bit，则PADDR[1:0]&#x3D;0，AHB中也有此要求，例如HSIZE&#x3D;1时，HADDR[0]&#x3D;0，HSIZE&#x3D;2时，HADDR[1:0] &#x3D; 0；HSIZE&#x3D;3时，HADDR[2:0] &#x3D; 0，以此类推。</p><p>AHB数据位宽最大多少 1024位，APB是32位最大位宽</p></li><li><p>地址越界</p><p>AXI系统中，slave地址空间一般为4KB的整数倍，如果burst传输地址范围超过了4kB就会传输错误。0x01000&#x3D;4KB<br>AHB系统中，salve地址空间一般为1KB的整数倍，如果burst传输地址范围超过了1kB就会传输错误。0x0400 &#x3D; 1KB<br>如果burst超过了4&#x2F;1KB边界，就要重新发起burst传输或者采用其他方式，取决于master行为。</p></li><li><p>AHB总线传输过程中的ERROR分析：</p><img src="/2024/022437262/image-20240224234749434.png" style="zoom: 67%;"><p>在error的倒数第二个周期hready需要拉低，表示不能再接收新的传输了（因为数据A传输过程中出现错误了），最后一个error周期，hready拉高了，（为什么拉高，因为IDLE状态下，不进行数据传输，hready就应该拉高，这是为了和复位时的状态保持一致吧），但是这个时候恢复到了IDLE状态，B的地址还是不能进行传输的，因为只有NONSEQ和SEQ才能进行地址的传输。进而保证了地址B不能进行有效传输。</p></li><li><p>还有一个原因是因为流水线的缘故，T3时刻的地址B已经传到总线上了，这也是为了防止在T3-T4周期，进行无效的数据B传输，所以需要设置为IDLE，而且一定要延迟这一拍，允许主机****有足够的的时间来取消地址B的传输****。（也就是说把地址B从总线上撤下来，或者说起到一个流水线冲刷的作用）</p></li></ul><p><img src="/2024/022437262/wps8.jpg" alt="img"> </p><p>​ERROR传输的两个周期中，第一个周期的hready是拉低的。</p><p>​ERROR的第二个周期，htrans是IDLE的，这种打断在AHB协议上是可以的，但是axi不支持</p><p>​ERROR传输的应用场景：译码错误，当master访问slave不存在的地址时。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总线协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C基础</title>
      <link href="/2024/02248418.html"/>
      <url>/2024/02248418.html</url>
      
        <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>堆栈</li></ul><p>stack堆是操作系统在编译时分配的，有一定的限制，是个定值；<br>heap栈是动态内存，由编程者自行决定；</p><img src="/2024/02248418/wps3.jpg" style="zoom:50%;"><p>eg. 存在函数返回值为指针时，由于返回的是地址，当stack内存被覆盖时，会引起读取数据错误，所以在返回值的地方要申请一块heap内存.</p><img src="/2024/02248418/wps4.jpg" style="zoom:50%;"><p>函数返回值为局部变量时，需要将变量设置为static静态变量，因为执行玩该函数,就会释放内存。如果返回值的是一个地址，那么后面再使用到该地址可能就不对了，因为他已经释放掉了。（static int *Add(int*a, int*b) ）</p><ul><li><p>内存泄露</p><p>内存泄漏指的是申请的动态内存heap，使用结束后没有释放，导致内存不足。</p></li></ul><h3 id="变量指针"><a href="#变量指针" class="headerlink" title="变量指针"></a>变量指针</h3><img src="/2024/02248418/wps1.jpg" style="zoom:50%;"><img src="/2024/02248418/wps2.jpg" alt="img" style="zoom:50%;"><pre class=" language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>c<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只允许读，不允许写</span></code></pre><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">*</span>a <span class="token operator">+</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> sum<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token operator">&amp;</span>add<span class="token punctuation">;</span>    sum <span class="token operator">=</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="static-extern关键字"><a href="#static-extern关键字" class="headerlink" title="static&#x2F;extern关键字"></a>static&#x2F;extern关键字</h2><p>Static可以用来修饰局部变量，保证在规定范围内，变量一直有效；</p><pre class=" language-C"><code class="language-C">#include<stdio.h>void test()&#123;    Static int a = 1;    a++;    printf("%d ", a);&#125;int main(void)&#123;    int i = 0;    while (i <= 10)    &#123;        test();        i++;    &#125;    return 0;&#125;// a的值只在函数内有效// Static修饰局部变量，修改了变量的生命周期，本质上改变了变量的存储范围，变成了静态存储区</code></pre><img src="/2024/02248418/wps6.png" alt="img" style="zoom:50%;"><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>Static修饰全局变量时，其他文件不可以访问该变量。<br>Extern声明的函数和变量，可以被其他文件访问。</p><img src="/2024/02248418/wps7.jpg" alt style="zoom: 67%;"><h2 id="全局结构体变量定义"><a href="#全局结构体变量定义" class="headerlink" title="全局结构体变量定义"></a>全局结构体变量定义</h2><p>​结构体是一种变量类型，最好方式是在.h文件定义，其他地方想用这个结构体，只需包含此.h文件即可，但是定义结构体变量的话，最好在.c文件定义，然后.h里面extern声明，其他.c文件想用只需包含.h文件即可。（为了防止重复定义，所以不建议在.h文件中直接定义变量）</p><pre class=" language-C"><code class="language-C">// a.ctemptype temp1,temp2,temp3;// 必须在函数里面使用才可以// a.htypedef struct &#123;    u8 disp_int;        //整数部分    u8 disp_flo;        //小数部分    u8 disp_flag;       //符号部分&#125;temptype; extern temptype temp1,temp2,temp3;// extern是一种“外部声明”的关键字，字面意思就是在此处声明某种变量或函数，在外部定义。// b.c#include “a.h”u8 data;data = temp1.disp_int;</code></pre><p>函数 extern &#x2F;&#x2F;不使用include</p><pre class=" language-C"><code class="language-C">a.c //定义extern int fun(int a, int b)&#123;    return a + b;&#125;b.c //声明#include<stdio.h>extern int fun(int a, int b);int main()&#123;    int result = fun(1, 3);    return 0;&#125;</code></pre><h2 id="ELF文件解析"><a href="#ELF文件解析" class="headerlink" title="ELF文件解析"></a>ELF文件解析</h2><p>程序中的段和节是真正的程序体，段包括代码段和数据段，多个节经过链接合并成一个段</p><p>段和节的信息都是通过header描述的，程序头是program header， 节头是section header；<br>段和节的大小都是不固定的，需要专门的数据结构来描述，即程序头表（program header table）和节头表（section header table）<br>这是两个数组，程序头表的元素全是程序头，节头表的元素全是节头。<br>程序头表是描述段的。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">get_syscall_name</span><span class="token punctuation">(</span>uintptr_t type<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> SYS_exit  <span class="token punctuation">:</span> <span class="token function">strcpy</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"SYS_exit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> SYS_gettimeofday<span class="token punctuation">:</span><span class="token function">strcpy</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"SYS_gettimeofday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Unhandled syscall"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> name<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>program break 是用户程序的数据段data segment结束的位置，链接的时候ld会默认添加一个名为_end的符号，指示程序的数据段结束位置。用户程序开始运行的时候, program break会位于_end所指示的位置, 意味着此时堆区的大小为0<br>通过访问end的地址即可得到program break，用户程序申请内存时，需要将递增后的program break作为地址传给系统调用，然后返回原来的program地址，供程序使用。</p><h3 id="C语言语法"><a href="#C语言语法" class="headerlink" title="C语言语法"></a>C语言语法</h3><h4 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h4><p><code>##(预处理器粘合剂)</code>：表示连接作用，比如，#define CON(x,y) x##y，表示 x和y接在一起<br><code>变参宏</code> ：比如 #define PR(…)  printf(_<em>VA_ARGS</em>_)</p><h4 id="位结构体"><a href="#位结构体" class="headerlink" title="位结构体"></a>位结构体</h4><p>​实现C中变量长度截断+符号位扩展，code如下</p><pre class=" language-C"><code class="language-C">#define SEXT(x, len) (&#123; struct &#123; int64_t n : len; &#125; __x = &#123; .n = x &#125;; (uint64_t)__x.n; &#125;)#define SEXT(x, len) (&#123;   struct &#123;     int64_t n : len;   &#125; __x = &#123;     .n = x   &#125;;   (uint64_t)__x.n; &#125;)</code></pre><p>可以整理成下面的形式进行分析，首先采用宏定义的形式，#define 关键一句在于‘int64_t n : len 表示只取n的后len位，对应于verilog变量的[len-1:0]位.<br>通过‘(uint64_t)__x.n; ，将len位的数据进行符号位扩展，符号位为n[len-1]的数据。</p><blockquote><p> 如果不采用这种方式进行符号位扩展的话，就会按照最高位为1的进行扩展，得到所有高位都是1，这种并不是我们想要的，比如一个10为的二进制数据：0010010101，扩展成16位，就会得到1111111110010101。这种不是我们要的结果。<br>如果按照上文提供的位结构体实现，就会得到0000000010010101，这才是我们想要的结果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-乘除法器设计</title>
      <link href="/2024/022240394.html"/>
      <url>/2024/022240394.html</url>
      
        <content type="html"><![CDATA[<h2 id="乘法器设计"><a href="#乘法器设计" class="headerlink" title="乘法器设计"></a>乘法器设计</h2><p>本设计采用基于4 Booth和华莱士树乘法器相结合的方式实现乘法；<br>一般乘法运算采用移位累加的方式实现，当乘法位数较大时，组合逻辑很大，且中间结果不易插入寄存器。在本设计的乘法中，<strong>Booth算法减小了部分积的个数，华莱士树算法提高了计算累加和的速度，且可以在中间插入寄存器，进一步提高主频和数据吞吐量</strong></p><h4 id="Booth算法"><a href="#Booth算法" class="headerlink" title="Booth算法"></a>Booth算法</h4><h5 id="booth乘法算法的条件"><a href="#booth乘法算法的条件" class="headerlink" title="booth乘法算法的条件"></a>booth乘法算法的条件</h5><ol><li>乘数和被乘数都是偶数，如果不是需要扩展符号位</li><li>补码运算，如果想要实现无符号数运算，需要在乘数和被乘数前面扩展两个0，然后按照补码运算</li></ol><p>编码的计算需要将乘数后面补0，一次完整的乘法共有N&#x2F;2个码元</p><img src="/2024/022240394/Booth_multiplication with shifter.png" alt="使用移位加实现Booth乘法" style="zoom: 33%;"><h5 id="key-point"><a href="#key-point" class="headerlink" title="key point"></a>key point</h5><ul><li><p>扩展符号位成偶数时，需要根据有无符号位进行扩展，如果是无符号，扩展0，如果有符号位，扩展符号位</p></li><li><p>在进行部分积累加中，每个cycle需要将累加寄存器右移两位，为的是对齐，得到真实的部分和，在下次加法时，保证是对齐的</p></li><li><p>在累加器右移过程中，需要扩展两位符号位，因为右移了2位，在下次操作时就要用到这两位符号位</p></li><li><p>booth两位运算规则</p></li></ul><table><thead><tr><th>yi+1</th><th>yi</th><th>yi-1</th><th>操作</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>+0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>+X补</td></tr><tr><td>0</td><td>1</td><td>0</td><td>+X补</td></tr><tr><td>0</td><td>1</td><td>1</td><td>+2X补</td></tr><tr><td>1</td><td>0</td><td>0</td><td>-2X补</td></tr><tr><td>1</td><td>0</td><td>1</td><td>-X补</td></tr><tr><td>1</td><td>1</td><td>0</td><td>-X补</td></tr><tr><td>1</td><td>1</td><td>1</td><td>+0</td></tr></tbody></table><p>本设计中乘法运算为 64bit * 64bit，booth算法本身是带符号的补码运算，如果要兼容无符号运算，需要在符号位前面扩展1bit，但是算法又规定乘数和被乘数都是偶数，所以还需要扩展1bit 符号位0，总共扩展2bit，exp_B为(66+1)bit，代码如下</p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">assign</span> exp_B <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">1'b0</span><span class="token punctuation">,</span> unsigned_flag<span class="token punctuation">,</span> B<span class="token punctuation">,</span> <span class="token number">1'b0</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最后补0是必须的，unsigned_flag = 1 => 表示无符号运算</span></code></pre><p>按照有符号补码运算，64bit的乘数，产生32个部分积；考虑无符号运算，还需要产生一个部分积，该部分积的产生规则如下：</p><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token keyword">case</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token number">3'b000</span><span class="token punctuation">,</span> <span class="token number">3'b111</span><span class="token punctuation">,</span> <span class="token number">3'b001</span> <span class="token punctuation">:</span>   P <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token number">3'b010</span> <span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>unsigned_flag<span class="token punctuation">)</span> P <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>   P <span class="token operator">=</span> X<span class="token punctuation">;</span>    <span class="token number">3'b110</span><span class="token punctuation">,</span> <span class="token number">3'b101</span> <span class="token punctuation">:</span> P <span class="token operator">=</span> <span class="token operator">~</span>X <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>                                 <span class="token number">3'b011</span> <span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>unsigned_flag<span class="token punctuation">)</span> P <span class="token operator">=</span> X<span class="token punctuation">;</span>            <span class="token keyword">else</span> P <span class="token operator">=</span> X <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token number">3'b100</span> <span class="token punctuation">:</span> P <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>X <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>                                               <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">// 无符号数运算，如果乘数的最高位为0，部分积为0；如果乘数的最高位为1，部分积为被乘数</span></code></pre><p><strong>最后，将部分积进行移位累加即可（每次累加和 移位2bit）</strong></p><h3 id="华莱士树算法"><a href="#华莱士树算法" class="headerlink" title="华莱士树算法"></a>华莱士树算法</h3><p><strong>本质是</strong> <strong>对累加的各个部分积进行压缩，最终压缩到单个C和S，通过加法器计算得到结果</strong></p><h4 id="进位保存加法器"><a href="#进位保存加法器" class="headerlink" title="进位保存加法器"></a><strong>进位保存加法器</strong></h4><ul><li>CAS （carry save adder）</li></ul><p>基本思想：将3个加数和减少为2个加数的和，将进位C和结果S分别计算保存，每个比特可以独立计算C和S，速度极快，一位的全加器相当于进位保留加法器 &#x3D;&gt; 3:2 压缩器。</p><p>比如一个算式如：Sum &#x3D; A + B + C + D，可以设计N bit的CAS结构，将多个数合并，经过两级CSA，最后将进位C[N-1:0]和Sum[N-1:0]通过一个加法器相加（<strong>注意将进位传给下面的CAS计算时，需要将C左移一位</strong>），得到最终结果。</p><img src="/2024/022240394/2.8_walloc_tree.4b50192e.png" alt style="zoom: 67%;"><p>上图是17bit的华莱士树，因为进位和输出结果都是同一个方向的，所以可以在每层之间插入寄存器打拍，提高主频。</p><p>相同bit的华莱士树有多种实现方式，如下图所示</p><img src="/2024/022240394/WORONG_exaxple of walllace tree.png" alt="两种错误的8个数相加的一位华莱士树" style="zoom: 33%;"><p>完成的功能相同，但是两者之间存在区别。<strong>关键点在于延迟</strong>，假设每个CSA部件的延迟为1，左面结构的结果延迟为5，右面为4。左面结构插入寄存器时，就会导致结果错误。</p><img src="/2024/022240394/image-20230811215003860.png" alt style="zoom: 33%;"><p>在设计华莱士树时，<strong>保证华莱士树的数据流是单向的，不会在该层之前进行操作，比如左图的进位C3，导致整个数据流发生了交叠</strong>。</p><h3 id="Booth算法×华莱士树算法"><a href="#Booth算法×华莱士树算法" class="headerlink" title="Booth算法×华莱士树算法"></a>Booth算法×华莱士树算法</h3><p>32位的乘法器结构如下，其中Switch模块完成将booth模块输出的结果打一拍，避免组合逻辑的延迟较长。</p><img src="/2024/022240394/image-20240222231842246.png" alt style="zoom: 33%;"><p>其中，booth输出的部分积，需要进行移位加才能进入到CSA模块中。代码如下</p><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// phase 1</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_1<span class="token punctuation">,</span> S1_1<span class="token punctuation">,</span> S2_1<span class="token punctuation">,</span> S3_1<span class="token punctuation">,</span> S4_1<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> C0_1<span class="token punctuation">,</span> C1_1<span class="token punctuation">,</span> C2_1<span class="token punctuation">,</span> C3_1<span class="token punctuation">,</span> C4_1<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa1</span><span class="token punctuation">(</span>in0<span class="token punctuation">,</span> in1<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">,</span> in2<span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">,</span> S0_1<span class="token punctuation">,</span> C0_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa2</span><span class="token punctuation">(</span>in3<span class="token operator">&lt;&lt;</span><span class="token number">6</span><span class="token punctuation">,</span> in4<span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">,</span> in5<span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">,</span> S1_1<span class="token punctuation">,</span> C1_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa3</span><span class="token punctuation">(</span>in6<span class="token operator">&lt;&lt;</span><span class="token number">12</span><span class="token punctuation">,</span> in7<span class="token operator">&lt;&lt;</span><span class="token number">14</span><span class="token punctuation">,</span> in8<span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">,</span> S2_1<span class="token punctuation">,</span> C2_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa4</span><span class="token punctuation">(</span>in9<span class="token operator">&lt;&lt;</span><span class="token number">18</span><span class="token punctuation">,</span> in10<span class="token operator">&lt;&lt;</span><span class="token number">20</span><span class="token punctuation">,</span> in11<span class="token operator">&lt;&lt;</span><span class="token number">22</span><span class="token punctuation">,</span> S3_1<span class="token punctuation">,</span> C3_1<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa5</span><span class="token punctuation">(</span>in12<span class="token operator">&lt;&lt;</span><span class="token number">24</span><span class="token punctuation">,</span> in13<span class="token operator">&lt;&lt;</span><span class="token number">26</span><span class="token punctuation">,</span> in14<span class="token operator">&lt;&lt;</span><span class="token number">28</span><span class="token punctuation">,</span> S4_1<span class="token punctuation">,</span> C4_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// phase 2</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> C0_2<span class="token punctuation">,</span> C1_2<span class="token punctuation">,</span> C2_2<span class="token punctuation">,</span> C3_2<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_2<span class="token punctuation">,</span> S1_2<span class="token punctuation">,</span> S2_2<span class="token punctuation">,</span> S3_2<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa6</span><span class="token punctuation">(</span>S0_1<span class="token punctuation">,</span> S1_1<span class="token punctuation">,</span> S2_1<span class="token punctuation">,</span> S0_2<span class="token punctuation">,</span> C0_2<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa7</span><span class="token punctuation">(</span>S3_1<span class="token punctuation">,</span> S4_1<span class="token punctuation">,</span> in15<span class="token operator">&lt;&lt;</span><span class="token number">30</span><span class="token punctuation">,</span> S1_2<span class="token punctuation">,</span> C1_2<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa8</span><span class="token punctuation">(</span><span class="token punctuation">(</span>C0_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C2_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S2_2<span class="token punctuation">,</span> C2_2<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa9</span><span class="token punctuation">(</span><span class="token punctuation">(</span>C3_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C4_1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> in16<span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">,</span> S3_2<span class="token punctuation">,</span> C3_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// phase 3</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_3<span class="token punctuation">,</span> C0_3<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S1_3<span class="token punctuation">,</span> C1_3<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa10</span><span class="token punctuation">(</span>S0_2<span class="token punctuation">,</span> S1_2<span class="token punctuation">,</span> S2_2<span class="token punctuation">,</span> S0_3<span class="token punctuation">,</span> C0_3<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa11</span><span class="token punctuation">(</span>S3_2<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S1_3<span class="token punctuation">,</span> C1_3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// phase 4</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_4<span class="token punctuation">,</span> C0_4<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S1_4<span class="token punctuation">,</span> C1_4<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa12</span><span class="token punctuation">(</span>S0_3<span class="token punctuation">,</span> S1_3<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_3 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S0_4<span class="token punctuation">,</span> C0_4<span class="token punctuation">)</span><span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa13</span><span class="token punctuation">(</span><span class="token punctuation">(</span>C2_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C3_2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_3 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S1_4<span class="token punctuation">,</span> C1_4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// phase 5</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> S0_5<span class="token punctuation">,</span> C0_5<span class="token punctuation">;</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa14</span><span class="token punctuation">(</span>S0_4<span class="token punctuation">,</span> S1_4<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_4 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S0_5<span class="token punctuation">,</span> C0_5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// phase 6</span>CSA #<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">WIDTH</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">csa15</span><span class="token punctuation">(</span>S0_5<span class="token punctuation">,</span> <span class="token punctuation">(</span>C0_5 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>C1_4 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> S<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> OUT <span class="token operator">=</span> S <span class="token operator">+</span> <span class="token punctuation">(</span>C <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="除法器设计"><a href="#除法器设计" class="headerlink" title="除法器设计"></a>除法器设计</h2><p>被除数Dividend &#x2F; 除数Divisor &#x3D; 商Quotient ······ 余数Remainder</p><p>简单的迭代除法是 <strong>试商法</strong>，迭代过程中，如果不够减，商0，根据是否恢复余数，分为恢复余数法（循环减法）、不恢复余数法（加减交替）。</p><p><strong>区别</strong>：逐位计算商的时候，不够减商0；如果是恢复余数算法，需要将余数加上除数；如果是不恢复余数算法，不需要加上余数，在下个周期时加上除数。</p><h3 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h3><p>64bit 绝对值 恢复余数除法运算结构如下</p><img src="/2024/022240394/image-20240223154401784.png" alt style="zoom:50%;"><p>优点：面积小，节省资源。缺点：速度慢</p><p>计算过程：被除数前面补64个0，记为A，除数为B，每个周期执行减法运算，判断ALU输出的符号，如果为负，寄存器A左移1bit且右面补0，不需要将ALU结果写入寄存器A；如果为正，寄存器A左移1bit，右面补1，将ALU计算结果写入寄存器A的高64位；以此类推，经过64个周期，从寄存器A中得到商和余数。最终，根据是否是 有符号计算，对输出结果进行处理。</p><p>其中，ALU采用补码进行减法运算。**[X - Y]补 &#x3D; [X]补 + [-Y]补**，  <strong>[-Y]补 &#x3D; [Y]补码 取反 + 1</strong></p><p>如果要同时支持无符号和有符号除法运算，需要对输入的数据进行预处理。根据被除数和除数的符号，决定 <strong>商和余数的符号</strong>；将有符号除法转换成无符号除法。</p><table><thead><tr><th align="center">被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td align="center">正</td><td>正</td><td>正</td><td>正</td></tr><tr><td align="center">正</td><td>负</td><td>负</td><td>正</td></tr><tr><td align="center">负</td><td>正</td><td>负</td><td>负</td></tr><tr><td align="center">负</td><td>负</td><td>正</td><td>负</td></tr></tbody></table><pre class=" language-verilog"><code class="language-verilog">    <span class="token keyword">assign</span> dividend_unsigned <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                                dividend<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">?</span>                               <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">1'b0</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">~</span>dividend<span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span> <span class="token punctuation">:</span> dividend                                <span class="token punctuation">:</span> dividend<span class="token punctuation">;</span>    <span class="token keyword">assign</span> divisor_unsigned <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                               divisor<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">?</span>                              <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">1'b0</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">~</span>divisor<span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span> <span class="token punctuation">:</span> divisor                              <span class="token punctuation">:</span> divisor<span class="token punctuation">;</span>    <span class="token keyword">assign</span> merchant   <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                         <span class="token punctuation">(</span>dividend<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">^</span> divisor<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span>                        <span class="token operator">-</span>merchant_t <span class="token punctuation">:</span> merchant_t                        <span class="token punctuation">:</span> merchant_t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最后一次商结果作为最终的商</span>    <span class="token keyword">assign</span> remainder  <span class="token operator">=</span> signed_flag <span class="token operator">?</span>                         dividend<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">?</span>                         <span class="token operator">-</span>remainder_t <span class="token punctuation">:</span> remainder_t                        <span class="token punctuation">:</span> remainder_t<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最后一次余数作为最终的余数</span></code></pre><h2 id="乘除法器-接入流水线CPU"><a href="#乘除法器-接入流水线CPU" class="headerlink" title="乘除法器 接入流水线CPU"></a>乘除法器 接入流水线CPU</h2><p>乘除法器都是多个周期才出结果，因此，需要握手信号。当乘除法指令到执行阶段时，Div&#x2F;Mul模块发出stall信号，等待valid和ready信号握手，输出计算结果，撤销stall信号，继续执行后续指令。</p><img src="/2024/022240394/image-20240222232209980.png" alt style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-Cache设计（三）</title>
      <link href="/2024/022113792.html"/>
      <url>/2024/022113792.html</url>
      
        <content type="html"><![CDATA[<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><h4 id="Fence指令"><a href="#Fence指令" class="headerlink" title="Fence指令"></a>Fence指令</h4><p>在前续集合predecessor执行到FENCE指令前的任何操作前，处于FENCE指令后的后续集合（successor）中的任何操作，都不能被其他任何RISC-V线程或者外部设备看到。即FENCE就像一个栅栏，FENCE之前所有的存储器操作、IO操作必须完成后，在FENCE指令之后的指令才能看到结果。 </p><h4 id="fence-i"><a href="#fence-i" class="headerlink" title="fence.i"></a>fence.i</h4><p>原因：store指令可能会对内存中的程序区进行修改，而icache可能看不到程序的修改，而读取错误的指令，导致程序运行错误。<br>目的：为了解决数据与指令的一致性问题，即icache和dcache的一致性。当执行fence.i指令时，fence之前的所有存储操作，io操作必须完成后，fence指令后面的指令才能访问内存。</p><h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><p>译码阶段遇到fence.i指令，icache和dcache的具体操作：</p><ol><li>对icache中的cachemem进行刷新，完成初始化，保证后面的所有取指令操作都是从内存中获取。</li><li>对dcache中cachemem的所有dirty置1的cacheline写到内存中，保证内存中代码区和数据区的一致性。</li></ol><h3 id="icache"><a href="#icache" class="headerlink" title="icache"></a>icache</h3><p>fence模块发出flash，stall和nop使能信号，将取指令的pc地址保持不变，将进入if阶段的fence指令通过nop冲刷掉，也就是说icache的cachemem一个周期就要完成冲刷。</p><img src="/2024/022113792/image-20240222105149731.png" alt style="zoom:50%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>    flash <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>fence_i<span class="token punctuation">)</span>    flash <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>flash_done<span class="token punctuation">)</span>    flash <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> stall <span class="token operator">=</span> flash <span class="token operator">|</span> fence_i<span class="token punctuation">;</span><span class="token keyword">assign</span> nop <span class="token operator">=</span> stall<span class="token punctuation">;</span></code></pre><h3 id="dcache"><a href="#dcache" class="headerlink" title="dcache"></a>dcache</h3><p>设置FLASH和FLASH_DONE状态，等待到fence.i指令流水到访存阶段，进入FLASH状态，遍历所有cacheline，将所有脏（dirty）块写到内存中；cachesize为2k，cacheline为8byte，设置axi_wlen为255，突发传输256 beats，通过wstrb决定是否将wdata写入内存。</p><p>遍历结束后，wlast拉高，进入FLASH_DONE状态，拉高flash_done，pc重新从内存中取指令，流水线继续执行，完成了icache和dcache的一致性。</p><img src="/2024/022113792/image-20240222112053777.png" alt style="zoom: 50%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span>        IDLE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> flash <span class="token operator">?</span> FLASH <span class="token punctuation">:</span>                            <span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> dirty <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> WRITEBACK <span class="token punctuation">:</span>                            <span class="token punctuation">(</span><span class="token operator">!</span>hit <span class="token operator">&amp;&amp;</span> valid<span class="token punctuation">)</span> <span class="token operator">?</span> RADDR <span class="token punctuation">:</span> IDLE<span class="token punctuation">;</span>        WRITEBACK <span class="token punctuation">:</span> next_state <span class="token operator">=</span> WADDR<span class="token punctuation">;</span>        ALLOCATE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>        RADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_arvalid <span class="token operator">&amp;&amp;</span> axi_arready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> RDATA<span class="token punctuation">;</span>        RDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_rvalid  <span class="token operator">&amp;&amp;</span> axi_rready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> ALLOCATE<span class="token punctuation">;</span>        WADDR <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_awvalid <span class="token operator">&amp;&amp;</span> axi_awready<span class="token punctuation">)</span> next_state <span class="token operator">=</span> WDATA<span class="token punctuation">;</span>        WDATA <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_wvalid  <span class="token operator">&amp;&amp;</span> axi_wready <span class="token operator">&amp;&amp;</span> axi_wlast <span class="token punctuation">)</span> next_state <span class="token operator">=</span> WRESP<span class="token punctuation">;</span>        WRESP <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>axi_bvalid  <span class="token operator">&amp;&amp;</span> axi_bready <span class="token punctuation">)</span> next_state <span class="token operator">=</span> flash_flag <span class="token operator">?</span> FLASH_DONE <span class="token punctuation">:</span> RADDR<span class="token punctuation">;</span>        FLASH <span class="token punctuation">:</span> next_state <span class="token operator">=</span> WADDR<span class="token punctuation">;</span>        FLASH_DONE <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token punctuation">:</span> next_state <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token keyword">assign</span> axi_wstrb  <span class="token operator">=</span> <span class="token punctuation">(</span>flash_flag<span class="token operator">&amp;</span>dirty<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b11111111</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>flash_flag<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'b0000_0000</span> <span class="token punctuation">:</span> byte_enable<span class="token punctuation">;</span><span class="token keyword">assign</span> axi_wlast  <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> WDATA<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flash_cnt <span class="token operator">==</span> CACHE_SIZE<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>flash_flag<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分频器设计</title>
      <link href="/2024/022118538.html"/>
      <url>/2024/022118538.html</url>
      
        <content type="html"><![CDATA[<p>分频器主要有以下几种设计</p><ol><li>偶分频（50%占空比）</li><li>奇分频（非50%占空比）</li><li>奇分频（50%占空比）</li><li>半整数（x.5）分频（非50%占空比）</li><li>任意小数分频（非50%占空比）</li></ol><h3 id="1-偶分频（50-占空比）"><a href="#1-偶分频（50-占空比）" class="headerlink" title="1. 偶分频（50%占空比）"></a>1. 偶分频（50%占空比）</h3><p>假设偶分频系数为N， 共有两种方式实现50%的偶分频。<br>方式1：计数到 N&#x2F;2-1，将clk_out翻转。</p><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span>posedeg clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;=</span> N<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        clkout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> N<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        clkout <span class="token operator">&lt;=</span> <span class="token operator">~</span>clkout<span class="token punctuation">;</span><span class="token keyword">end</span></code></pre><p>方式2：计数到N-1，小于 N&#x2F;2 - 1，clkout输出0，否则输出1；(可实现不同占空比)</p><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span>        clk_out <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;=</span> N<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        clk_out <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_out <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span></code></pre><h3 id="2-奇分频（非50-占空比）"><a href="#2-奇分频（非50-占空比）" class="headerlink" title="2. 奇分频（非50%占空比）"></a>2. 奇分频（非50%占空比）</h3><p>不需要使用双边沿逻辑，和偶分频的第二种方式类似。</p><h3 id="3-奇分频（50-占空比）"><a href="#3-奇分频（50-占空比）" class="headerlink" title="3. 奇分频（50%占空比）"></a>3. 奇分频（50%占空比）</h3><p>需要双边沿逻辑；假设实现占空比50%的5分频，实现方法：</p><ol><li>采用正沿和负沿分别实现5分频</li><li>占空比为（5-1）&#x2F;2个源时钟周期</li><li>正沿和负沿产生的时钟信号做 <strong>或</strong></li></ol><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span> Odd_div_50p #<span class="token punctuation">(</span>    <span class="token keyword">parameter</span> N <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       clk_in<span class="token punctuation">,</span>    <span class="token keyword">input</span>       nrst<span class="token punctuation">,</span>        <span class="token keyword">output</span>      clk_out <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> clk_pos<span class="token punctuation">,</span> clk_neg<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt_pos<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt_neg<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        cnt_pos <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_pos <span class="token operator">==</span> N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cnt_pos <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        cnt_pos <span class="token operator">&lt;=</span> cnt_pos <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        cnt_neg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_neg <span class="token operator">==</span> N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cnt_neg <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        cnt_neg <span class="token operator">&lt;=</span> cnt_neg <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">// clk_pos clk_neg</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_pos <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt_neg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> clk_out <span class="token operator">=</span> clk_pos <span class="token operator">|</span> clk_neg<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre><h3 id="4-半整数（x-5）分频（非50-占空比）"><a href="#4-半整数（x-5）分频（非50-占空比）" class="headerlink" title="4. 半整数（x.5）分频（非50%占空比）"></a>4. 半整数（x.5）分频（非50%占空比）</h3><p>假设实现3.5分频，正沿计数器循环计数到7，分别交替产生分频比为4和3的时钟信号，平均下来得到的时钟信号为（4+3）&#x2F; 2 &#x3D; 3.5分频。但是每个分频时钟不是严格的3.5分频。<strong>因此，需要对不均匀的分频比进行调整，采用负沿计数器计数到7，分别交替产生分频比为3和4的时钟信号</strong>，将正沿和负沿产的时钟信号做 <strong>与</strong>操作，得到均匀的3.5分频的时钟信号。</p><img src="/2024/022118538/image-20240221164423487.png" alt style="zoom:67%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span> Half_Int_div #<span class="token punctuation">(</span>    <span class="token keyword">parameter</span> N <span class="token operator">=</span> <span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>           clk_in<span class="token punctuation">,</span>    <span class="token keyword">input</span>           nrst<span class="token punctuation">,</span>    <span class="token keyword">output</span>          clk_out                      <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">localparam</span> Naddp5 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> Nsubp5 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pos_vth<span class="token punctuation">,</span> neg_vth<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pos_cnt<span class="token punctuation">,</span> neg_cnt<span class="token punctuation">;</span><span class="token keyword">reg</span> clk_pos<span class="token punctuation">,</span> clk_neg<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        pos_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>pos_cnt <span class="token operator">&lt;=</span> pos_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        pos_cnt <span class="token operator">&lt;=</span> pos_cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         pos_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         pos_vth <span class="token operator">&lt;=</span> Naddp5<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>pos_cnt <span class="token operator">==</span> pos_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>pos_vth <span class="token operator">==</span> Naddp5<span class="token punctuation">)</span>            pos_vth <span class="token operator">&lt;=</span> Nsubp5<span class="token punctuation">;</span>        <span class="token keyword">else</span>            pos_vth <span class="token operator">&lt;=</span> Naddp5<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>pos_cnt <span class="token operator">==</span> <span class="token number">'h0</span><span class="token punctuation">)</span>        clk_pos <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_pos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        neg_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>neg_cnt <span class="token operator">&lt;=</span> neg_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        neg_cnt <span class="token operator">&lt;=</span> neg_cnt <span class="token operator">+</span> <span class="token number">'h1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         neg_cnt <span class="token operator">&lt;=</span> <span class="token number">'h0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>         neg_vth <span class="token operator">&lt;=</span> Nsubp5<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>neg_cnt <span class="token operator">==</span> neg_vth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>neg_vth <span class="token operator">==</span> Nsubp5<span class="token punctuation">)</span>            neg_vth <span class="token operator">&lt;=</span> Naddp5<span class="token punctuation">;</span>        <span class="token keyword">else</span>            neg_vth <span class="token operator">&lt;=</span> Nsubp5<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk_in <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>neg_cnt <span class="token operator">==</span> <span class="token number">'h0</span><span class="token punctuation">)</span>        clk_neg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         clk_neg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">assign</span> clk_out <span class="token operator">=</span> clk_pos <span class="token operator">|</span> clk_neg<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre><h3 id="5-任意小数分频（非50-占空比）"><a href="#5-任意小数分频（非50-占空比）" class="headerlink" title="5. 任意小数分频（非50%占空比）"></a>5. 任意小数分频（非50%占空比）</h3><p>同样不能做到50%的占空比。基于可变分频和平均分频得到，在长时间内，得到小数分频比。<br>比如7.6分频，保证76个源时钟周期时间内，目的时钟经过10个周期的时间。即对源时钟进行 <strong>6次8分频，4次7分频（6*8+4*7&#x3D;76）。</strong>5.76分频，对源时钟进行 <strong>76次6分频，24次5分频</strong></p><p>以 7.6 倍分频为例，7 分频和 8 分频的实现顺序一般有以下 4 种：</p><p>(1) 先进行 4 次 7 分频，再进行 6 次 8 分频；<br>(2) 先进行 6 次 8 分频，再进行 4 次 7 分频；<br>(3) 将 4 次 7 分频平均的插入到 6 次 8 分频中；<br>(4) 将 6 次 8 分频平均的插入到 4 次 7 分频中。</p><p>前两种方法时钟频率不均匀，相位抖动较大，所以一般会采用后两种平均插入的方法进行小数分频操作。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dc_flow</title>
      <link href="/2024/02206923.html"/>
      <url>/2024/02206923.html</url>
      
        <content type="html"><![CDATA[<h2 id="dc-topo模式"><a href="#dc-topo模式" class="headerlink" title="dc_topo模式"></a>dc_topo模式</h2><p>dc_topo模式 指 在综合时考虑物理约束，需要ICC阶段生成的def文件。<br>流程：<br>       1. dct生成一版网表netlist，给ICC，导出floorplan的DEF文件<br>       2. 根据icc导出的def文件，重新在dct模式下综合，得到的网表更准确<br>       3. compile_ultra</p><img src="/2024/02206923/image-20240220161903358.png" alt style="zoom: 50%;"><pre class=" language-tcl"><code class="language-tcl"><span class="token operator">/</span><span class="token operator">/</span> icc 写def 命令write_def <span class="token operator">-</span>output name.def<span class="token operator">/</span><span class="token operator">/</span> dct 读def命令extract_physical_constraints name.def</code></pre><p><strong>注意事项：第一次时，topo模式需要创建milkway，第二次进入dct模式时，已经有def文件，但是不需要创建milkway库，直接打开就可以</strong></p><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><ol><li><p>将设计与工艺库中stdcel进行对应。</p></li><li><p>将设计连接到这些库单元上。</p><p>link后，生成没有工艺库对应的getch库文件，以ddc的格式保存。</p><p>link后，进行uniquify，创建同一个reference的不同instance，以便根据不同的物理环境做优化。</p></li></ol><h3 id="report-芯片面积"><a href="#report-芯片面积" class="headerlink" title="report 芯片面积"></a>report 芯片面积</h3><p>三种方式描述面积：1. 晶体管级 transitor 2. 2输入与非门的个数 3. 实际的面积</p><p>report_area 输出实际的面积,也会显示综合后的标准单元个数。如果想要转换到与非门的个数，将报出的面积除以与非门的面积，得到2输入与非门个数。</p><p>查看综合后的网表有多少门</p><pre><code>sizeof_collection [get_cells * h]</code></pre><p>查看2输入与非门的面积：</p><ol><li>打开logic 库，查看NA2的面积，<strong>tsmc65大概是2.16平方微米</strong>。</li><li>tcl查询，NAND2的属性 attribution <code>get_attribute[get_lib_cell */nand2]</code> </li><li>单独综合一个与非门，查看面积。</li></ol>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生一芯-CPU流水线设计（一）</title>
      <link href="/2024/021950375.html"/>
      <url>/2024/021950375.html</url>
      
        <content type="html"><![CDATA[<p>将整个结构划分为五级，相比于单周期的CPU，在流水线设计过程中主要解决数据冒险和结构冒险。</p><h2 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h2><p>将数据旁路模块bypass放在译码阶段（id），与教材中放在执行阶段不同，原因是可以减少寄存器堆的一个读端口。（译码to执行阶段 写寄存器的时候，Write back阶段已经将数据写入到寄存器堆中，所以要单独设置一个读端口读取写入寄存器堆的数据）。</p><p>数据旁路的数据来源有四个：</p><ol><li>id译码阶段的寄存器堆输出 </li><li>exe执行阶段的结果 </li><li>ls访存阶段的结果 </li><li>wb写回阶段的结果。</li></ol><img src="/2024/021950375/image-20240220111048796.png" alt style="zoom: 33%;"><p>​判断条件:  </p><pre class=" language-verilog"><code class="language-verilog"><span class="token function">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>rs1_id <span class="token operator">==</span> xx_rdid<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>xx_rdwen<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs1_id <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    发生数据旁路<span class="token keyword">else</span>     不发生数据旁路<span class="token comment" spellcheck="true">// 如果源寄存器的id为0时，不能进行数据旁路，因为默认寄存器堆的0号寄存器值常0</span></code></pre><p><strong>特别：如果在exe阶段的指令是load指令，且发生了数据冒险，需要将流水线停顿一拍，等待进入访问阶段才能得到真正的数据</strong>。 这种情况称为” load use”型指令，需要发出stall和nop使能。</p><p><img src="/2024/021950375/image-20240220134957838.png"></p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">assign</span> stall <span class="token operator">=</span> <span class="token punctuation">(</span>rs1id <span class="token operator">==</span> ex_rdid<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>rs2id <span class="token operator">==</span> ex_rdid<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ex_rdwen <span class="token operator">&amp;&amp;</span> ex_lden<span class="token keyword">assign</span> nop <span class="token operator">=</span> stall<span class="token punctuation">;</span></code></pre><h2 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h2><p>控制冒险的处理放在译码阶段，而不是执行阶段，这样做可以提前决定指令执行顺序；</p><p>采用静态分支预测方式，当预测失败时，PC地址发生跳转，跳转地址在bru中计算得到；否则，执行PC+4。</p><img src="/2024/021950375/image-20240220144307189.png" alt style="zoom: 50%;"><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">assign</span> nop <span class="token operator">=</span> jalr <span class="token operator">||</span> jal <span class="token operator">||</span> brch<span class="token punctuation">;</span><span class="token keyword">assign</span> jump_en <span class="token operator">=</span> nop<span class="token punctuation">;</span></code></pre><img src="/2024/021950375/image-20240220150606788.png" alt style="zoom: 50%;"><h2 id="数据冒险-控制冒险-冲突"><a href="#数据冒险-控制冒险-冲突" class="headerlink" title="数据冒险+控制冒险 冲突"></a>数据冒险+控制冒险 冲突</h2><p>当译码阶段的指令是jalr时，rs1发生了数据冒险，且是load-use类型，bypass模块发出stall和nop信号；bru模块发出jump和nop信号。对于IF_ID寄存器，同时收到了bypass的stall和bru的nop信号。<strong>此时，产生了冒险冲突</strong></p><p>解决办法：<strong>先stall处理完数据冒险，再nop处理控制冒险保证处理控制冒险时，跳转地址的计算是正确的。</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">// exauipc a5 0x0ld   a5 595(a5)jalr  a5 </code></pre><p><img src="/2024/021950375/image-20240220152550379.png"></p><h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>实现srlw指令出现的问题：</p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> srlw<span class="token punctuation">;</span> <span class="token important">always </span>srlw <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">32</span><span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span>data_A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span>data_A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>></span> data_B<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// right</span><span class="token important">always </span>srlw <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span><span class="token number">32'b0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token number">#123</span><span class="token punctuation">;</span>data_A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>></span> data_B<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token number">#125</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// wrong</span><span class="token comment" spellcheck="true">// 存在特殊情况，如果data_A[31]为1，且data_B为0，srlw的高32位应该全为1.</span></code></pre><p>如果srlw指令中的data_B &gt;&#x3D; 1，srlw结果高32bit都为0，两种方式的结果一致；<br>如果srlw指令中的data_B &#x3D; 0，data_A的第32bit为0，两种方式结果一致；<br>如果srlw指令中的data_B &#x3D; 0，data_A的第32bit为1，两种方式结果不一致；第一种是正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk用法</title>
      <link href="/2024/021721611.html"/>
      <url>/2024/021721611.html</url>
      
        <content type="html"><![CDATA[<h3 id="Awk处理文本数据"><a href="#Awk处理文本数据" class="headerlink" title="Awk处理文本数据"></a><strong>Awk处理文本数据</strong></h3><p>格式：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">awk</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> ‘匹配规则和处理规则’  <span class="token punctuation">[</span>处理文本路径<span class="token punctuation">]</span></code></pre><ul><li><p>处理规则：</p><p>BEGIN{}: BEGIN是在awk处理文本之前运行</p><p><strong>&#x2F; &#x2F; ： 使用的匹配原则</strong></p><p>{}：循环（每次处理一行）</p><p>END{}: 当所有行执行完毕后，执行END的操作</p></li></ul><p>原理：</p><ol><li><p>awk会接收一行作为输入，将这一行赋给awk的内部变量$0，行的边界是以换行符作为结束的。</p></li><li><p>刚刚读入的行被以:为分隔符分解成若干字段（或域），每个字段存储在已编号的变量中，编号从$1开始，最多达100个字段，-F 指定分隔符，默认是空格。</p></li><li><p>使用print打印，如果$1$3之间没有逗号，输出时贴在一起，如果添加”,”，$1和$3之间默认用空格分开，通过OFS修改输出的间隔符   ‘BEGIN{OFS&#x3D;”-“}{print $1,$3}’</p></li><li><p>输出后，获取下一行，执行上述操作</p></li></ol><h5 id="awk变量"><a href="#awk变量" class="headerlink" title="awk变量"></a><strong>awk变量</strong></h5><pre class=" language-tcl"><code class="language-tcl">$<span class="token variable">0</span>:当前行的内容NR：行号NF: 总字段数FS：输入字段分隔符，默认空格OFS：输出字段分隔符</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'&amp;#123;if(NR > 7)&amp;#123;print NR,<span class="token variable">$0</span>&amp;#125;&amp;#125;'</span> /etc/passwd<span class="token operator">==</span> <span class="token function">awk</span> -F: <span class="token string">'NR > 7 &amp;#123;print NR,<span class="token variable">$0</span>&amp;#125;'</span> /etc/passwd// 输出第7行之后的内容指定<span class="token string">','</span>作为分隔符，-F<span class="token string">','</span>-F:  ：表示以<span class="token string">':'</span>作为分隔符<span class="token function">awk</span> -F<span class="token string">':'</span> <span class="token string">'BEGIN&amp;#123;FS=","&amp;#125;&amp;#123;print <span class="token variable">$1</span>,<span class="token variable">$2</span>&amp;#125;'</span> FS的优先级大于-F指定的输出指定分隔符<span class="token function">awk</span> -F<span class="token string">':'</span> <span class="token string">'BEGIN&amp;#123;OFS=" >>> "&amp;#125;&amp;#123;print <span class="token variable">$1</span>,<span class="token variable">$2</span>&amp;#125;'</span></code></pre><ul><li><strong>正则表达式</strong></li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'/^xxx/'</span> /etc/passwd</code></pre><ul><li>条件模式</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'NR > 7'</span> /etc/passwd</code></pre><ul><li>算数运算</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'&amp;#123;print <span class="token variable">$1</span>,<span class="token variable">$2</span>+1&amp;#125;'</span></code></pre><ul><li>if判断</li></ul><pre class=" language-bash"><code class="language-bash">单分支：    if<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>双分支：    if<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125; else &amp;#123;&amp;#125;</span>多分支：    if<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125; else if()&amp;#123;&amp;#125; else &amp;#123;&amp;#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk文本处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AXI协议</title>
      <link href="/2024/02077053.html"/>
      <url>/2024/02077053.html</url>
      
        <content type="html"><![CDATA[<h3 id="AXI协议"><a href="#AXI协议" class="headerlink" title="AXI协议"></a>AXI协议</h3><h4 id="AXI3和AXI4的区别"><a href="#AXI3和AXI4的区别" class="headerlink" title="AXI3和AXI4的区别"></a>AXI3和AXI4的区别</h4><h5 id="1-Burst"><a href="#1-Burst" class="headerlink" title="1. Burst"></a>1. Burst</h5><p>AXI4对burst length进行了扩展<br>AXI4支持最大256 beats，AxLEN位宽为8；AXI3最大支持burst 16 beats，AxLEN位宽为4；</p><p>只有INCR burst类型，才支持burst 超过16 beats</p><p><img src="/2024/02077053/image-20240207000854573.png"></p><p>实际使用中，很少使用burst超过16 beats的操作，因为长时间占用总线会影响系统性能。而且burst 一旦开始，无法停止。</p><p>axi4协议规定 一次burst，最多传输256笔数据。</p><h5 id="2-Write-interleaving"><a href="#2-Write-interleaving" class="headerlink" title="2. Write interleaving"></a>2. Write interleaving</h5><p>AXI4去掉了WID，不再支持写交织（write interleaving）。<br>这就限制了写入的数据必须和写入的地址顺序相同且连续。不同write burst的beat不可以相互交织。</p><p>原因：发送端必须要缓存多个ID的wdata，不管是maser还是总线interconnection都必须要增加大量的缓存，所以增加了面积；另外，Write interleaving增加了系统总线设计的复杂度，而且很容易造成死锁，</p><h5 id="3-Write-response-dependencies"><a href="#3-Write-response-dependencies" class="headerlink" title="3. Write response dependencies"></a>3. Write response dependencies</h5><p>修改了BVALID拉高的要求</p><p>AXI3握手依赖</p><p><img src="/2024/02077053/v2-0160a446a10236e56609b0bc7fcc541e_1440w.png"></p><p>AXI3必须等到了WVALID和WREADY后才能把BVALID置高来响应，也就是说只要收到了所有数据，SLAVE就可以发写响应。</p><p>AXI4握手依赖</p><p><img src="/2024/02077053/v2-12a2457485825157ceaaa25f358b7ae7_1440w.png"></p><p>​AXI4规定，必须等到AWVALID,AWREADY,WVALID, WREADY, and WLAST 都为高(不是同一时刻都为高)后，SLAVE才能发BVALID进行写响应。也就是不仅仅要等数据通路，而且要等地址通路，并且明确了要等WLAST。这样能保证响应的时候Transaction是真正完成的</p><h5 id="4-Locked-transactions"><a href="#4-Locked-transactions" class="headerlink" title="4. Locked transactions"></a>4. Locked transactions</h5><p>​AXI4去掉了locked 传输。AxLOCK缩为2bit</p><img src="/2024/02077053/v2-52896f5fa4a0dfe4c2c6a4a4645664a9_1440w.png" alt style="zoom:67%;"><p>​Locked access作用的对象是总线，一旦发生Locked access，那么其他的master都不能使用总线了，在一个复杂的SOC系统中，Locked access对系统的影响就太大了，万一发生Locked access的master出点啥问题，整个系统就挂死了</p><p>​Exclusive access 作用的对象是对应的Slave，支持Exclusive access的Slave会在slave中实现一个Exclusive access monitor，如果monitor记录了能够访问的master，那么对应的master就能通过Exclusive access来访问，其他的未记录的Exclusive access就都不能访问。Exclusive access对总线系统是没有要求的，只是对slave做了特殊要求，即使出错也不会影响系统其他部分，最多访问失败而已。</p><h4 id="窄传输"><a href="#窄传输" class="headerlink" title="窄传输"></a>窄传输</h4><p>当数据传输的位宽小于数据总线的位宽时，称为窄位宽传输。通常通过wstrb来控制哪些字节有效。<br>当从机自身限制或者其他客观条件时，比如从机每次只能接收1个字节数据，且不能缓冲多字节数据，<strong>主机就要进行窄传输。</strong>可以将传输数据都放在数据总线上，每次传输只需要改变wstrb即可。</p><p>32位数据总线，wstrb为4bit；64位数据总线，wstrb是8bit。</p><p>AXI-Lite协议</p><ul><li><p>不支持突发传输，且每次传输一个数据，没有last信号；</p></li><li><p>支持多master，多slave</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总线协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低功耗设计</title>
      <link href="/2024/020534087.html"/>
      <url>/2024/020534087.html</url>
      
        <content type="html"><![CDATA[<h1 id="低功耗设计"><a href="#低功耗设计" class="headerlink" title="低功耗设计"></a>低功耗设计</h1><p>时钟频率的增加导致功耗的增加，温度升高带来大规模集成电路的散热问题，导致性能下降。</p><p>功耗和能量是两个不同的概念。能量是一段时间内的消耗，而功率是瞬时的能量。</p><img src="/2024/020534087/v2-ea250d565bf82da5061f7cb7687b5252_1440w.webp" alt style="zoom:67%;"><p>SOC芯片的功耗分为：动态功耗和静态功耗</p><p>动态功耗又分为：翻转功耗（开关功耗，电容充放电功耗，switching power）和短路功耗（内部功耗，internal power）</p><ol><li><p>翻转功耗表达式：<img src="/2024/020534087/v2-e2be66370380c970f5e36e3aff3f8720_1440w.png"><br>得出降低功耗，可以通过降低电源电压，降低翻转概率，减小负载</p></li><li><p>内部功耗：在信号翻转时，存在NMOS和PMOS同时导通的情形，产生了VDD到GND的通路，形成了短路电流。</p></li></ol><p>静态功耗：在没有信号变化时，由于漏电流所引起的功耗。</p><img src="/2024/020534087/v2-30817fdf230a2209d3e42a37f4abbcf7_1440w.webp" alt style="zoom: 67%;">静态功耗的计算方式：<img src="/2024/020534087/v2-bf118d5d1de06f0f9110d057f1910cdf_1440w.png" alt="img" style="zoom:50%;"><p>SOC中，不同结构的功耗贡献是不一样的</p><ol><li>时钟树功耗：通常占整个功耗的40%；(门控时钟技术很重要)</li><li>CPU：时钟频率越来越高，功耗越来越大。（采用大小核，不同场景使用不同的处理器核）</li><li>GPU：CPU的并行处理单元，多个模块同时工作，功耗较大。很多SOC不带GPU或者默认关闭</li><li>存储器：DDR作为SOC的主存，时刻需要调用。</li></ol><p>从上面的公式看出，降低功耗最有效的办法是<strong>降低电源电压</strong></p><h2 id="多电压技术"><a href="#多电压技术" class="headerlink" title="多电压技术"></a>多电压技术</h2><p>思想：1. 针对不同的模块，采用不同的电压。2. 同一个模块，做不同的事情，采用不同的电压</p><ul><li><p>静态多电压技术 MSV：Multi Supply Vdd</p><p>将设计中不同的功能模块划分为不同的电压域(Power domain, PD). 每个电压域对应于设计中的一个或多个子模块。</p><p>原则：<strong>在满足系统性能(频率)要求的基础上，采用最低电压</strong></p><p>缺点：需要不同的电源电压供电，以及不同电压域的level shifter，增加了设计的复杂度</p></li><li><p>动态电压频率缩放技术 DVFS：Dynamic Voltage and Frequency Scaling</p><p>根据芯片所运行的应用程序对计算能力的不同需要，监控芯片的工作负载，动态调节芯片的运行频率和电压。在保证性能的同时，降低电压，实现减少功耗的目的。</p><p><img src="/2024/020534087/v2-013caae8290aa4e7e666a3366f4924b2_1440w.webp"></p><p>​管理单元监控工作状态，根据运行状态控制电压生成单元和频率生成单元调整工作模块的电压VDD和频率f。一般采样软件算法进行判决来控制管理单元生成需要的电压和频率。（开环调节）</p></li><li><p>自适应电压频率调节技术 AVFS ：Adaptive Voltage and Frequency Scaling</p><p>软件根据不同的应用场景，选择不同的电压和频率。对不同的模块能够自适应的调节电压和频率。</p><p>AVFS是一个闭环方案，在运行过程中自动完成调节，不需要外部干预。换句话说，它不固定电压和频率的一一对应关系，而是将对温度，传播延时等因素在运行时予以补偿。（闭环调节，复杂度很高）</p></li><li><p>电压关断技术 PSO：Power Shut Off</p><p>不使用的模块，关断其电压。断电后，设计进入睡眠模式，其漏电功率很小。唤醒时，为了使模块尽快恢复工作模式，需要保持关电前的状态。保持寄存器(retention register)可用于记忆状态。</p><p>为了在电源关断时不影响其他部分的逻辑，电源门控模块的输出端需要使用隔离单元(Isolation Cell)，因为在睡眠模式时，模块的输出为不确定值。为了保证在睡眠模式时，下一级的输入不会悬空，插入隔离单元，保持一个”1”或”0”的输出。</p></li></ul><h4 id="ASIC-低功耗中常使用的特殊单元"><a href="#ASIC-低功耗中常使用的特殊单元" class="headerlink" title="ASIC 低功耗中常使用的特殊单元"></a>ASIC 低功耗中常使用的特殊单元</h4><ol><li><p>Isolation cell</p><p>隔离单元，某个电压域关闭时，可以保持输出或者输入为常数。</p><p>两个原因：1. 防止虚假信号传播到未关闭电压的域，导致逻辑错误。2. 防止产生瞬态电路，带来功耗。</p><img src="/2024/020534087/v2-1f2eefb144af1ca428447621fa7e8812_1440w.webp" alt style="zoom:67%;"></li></ol><p>​典型的Shutdown PD的ISO，AND和OR门都可以构成一个isolation cell。AND类型，输出常0，OR类型，输出常1。控制信号power_ctrl必须在AON域。</p><p>​考虑到power-on rail的走线，isolation cell自身的功耗，一般还是放在input端比较好，因为放在input端不需要always-on的power。</p><img src="/2024/020534087/v2-483302cba227a51c6ab093adc887f513_1440w.png" alt style="zoom:50%;"><ol start="2"><li><p>isolation cell</p><p>将信号从一个电压域切换到另一个电压域，如果不进行电压转换，器件就无法正常工作。</p></li></ol><img src="/2024/020534087/v2-554cee9ed18ce8e73c597e165d274a39_1440w.webp" alt style="zoom:50%;"><p>​通常LS和ISO会一起用，所以会把两个cell合成一个，叫做enable level shifter (ELS)</p><img src="/2024/020534087/v2-59fb4635fb7452017136fd232fb5efa2_1440w.webp" alt style="zoom:50%;"><ol start="3"><li>Power Switches</li></ol><p>​电源开关单元提供了关闭逻辑域的电源的能力</p><ol start="4"><li>Always-on Cells</li></ol><p>​电源管理单元需要保持激活，即使这些单元周围的逻辑已经被关闭，这就行需要用到Always-on cells，它的供电来自于不会被关断的电源域(always-on domain), 但是被摆放在可以被关断的电源域。</p><ol start="5"><li>Retention Cells</li></ol><p>​Retention cell: 保留单元，一种能够在电源关闭的情况下，能保持内部状态的特殊单元。</p><h4 id="在各设计抽象层次降低功耗"><a href="#在各设计抽象层次降低功耗" class="headerlink" title="在各设计抽象层次降低功耗"></a>在各设计抽象层次降低功耗</h4><p>层次越高对功耗降低越有效。</p><img src="/2024/020534087/image-20240223093647968.png" alt style="zoom:50%;"><ul><li><p>系统级</p><p>通过合理划分软硬件的功能，可以有效降低功耗。<br>编写C程序时，可以考虑优化指令条数来编写C程序。<br>处理器的选择会对整体功耗产生明显的影响。对于特定的应用，可以使用协处理器或者专门的DSP处理数据。</p></li><li><p>体系结构级</p><ol><li><p>门控时钟技术</p><p>常用的门控时钟单元 <strong>锁存器+与门</strong> （时序门控时钟）</p><p>组合门控时钟如下所示</p><img src="/2024/020534087/image-20240223111132118.png" alt style="zoom: 50%;"><p>对于输入的时钟信号是组合逻辑产生的，所以称为组合门控时钟，缺点是容易产生毛刺。</p><p>时序门控时钟如下所示</p><img src="/2024/020534087/image-20240223111242133.png" alt style="zoom:50%;"><p>时钟使能信号经过寄存器或者锁存器，再与时钟信号做 <strong>与</strong>，称为时序门控时钟，没有毛刺产生。</p></li><li><p>动态电压频率调节 DVFS</p><p>本质：牺牲性能，降低功耗。<br>P&#x3D;V^2 * CL*f，电压与功耗成平方关系，根据特定情况选择电压和频率，可以大大降低功耗。</p></li><li><p>基于缓存的系统体系架构</p><p>缓存的意义：某些场景需要频繁访问存储器，可以设置缓存，提高访问速度。同时，也大大降低了功耗。（牺牲了硬件成本和面积）</p></li><li><p>多阈值电压</p><p>需要工艺库提供相同电压，不同阈值的cell。在满足时序要求下，提高Vt，降低功耗，但是面积也会相应增加。</p></li><li><p>多电压域</p><p>不同模块根据不同需求，采用不同电压。需要工艺库中提供特殊的电压转化cell。</p></li></ol></li><li><p>寄存器传输级 （RTL实现）</p><ol><li><p>状态机编码和解码</p><p>格雷码最合适低功耗设计，相邻状态跳变，只有1bit信号发生翻转，并且降低了产生毛刺的概率。降低功耗。</p></li><li><p>多路选择器采用独热码</p><p>如果mux的输入是多位总线，会产生明显的开关过程，产生功耗。如果按照独热码方式，在初始的时候就可以mask一些未选中的总线，起到了降低功耗作用。</p></li><li><p>资源共享</p><p>优化组合逻辑，共用相同的逻辑，减小不必要的计算，降低功耗。</p></li></ol></li><li><p>寄存器级</p><p>通过优化物理版图、MOS管结构降低功耗。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机体系结构</title>
      <link href="/2024/012760393.html"/>
      <url>/2024/012760393.html</url>
      
        <content type="html"><![CDATA[<p>超流水线：<br>    通过增加流水线级数来缩短指令执行速度。细化流水，提高主频。用时间换空间。超流水线技术对芯片的工作速度要求比较高，同时硬件系统比较复杂，需要占用较大的芯片的面积，因此超流水线结构在嵌入式RISC处理器中很少采用。</p><p>超标量：<br>    一个时钟周期可以发射多条指令，CPU中有一条以上的流水线，每个周期可以完成一条以上的指令。用硬件来换速度。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路设计（RTL）</title>
      <link href="/2024/012448005.html"/>
      <url>/2024/012448005.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>课题组项目 后端指导前端 log</p><p>在做pt eco的时候，有个模块lms_delay的路径修复好几次都不成功。report_timing发现组合逻辑的路径太长造成的。检查RTL代码确实是先进行了减法 又进行了乘法，中间没有打拍。</p><p>采取的方式：在减法和乘法之间，打一拍，而且没有影响功能。</p></li><li><p>对齐</p><p>用空格将等号对齐，提高代码的可读性和美观性。</p></li><li><p>布线太密的原因</p><ul><li>第一个原因：寄存器位宽太大，如果对该数据进行了很多逻辑操作，就会出现布线密集的情况。</li><li>第二个原因：负载太大，1对多，一个信号在很多地方使用，也会导致布线密集。解决办法：使用寄存器复制的方式。</li></ul></li></ul><img src="/2024/012448005/640.png" alt style="zoom:50%;"><img src="/2024/012448005/640-1706455914012-3.png" alt style="zoom:50%;"><ul><li><p>面积优化策略</p><p>面积：加法器 &gt; 比较器 &gt; 选择器.<br>乘法器本质也是加法器。<br>策略：<strong>先选后加，先选后比，先选后乘</strong></p></li><li><p>表达式位宽</p><p>利用中间值，使得结果没有歧义，比如乘法的结果是a+b的位宽之和，$unsigned(a*b)的位宽是a&#x2F;b中最大的一个，与z的定义不同。</p><p><img src="/2024/012448005/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxODQyMDk3,size_16,color_FFFFFF,t_70.png"></p></li><li><p>有符号数的部分选择</p></li></ul><p>​部分选择有符号数，得到的切片仍然是无符号数。哪怕选择了整个向量也是无符号的，如 input signed[7:0] a 中 a[7:0] 也会被认为是无符号的。</p><p>​若表达式中有一个数为无符号数，Verilog会把整个表述为无符号的，导致功能失常。</p><ul><li><p>有符号数运算</p><p>如果是有符号数的运算，在定义时使用signed声明比较好，而不是用无符号数模拟有符号数，这样综合得到的电路更好。但是如果运算中既有无符号数，又有有符号数，结果就是无符号数的计算。</p><p><img src="/2024/012448005/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxODQyMDk3,size_16,color_FFFFFF,t_70-1706971897728-3.png"></p></li><li><p>条件完备的case是没有优先级的，条件不完备是有优先级的。</p></li></ul><h3 id="大小端对齐"><a href="#大小端对齐" class="headerlink" title="大小端对齐"></a>大小端对齐</h3><p>大端对齐：MSB最高有效字节在内存中对应低地址；（高地址对应高位数据）<br>小端对齐：MSB最高有效字节在内存中对应高地址；地址偏移量和字节数是一一对应的关系；（低地址对应低位数据）</p><p>eg. 对于16进制数据0x12345678在内存中的保存方式</p><p><img src="/2024/012448005/image-20240221225921219.png"></p><p>优点：大端模式，很容易通过访问最低位地址，判断数值的正负。</p><h3 id="亚稳态问题"><a href="#亚稳态问题" class="headerlink" title="亚稳态问题"></a>亚稳态问题</h3><p>当数据不满足建立setup和保持hold时间时，会出现亚稳态问题。<br>解决办法（单bit）：1. 多级同步器 2. 时钟倍频电路的多级同步器<br>方法1需要较长时间去响应异步输入，解决办法：使用倍频时钟作为两个同步器的时钟输入。（Altera的FPGA中具有这项称为时钟倍频的技术，减小异步信号输入的延迟）</p><img src="/2024/012448005/image-20240219205135401.png" alt="时钟倍频电路的多级同步器" style="zoom:50%;"><ul><li><p>寄存器的输出 驱动 另一个寄存器的异步复位端</p><p>第二级寄存器的时钟和复位之间存在潜在的竞争关系。</p></li></ul><img src="/2024/012448005/image-20240219223205525.png" alt="异步复位" style="zoom: 33%;"><ul><li><p>锁存器生成对应的电路</p><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span>clk<span class="token punctuation">)</span>   <span class="token function">if</span><span class="token punctuation">(</span>clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>      b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>      b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">end</span></code></pre></li></ul><img src="/2024/012448005/image-20240219225204769.png" alt style="zoom:50%;"><p>​某些FPGA架构不支持锁存器，在综合时会将锁存器综合成 带有反馈的组合逻辑实现。</p><img src="/2024/012448005/image-20240219225414951.png" alt style="zoom: 50%;"><p>​<strong>虽然该结构有锁存数据的能力，但是可能会违背建立时间和保持时间的要求，跟带电平触发的锁存器是不一样的。在设计中不应包含任何组合逻辑环路</strong>。<br>​锁存器并不是不能存在的，可以用来挪用周期或借用时间来满足关键路径的要求。（time borrowing)</p><ul><li>内部时钟产生</li></ul><p>​毛刺出现在数据上，不会有太大影响，因为是边沿采样；如果毛刺出现在时钟上，会产生明显的影响。比如，由于时钟毛刺，使得计数器的值多增加1。因此，寄存器的输入时钟最好不是经过组合逻辑处理得到的。<br>​解决办法：将组合逻辑输出的时钟，打拍寄存器输出。</p><ul><li><p>门控时钟和时钟使能技术</p><p>门控时钟：当门控关闭后，时钟网络和内部的组合逻辑停止翻转，减小功耗。</p><img src="/2024/012448005/image-20240220103515514.png" alt style="zoom:67%;"></li></ul><p>​同步时钟使能：以同步的方式，将输出拉死，并没有关闭时钟，而是将寄存器的输出保持不变，无法降低功耗。</p><img src="/2024/012448005/image-20240220103631732.png" alt style="zoom:67%;"><ul><li><p>门控时钟电路</p><p><strong>不带锁存器的门控时钟</strong>，使用“与”门 或者 “或”门实现。</p><img src="/2024/012448005/image-20240220104808503.png" alt style="zoom:50%;"></li></ul><p>​存在问题：en和clk是完全异步的，使得时钟输出畸形；</p><img src="/2024/012448005/image-20240220104905125.png" alt style="zoom:50%;"><p>​<strong>带锁存器的门控时钟</strong></p><p>​为了防止高电平被意外截断，需要使用锁存器保证 在CLK为1时，即使EN拉低，GATED_CLK输出保持不变。所以需要负锁存器，在CLK拉低时，对EN进行采样，CLK拉高时锁存器的输出不变。这样可以得到完整的时钟波形</p><img src="/2024/012448005/image-20240220105432984.png" alt style="zoom: 50%;"><p><strong>使用锁存器而不使用寄存器的原因：节省面积，一个DFF需要两个锁存器，而且还能降低功耗</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>icc_flow</title>
      <link href="/2024/012139355.html"/>
      <url>/2024/012139355.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>decap cell的插入</p><p>解决IR drop的，为逻辑单元提供稳定的电压。去耦电容，提供稳定的电源和地，降低电源噪声和提高电噪声免疫性的特殊电路元件。<br>Decap cell是小电容器，位于整个布局的VDD和GND之间。当逻辑电路汲取大量电流时，该电容器为该电路提供额外的电荷当逻辑电路不吸收任何电流时，decap cell被充电至最大电容利用decap cell来降低动态IR drop。<br>decap cell是带金属层的，建议routing结束后再加，否则影响route走线。</p></li></ul><img src="/2024/012139355/image-20240121233331816.png" alt style="zoom:50%;"><ul><li><p>filler cell</p><p>为确保所有VDD和VSS rail连接正常，我们需要使用filler cell填充标准单元row中的空白区域。filler cell没有逻辑连接，同时还包含衬底nwell连接以改善衬底偏置。</p></li></ul><p>​在routing后进行的，先插入decap cell，再插入filler cell</p><p>​插完decap cell和filler cell之后，我们可以发现整个设计都被cell给填充了，可以把芯片的表面做平，<strong>在stdcell区域是不允许有间隙的存在的</strong>，也可以用命令checkFiller来检查。</p><p>​<strong>作用：</strong></p><ol><li><p><strong>平整表面</strong>：在后续的工艺步骤中，便于后续工艺的抛光。</p></li><li><p><strong>获得连续的VDD和VSS</strong></p></li><li><p>保证版图连续性和均匀性，保证掺杂均匀性，减小工艺变异，增强结构稳健性。</p></li><li><p><strong>优化功耗和性能</strong>：通过在空白区域添加 Filler Cells，电流路径可能会更均匀，有助于减少电磁干扰和功耗。</p></li></ol><ul><li><p>dummy</p><p>主要有以下几种用途：</p><ol><li>保证可制造性，DFM。tapeout时会检查芯片的密度，插入dummy mental，dummy poly，dummy diff</li><li>在关键器件旁边加入dummy 器件，比如cap，res，mos等</li><li>避免芯片中的noise对关键信号的影响，在关键信号的周围加上dummy routing layer或者dummy元器件，shielding。</li></ol></li><li><p>获取整个design的instance个数和面积</p><p>report_qor</p><img src="/2024/012139355/image-20240123212321424.png" alt style="zoom:67%;"><img src="/2024/012139355/abc207bf21bdcaa65b8339f664292df.jpg" alt style="zoom: 33%;"></li></ul><p>​gate count计算：等效的门数，只是一个粗略的计算，不是精确值。将两输入与非门的面积作为等效参考，即一个gate的面积。用所有std cell的面积除以2输入与非门的面积，得到是数值为用到的总门数。总门数*4得到的是晶体管数目。</p><blockquote><p>DC综合两输入与非门的面积为1.44，所有cell的总面积为41.2w平方微米。等效门数为41.2&#x2F;1.44 &#x3D; 28.61w逻辑门。</p></blockquote><ul><li><p>查看clock skew的值</p><ol><li><p>通过report_timing</p><p>得到的skew会偏大一些，因为skew经过derate。</p></li><li><p>通过report clcok tree</p></li></ol></li><li><p>clock skew的设置</p><p>在长时钟树时，要设置targe skew，告诉工具clock skew期望值多少，一般设置为50-80ps，100ps以内都正常。</p></li></ul><p>ICC cts的相关设置</p><p><a href="https://www.cnblogs.com/IClearner/p/6606360.html">https://www.cnblogs.com/IClearner/p/6606360.html</a></p><ul><li><p>wire spreading（连线扩展）</p><p>也成为critical area analysis关键区域分析的地方</p><p>bg：制造过程中可能会出现随机的颗粒缺陷导致短路或者开路<br>最小间距的连线最容易造成短路，最小宽度的连线最容易造成开路。</p><p>解决办法：容易短路的地方，增加间距。容易断路的地方，增加线宽。</p><img src="/2024/012139355/20200729093453667.png" alt style="zoom: 67%;">icc_tcl:  spread_zrt_wires / widen_zrt_wires</li><li><p>检查placement是否合法</p></li></ul><p>​placement后，执行<code>check_legality</code></p><ul><li>ICC 在导入网表后，没有tie cell是正常的，因为是在placement才加入tie cell；High Fanout Net也是正常的，还没有插入buffer进行优化。</li></ul><img src="/2024/012139355/image-20231224214002120.png" style="zoom: 67%;"><ul><li>后端流程</li></ul><img src="/2024/012139355/image-20231224215828226.png" alt style="zoom:67%;"><ul><li>时序库 （*.lib， *db）表征的2个模型</li></ul><p>​.NLDM (non linear delay model)，65nm 之前工艺 </p><p>​.CCS （composite current source）, 更精确，同时能描述crosstalk （信号干扰）的信息 </p><ul><li>max_transition &#x2F; input_transition</li></ul><p>​一般来说，sdc中关于max_transition的值参考lib库中给定的transition值，尽量取中间范围。transition设置的过小也不好，会导致工具插入很多cell，增大了芯片的面积。</p><p>​解决措施：在DC和ICC时设置max_transition为0.4，在PT时设置0.6</p><p><img src="/2024/012139355/3158545f6cb70988f94b0214218380a.jpg"></p><p>出现上述问题的原因是因为在做lvs时，网表与版图不匹配，可以将icc生成的网表导入到calibre里面做lvs。在icc pr后的网表中，在module里面并没有上述的Q端口，而是使用的Qn，接一个反相器输出的，这个是和版图对应的。</p><p>CCS的lib中有 crosstalk的信息；</p><p>物理信息库<br>     1. LEF(library exchange format): cadence 的物理信息库，只有布局布线要用到信息，pins…<br>     2. milkway：synopsys的物理库<br>     3. GDS：流片用的信息，所有的层次都有<br>     4. CDL：器件级spice网表，lvs和仿真</p><p><img src="/2024/012139355/wps2.jpg">（LEF GDS)</p><p>DC在做综合的时候，把DRC的约束优先级设置为最高，依次是：max_capacitance,max_transition, max_fanout</p><p>DC中报告的漏电功耗是准的，动态功耗不准。</p><ul><li><h4 id="Formality"><a href="#Formality" class="headerlink" title="Formality"></a><strong>Formality</strong></h4><p>只验证逻辑，不验证功能。比较的原理：formality将设计分为多个logic cone和compare point</p><img src="/2024/012139355/image-20240102224954497.png" alt style="zoom: 80%;"></li></ul><p><img src="/2024/012139355/image-20240102225055027.png"></p><ul><li><p>DC和PT分析时序路径的不同</p><p>DC</p><ol><li>过约束，留出一定的裕量给后续的步骤</li><li>时钟网络的延迟的不准确的，一定设置为ideal clock network</li><li>线延迟也是基于库中的wire load model估计出来的</li><li>通常在单一PVT的corner进行的，比如wc</li></ol><p>ICC</p><ol><li>不需要过约束，根据实际的电路计算</li><li>所有网络 clock，wire network均为实际的</li><li>可以从版图中抽取RC寄生参数，计算net delay</li><li>需要在多个PVT corner下验证</li></ol></li><li><p>修复setup违例</p><p>满足 Tskew + Tclk &gt; Tlogic + Tsetup + Tclk2q</p><ol><li>提高Tclk，降低频率</li><li>减小Tlogic，优化组合逻辑，划分流水线</li><li>减小Tclk2q，将HVT管换成LVT管子，速度变快</li></ol></li><li><p>修复hold违例</p><p>满足Tclk2q + Tlogic(min) &gt; Thold + Tskew</p><ol><li>增加组合逻辑延迟，插入buffer</li><li>降低Tskew，甚至用负的skew</li></ol></li></ul><p>SDF：标准延迟格式的文件，描述了设计中的时序信息，包括net delay和cell delay，sdf文件可以直接用于后仿</p><p>SPEF：标准寄生格式交换文件，提供具体的R和C参数，延时计算相对准确。</p><p><img src="/2024/012139355/image-20240103100523201.png"></p><p>在PT中设置clock约束时和DC的区别</p><p><img src="/2024/012139355/image-20240103100716030.png"></p><p><img src="/2024/012139355/image-20240103101023594.png"></p><p>ECO是在post layout上进行的。</p><p>PT自动进行ECO，PT工具主要通过resizing cells和插入buffer来完成ECO</p><ul><li><p>OCV</p><p><strong>只在post layout进行分析。</strong></p></li><li><p>约束输入端口</p><pre><code>set_drive_cellset_driveset_input_transition</code></pre><p>这三条语句都是约束输入端口的，但是适用场景不同。</p><ol><li><p>set_drive_cell</p><p>应用场景：Block level<br>从库中找一个cell来驱动这个模块的输入端口port，更贴近实际的情况。这种应用于模块级别的。</p></li><li><p>set_drive</p><p>应用场景：Chip level<br>通过为输入端口指定电阻值的方法来为其定义外部驱动强度，典型的值是0.05，单位取工艺库中电阻的单位，一般为kΩ；该值越小表示驱动能力越大</p></li><li><p>set_input_transition</p><p>应用场景：Chip level<br>为输入端口指定一个固定的transition时间，transition时间相对独立于当前设计中的电容。transition time越大，导致短路电流越大，功耗也越大。</p></li></ol></li><li><p><strong>课题组项目后端的细节处理</strong></p><ol><li>在版图布局中，由于SPI模块与数字芯片core的位置距离较远，需要对数字芯片CORE的输入端口进行约束，设置input_transition_time为0.5；并在SPI的输入端口添加模拟的buffer，提高驱动能力。</li><li>在之前的芯片测试时，发现控制字的输入有问题，有时候需要SPI写入两次才能起作用。后来怀疑是SPI模块给到数字core的时钟信号走线太长，到core时候，clk的驱动就比较弱了。再后面的流片时，在数字core的clk输入端口加了buffer，解决了这个问题。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StarRC_flow</title>
      <link href="/2024/012044084.html"/>
      <url>/2024/012044084.html</url>
      
        <content type="html"><![CDATA[<p>根据TSMC signoff的标准</p><p><img src="/2024/012044084/image-20240120174002288.png"></p><p>整理如下：</p><table><thead><tr><th><strong>setup</strong></th><th>process</th><th>voltage</th><th>tempature</th><th>library db</th><th>spef</th></tr></thead><tbody><tr><td>wc+Cworst</td><td>ss</td><td>1.08v</td><td>125</td><td>tcbn65lpwc1d081d08_ccs</td><td>Cworst125</td></tr><tr><td>wcl+Cworst</td><td>ss</td><td>1.08v</td><td>-40</td><td>tcbn65lpwcl1d081d08_ccs</td><td>Cworstm40</td></tr><tr><td><strong>tc+Ctypical</strong></td><td><strong>tt</strong></td><td><strong>1.2v</strong></td><td><strong>-40</strong></td><td><strong>tcbn65lplt1d21d2_ccs</strong></td><td><strong>Ctypical25</strong></td></tr><tr><td><strong>hold</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>wc+Cworst</td><td>ss</td><td>1.08v</td><td>125</td><td>tcbn65lpwc1d081d08_ccs</td><td>Cworst125</td></tr><tr><td>wcl+Cworst</td><td>ss</td><td>1.08v</td><td>-40</td><td>tcbn65lpwcl1d081d08_ccs</td><td>Cworstm40</td></tr><tr><td><del>bc+Cworst</del></td><td><del>ff</del></td><td><del>1.32v</del></td><td><del>0</del></td><td><del>tcbn65lpbc1d321d32_ccs</del></td><td><del>Cworst0</del></td></tr><tr><td><del>bc+Cbest</del></td><td><del>ff</del></td><td><del>1.32v</del></td><td><del>0</del></td><td><del>tcbn65lpbc1d321d32_ccs</del></td><td><del>Cbest0</del></td></tr><tr><td>lt+Cworst</td><td>ff</td><td>1.32v</td><td>-40</td><td>tcbn65lplt1d321d32_ccs</td><td>Cworstm40</td></tr><tr><td>lt+Cbest</td><td>ff</td><td>1.32v</td><td>-40</td><td>tcbn65lplt1d321d32_ccs</td><td>Cbestm40</td></tr><tr><td><strong>tc+Ctypical</strong></td><td><strong>tt</strong></td><td><strong>1.2v</strong></td><td><strong>-40</strong></td><td><strong>tcbn65lplt1d21d2_ccs</strong></td><td><strong>Ctypical25</strong></td></tr></tbody></table><blockquote><p>删除的bc+Cbest&#x2F;Cworst，原因是这两种case位于wc和lt之间，没必须再去分析。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StarRC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcl脚本</title>
      <link href="/2024/011824060.html"/>
      <url>/2024/011824060.html</url>
      
        <content type="html"><![CDATA[<p>set endp xxx&#x2F;D</p><p>set path [get_timing_path -to $endp -group reg2reg]</p><p>set points [get_attri $path points]</p><p>point有很多属性</p><img src="/2024/011824060/image-20240118232406988.png" alt style="zoom:50%;"><pre class=" language-tcl"><code class="language-tcl">foreach_in_coll point $<span class="token variable">points</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token keyword">set</span> <span class="token variable">obj</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">point</span> object<span class="token punctuation">]</span>     <span class="token keyword">set</span> <span class="token variable">objn</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">obj</span> full_name<span class="token punctuation">]</span>    <span class="token keyword">set</span> <span class="token variable">dir</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">obj</span> dir<span class="token punctuation">]</span>    <span class="token builtin">if</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;dir=="in"&amp;#125; &amp;#123;continue&amp;#125;</span>    <span class="token keyword">set</span> <span class="token variable">inst</span> <span class="token punctuation">[</span><span class="token keyword">file</span> dir $<span class="token variable">objn</span><span class="token punctuation">]</span>    <span class="token keyword">set</span> <span class="token variable">cell</span> <span class="token punctuation">[</span>get_cell $<span class="token variable">inst</span><span class="token punctuation">]</span>    <span class="token keyword">set</span> <span class="token variable">ref</span> <span class="token punctuation">[</span>get_attri $<span class="token variable">cell</span> ref_name<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token builtin">proc</span> <span class="token function">is_hvt</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;ref&amp;#125; &amp;#123;</span>    <span class="token builtin">if</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;string match "*_HVT" $ref&amp;#125; &amp;#123;</span>        retrun 1    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125; else &amp;#123;retrun 0&amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token comment" spellcheck="true"># if &amp;#123;![is_hvt $ref] || ![is_lvt $ref]&amp;#125; &amp;#123;&amp;#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tcl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PT flow</title>
      <link href="/2024/011821871.html"/>
      <url>/2024/011821871.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>检查反标率</p><p>跑PT时，需要保证每个corner使用的lib和spef是对应的。读入设计的spef和网表netlist后，需要report_annotated_parasitics命令报出反标情况。</p></li></ul><p>​反标问题我们是看Pin to pin nets的反标，如果这一行的Not Annotated非0，那么就一定存在RC反标问题。常见反标问题原因：</p><pre class=" language-tcl"><code class="language-tcl">spef正确，但netlist错误Netlist正确，spef错误</code></pre><img src="/2024/011821871/image-20240118192337980.png" alt style="zoom: 50%;"><p>手修timing</p><pre class=" language-markdown"><code class="language-markdown">size_cell U324 INVD8</code></pre><ul><li><p>setup </p><p>替换大驱动的cell。 x4 &#x3D;&gt; x16<br>(有时候替换了大cell，delay会增加，因为驱动能力的增加不足以抵消input transition和output load的增加)</p></li><li><p>max_capacitance </p><p>方法1：替换大的cell，提高阈值。<br>方法2：减小实际的capacitance，通过在ICC中插入buffer实现</p></li><li><p>max_transition</p><p>方法1：替换大的cell，提高阈值。<br>方法2：减小实际的transition，通过在ICC中插入buffer实现</p></li><li><p>hold</p><ul><li>get_lib_cell  *&#x2F;*BUF*</li><li>insert_buffer [通过report_timing -delay_type min 得到的] *BUF*</li></ul></li></ul><p> report_constraint  -all_violators：可以看出违例的endpoint  summary</p><p>syn off :关闭高亮显示</p><p>查看某个net连接的cell：all_fanout -from U503&#x2F;E -flat -endpoints_only</p><p>report_timing -transition -from U399 -delay_type max:可以查看具体的cell</p><h3 id="timing-eco"><a href="#timing-eco" class="headerlink" title="timing eco"></a>timing eco</h3><p>修违例的顺序：1. drc的错误 2. 再修setup hold</p><p>尽可能使用size_cell来修违例，而不用insert_buffer，因为RC是准确的，保证net delay是对的。</p><p>如果想运行dmsa，那么在启动pt的时候，必须加上-mul选项启动多线程，不然是无法进行dmsa优化的。</p><p>在icc中，摆放eco 的cell</p><pre class=" language-tcl"><code class="language-tcl"><span class="token keyword">source</span> iccpt.tcllegalize_placement <span class="token operator">-</span>eco <span class="token operator">-</span>incremental route_zrt_eco <span class="token operator">-</span>utilize_dangling_wires true <span class="token operator">-</span>reuse_existing_global_route true <span class="token operator">-</span>open_net_driven true save_mv_cel <span class="token operator">-</span>as eco_routed </code></pre><p>在ICC中打开mw_lib中的cell</p><pre class=" language-tcl"><code class="language-tcl"><span class="token keyword">source</span> xxx.setupopen_mw_lib ..<span class="token operator">/</span>..<span class="token operator">/</span>XXX.libopen_mw_cell FMCW_DCORE_TOP</code></pre><ul><li><p><strong>max_transition设置</strong></p><p>signoff的标准是0.6，在pr阶段一般会过约束，可以将data_path设置为0.5，clock上设置为0.45，而clock path的max transition在cts之前再约束sdc里面就不再单独设置。</p></li></ul><p>ICC中修复hold time</p><ol><li><p>cts之前</p><p>psynopt -only_hold_time</p></li><li><p>routing阶段<br>指定布线优化选项来修复<br>route_opt -incr -only_hold_time</p></li><li><p>chipfinish</p><p>3.1 可以用CCD来修复：</p><p>&gt;focal_opt -concurrent_clock_and_data -hold_endpoints all</p><p>3.2可以让软件自动对所有hold endpoints来修复：</p><p>&gt;focal_opt -hold_endpoints all -effort high</p><p>其实可以指定某些hold endpoints来单独对它们进行优化，但是自己尝试发现没有什么用，没有PT效果那么好。</p><p>3.3 指定REG2REG路径进行修复</p><p>如果违规都集中在REG2REG的路径上，那么用下面的命令更好：</p><p>&gt;focal_opt -hold_endpoints all -register_to_register</p></li></ol><p>​3.4 手工ECO修复</p><p>​如果上述方法都不行的话，就需要手动插入buffer或者delay cell来解决了，即采用ECO的方法来手工解决。在插入之前要确保没有插入Core filler，或者有Filler的话要remove，需要注意的是不用全部remove，在放置eco cell的命令的后边会有移除部分filler的选项哟，这个非常棒。</p><p>3.5 用PT进行ECO修复</p><p>​当然这些也是可以不用手工ECO的方法，而将整个设计的网表、spef导入PT，让PT自己修复，然后导出ECO的脚本，然后将脚本导入ICC进行修复，不过感觉这个过程挺麻烦的，还不如手工来的方便，具体方法可以参见ICCECO流程那一部分。</p><h5 id="记录修复timing-removal的错误"><a href="#记录修复timing-removal的错误" class="headerlink" title="记录修复timing-removal的错误"></a>记录修复timing-removal的错误</h5><p>2024&#x2F;1&#x2F;23<br>尝试使用pt的dmsa模式修复hold time时，发现有removal的违例，很是震惊。从来没遇到过</p><img src="/2024/011821871/image-20240123205008592.png" alt style="zoom: 67%;"><p>之前clock_uncertainty的值不太对，只是修改了这个地方。就出现了recovery的违例。以为是这里的问题，修改后，发现还是有removal的违例，然后一阵搜资料。最后查看了pt 违例的timing path，发现是pt的sdc里面的input&#x2F;output delay设置的太小。导致有大量的removal违例。（类比于hold）。相当于数据保持的时间太多，不满足removal检查。</p><p>将input output delay设置好后（之前是0.35，修改为3.5。在ICC中也是3.5），removal没有违例。</p><img src="/2024/011821871/image-20240123211117779.png" alt style="zoom:67%;"><img src="/2024/011821871/eb5a2b0dce25b2ed55c869128fdd6f0.jpg" alt style="zoom: 33%;"><ul><li><p>recovery</p><p>如果report_timing的path，-end指向的是DFF的D端，则是分析setup，如果是DFF的rst端，则是recovery。</p></li><li><p>电路后仿真</p></li></ul><p>​在后仿真时，需要吃sdf文件。sdf文件既可以是ICC产生的，也可以是PT生成的。在进行带有延迟反标的仿真时，需要注意两个延迟文件之间的区别。<br>​在仿真激励tb中，使用系统函数$annotated来完成延迟反标。<br>​延迟反标的参数，有三种类型：最大、最小和典型。在ICC和PT导出的sdf文件中，每一个gate同样有三个参数。<strong>注意的是，如果不设置延迟反标的类型，会中间的默认典型值，ICC导出的sdf里面典型值不为0，PT导出sdf文件典型值为0，因此如果在使用annotated时，不指定最大最小延迟，默认典型延迟，在波形图中就不会有组合逻辑造成的多次信号跳变，导致延迟参数反标不上去</strong></p><p>icc的sdf文件</p><p><img src="/2024/011821871/image-20240127193058698.png"></p><p>pt吐出的sdf文件</p><p><img src="/2024/011821871/image-20240127193134312.png"></p><p>​措施：在使用annotated函数时，指定max&#x2F;min延迟类型，其中max用于setup检查，min用于hold检查。</p><pre class=" language-tcl"><code class="language-tcl">$<span class="token variable">sdf_annotate</span> <span class="token punctuation">(</span>“sdf_file”<span class="token punctuation">[</span>, “module_instance”<span class="token punctuation">]</span> <span class="token punctuation">[</span>,<span class="token operator">/</span><span class="token operator">/</span> 实例化“sdf_configfile”<span class="token punctuation">]</span><span class="token punctuation">[</span>,  <span class="token operator">/</span><span class="token operator">/</span> 一般缺省“sdf_logfile”<span class="token punctuation">]</span><span class="token punctuation">[</span>, <span class="token operator">/</span><span class="token operator">/</span> 指定vcs保存errors和warnings的log文件,<span class="token punctuation">(</span>modelsim没有这个选项<span class="token punctuation">)</span>“mtm_spec”<span class="token punctuation">]</span> <span class="token punctuation">[</span>,<span class="token operator">/</span><span class="token operator">/</span> 指定延迟类型，MINIMUM<span class="token punctuation">(</span>min<span class="token punctuation">)</span>, TYPICAL<span class="token punctuation">(</span>typ<span class="token punctuation">)</span>,MAXIMUM<span class="token punctuation">(</span>max<span class="token punctuation">)</span>“scale_factors”<span class="token punctuation">]</span><span class="token punctuation">[</span>,  <span class="token operator">/</span><span class="token operator">/</span> 缩放因子，默认1:1:1“scale_type” <span class="token operator">/</span><span class="token operator">/</span> 指定缩放之前延迟值得来源,“FROM_TYPICAL”,“FROM_MIMINUM”,                     <span class="token operator">/</span><span class="token operator">/</span> “FROM_MAXIMUM<span class="token string">"和"</span>FROM_MTM” <span class="token punctuation">(</span>default<span class="token punctuation">)</span>.<span class="token operator">/</span><span class="token operator">/</span> FROM_MINIMUX 选择SDF文件中mininum timing，组合逻辑的延时最小，侧重于hold time 的检查<span class="token operator">/</span><span class="token operator">/</span> FROM_TYPICAL 选择SDF文件中typical timing<span class="token operator">/</span><span class="token operator">/</span> FROM_MAXIMUM 选择SDF文件中maximum timing，组合逻辑的延时最大，侧重于setup time的检查<span class="token punctuation">]</span><span class="token punctuation">)</span>;</code></pre><ul><li>在后仿过程中，需要care的点<ol><li>input 端口都要给定值，不能floating不给初值，否则内部出现x态。</li><li>激励中的时钟频率，不能超过STA时的。</li><li>有些信号是反逻辑，可能和前仿的信号不一致</li><li>如果出现了setup的违例导致功能错误，可以对比STA中path的delay与波形的delay是否一致</li></ol></li></ul><p>由于集成电路制造工艺的差异，实际电路中器件的延迟总会在一定范围内波动。Verilog 中，用户不仅可以指定 3 种类型的门延迟，还可以对每种类型的门延迟指定其最小值、典型值和最大值。</p><ul><li><p>后仿的各种组合情况</p><p>PVT_corner + fast&#x2F;typical&#x2F;slow SDF</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ASIC数字后端流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步复位和同步复位</title>
      <link href="/2023/122543491.html"/>
      <url>/2023/122543491.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>常用的复位方式</p><ol><li>带同步复位的寄存器后紧跟一个不带复位的寄存器</li></ol><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>q1 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">begin</span>        q1 <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span>        q2 <span class="token operator">&lt;=</span> q1<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">// 错误的复位方式    q2没有被正确的复位，并且综合生成的电路也非常奇怪。</span></code></pre><img src="/2023/122543491/image-20231225203911890.png" alt style="zoom: 33%;"></li></ul><p>​因为在rst_n有效时，q2没有动作，所以rst_n作为第二级寄存器的ld_en信号，将q1的结果输出在q2上。</p><p><strong>正确的code style</strong></p><pre><code>always @(posedge clk) begin    if(!nrst)q1 &lt;= 0;    else q1 &lt;= d;endalways @(posedge clk)    q2 &lt;= q1;</code></pre><img src="/2023/122543491/image-20231225204528665.png" alt style="zoom: 33%;"><p><strong>同步复位</strong>：复位信号，只在clk的有效边沿才会发挥作用，参与输入信号d的组合逻辑，相当于做“与”逻辑。这种情况下，if-else的优先级就很重要。reset需要在if中发挥作用。</p><p>使用同步复位出现的问题：综合工具DC无法分辨复位信号和其他数据信号。<br>带同步复位的可加载触发器如下</p><img src="/2023/122543491/image-20240220164819082.png" alt style="zoom:50%;"><p>​综合工具也可能会综合成下面的结构，两者实现的功能相同。</p><img src="/2023/122543491/image-20240220164859844.png" alt style="zoom:50%;"><p>​第二种方式在门级仿真时，如果rst_n信号为低，mux的输入都是0，如果load是x态，导致触发器会输出x态，而不会复位。<strong>本质区别是 rst_n的优先级，第一种方式rst_n的优先级要高于第二种，第一种可以保证在仿真时复位的有效性</strong>，这两种方式在实际硬件中，都是可以正常复位的。因此，在仿真过程中，使用编译指令，告知综合工具，让复位信号rst_n尽可能靠近触发器，提高复位信号的优先级。</p><p><strong>优点：</strong></p><pre><code>1. 可以使用基于周期仿真的模拟器，比如verilator。2. 确保了所有的电路都是同步的。3. 由于是时钟有效时，才可以复位，所以可以过滤一些reset的毛刺。</code></pre><p><strong>缺点：</strong></p><ol><li>同步复位可能需要脉冲展宽器来保证复位脉冲足够宽</li><li>对于时钟门控的寄存器，同步复位无效。</li></ol><ul><li><strong>三态总线的复位</strong></li></ul><p>为了防止芯片上电时，内部三态总线上的总线竞争，就迫切需要时钟产生复位；</p><p>因此，芯片需要具有异步复位的功能。</p><img src="/2023/122543491/image-20231225235555437.png" alt style="zoom: 33%;"><p>也可以使用同步复位的方式实现，但是也必须使用复位信号直接撤销三态门的使能，寄存器的输出必须与rst_n做与；</p><img src="/2023/122543491/image-20231225235658088.png" alt style="zoom: 33%;"><h4 id="异步复位"><a href="#异步复位" class="headerlink" title="异步复位"></a>异步复位</h4><p>​异步复位可以保证 数据路径上没有复位信号的参与，在复位时，数据路径是干净的。</p><p>​异步复位最大的问题是 复位信号的释放。</p><p>​在DC阶段，对于clock和reset信号，通过设置输入驱动为0，表示驱动能力最强，<code>set_drive 0</code>。并设置<code>set_dont_touch_network</code>保护clk和reset信号不被修改。这样做的目的是 因为综合时，没有布局布线信息，在dc时即使插入buffer对clk和reset信号优化，也是没有意义的，到ICC阶段也会重新插buffer。反而，可能会对物理实现带来负面影响。所以最好的办法是不处理，在CTS时才真正的解决clk和reset。</p><p><strong>优点：</strong></p><pre><code> 1. 保证复位信号不会参与到数据路径中，保证数据路径是干净的。 2. 不需要时钟，就可以进行电路的复位。</code></pre><p><strong>缺点：</strong></p><ol><li>不能使用基于周期的仿真器</li><li>异步复位时，不会有亚稳态的影响，但是在释放时，很有可能clk是上升沿会采到rstn在变化，造成亚稳态。导致复位后的稳定状态丢失。</li><li>会受到毛刺的影响</li><li>异步复位 带来时序分析的困难</li></ol><ul><li><p>异步复位和异步置位寄存器</p><p>尽可能避免出现该类型的寄存器，否则，可能会造成综合前后结果不一致的问题。</p></li></ul><p>异步复位需要考虑recovery time和removal time的违例。</p><p>recovery time类似于setup time，在有效时钟沿上升之前，rst发生变化的最短时间。</p><p>removal time类似hold time，在有效时钟沿上升之后，rst发生变化所需要的最短时间。</p><ul><li><p>key points</p><p><strong>每个使用异步复位的ASIC电路，都应该包括复位同步器电路</strong>，也就是异步复位，同步释放。</p><p>异步复位同步器综合了两者的优点，</p></li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        nrst1 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        nrst2 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        nrst1 <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        nrst2 <span class="token operator">&lt;=</span> nrst1<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span>第二级的nrst2是为了消除，第一级异步复位信号释放带来的任何亚稳态。</code></pre><img src="/2023/122543491/image-20231226100118399.png" alt style="zoom:50%;"><ul><li><p><strong>异步复位毛刺过滤器</strong></p><p>通过延迟电路，将延迟前后的信号做”与”，即可得到真正的复位信号。</p><img src="/2023/122543491/image-20240220172053034.png" alt style="zoom: 50%;"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile</title>
      <link href="/2023/11277120.html"/>
      <url>/2023/11277120.html</url>
      
        <content type="html"><![CDATA[<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="Makefile的运行"><a href="#Makefile的运行" class="headerlink" title="Makefile的运行"></a>Makefile的运行</h3><p>make -f 文件名，执行特定的Makefile文件<br>Make 的默认行为是执行Makefile的第一个target，该目标一般会带起多个目标的执行。目标中有&#x3D;，或者-打头的不能指定为终极目标，因为这些字符的目标会被解析成命令行参数或者变量。</p><pre class=" language-makefile"><code class="language-makefile"><span class="token builtin">.PHONY</span><span class="token punctuation">:</span> all <span class="token symbol">all</span><span class="token punctuation">:</span> prog1 prog2 prog3 prog4<span class="token comment" spellcheck="true"># 通过make all执行所有的target</span></code></pre><ul><li>检查规则(常用)</li></ul><pre class=" language-bash"><code class="language-bash">-n 打印命令，不执行-s ：全面禁止命令的显示-q 寻找目标，找到什么都不输出，找不到打印错误error-B 认为所有目标都需要重编译-C <span class="token operator">&lt;</span>dir<span class="token operator">></span> 指定读取Makefile的目录，如果有多个“-C”参数，make 的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。比如“make -C ~hchen/test -C prog”等价于“make -C ~hchen/test/prog”。-I <span class="token operator">&lt;</span>dir<span class="token operator">></span> 指定一个被包含Makefile的搜索目标。可以使用多个“-I”参数来指定多个目录-t 更新target的时间，组织生成目标的命令运行</code></pre><ul><li>命令执行顺序</li></ul><p>命令顺序执行，如果想要当前的命令在下一行使用，需要将下行命令放在当前行，并加上“；”<br>默认使用&#x2F;bin&#x2F;sh标准执行命令</p><ul><li>命令执行出错</li></ul><p>有可能会终止整个make的执行；但是有时候命令出错是允许的，所以要在命令前加上“-”，表示忽略命令的出错。<br>或者通过命令行参数的方式，<br>-i make会忽略所有出错的命令<br>-k 表示命令出错时，终止该命令执行，但是继续执行其他规则</p><ul><li>嵌套执行make</li></ul><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">subsystem</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C subdir//进入子目录，执行make选项var <span class="token operator">=</span> 123<span class="token keyword">export</span> var <span class="token comment" spellcheck="true"># 声明该变量传递给子make文件</span>make -w 进入或者退出目录时会有提示</code></pre><h3 id="Makefile中的变量"><a href="#Makefile中的变量" class="headerlink" title="Makefile中的变量"></a>Makefile中的变量</h3><pre class=" language-makefile"><code class="language-makefile">Var <span class="token operator">=</span> value类似C的<span class="token keyword">define</span>，强烈建议变量的引用使用括号，比如 <span class="token variable">$</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span>等号右侧的变量可以是Makefile文件后面的内容，就有可能导致递归，所以要使用 <span class="token operator">:=</span>，表示只能使用前面的变量。Var <span class="token operator">:=</span> value</code></pre><pre class=" language-makefile"><code class="language-makefile"><span class="token comment" spellcheck="true">#定义一个变量，值是一个空格</span>Nullstring <span class="token operator">:=</span>space <span class="token operator">:=</span> <span class="token variable">$Nullstring</span> <span class="token comment" spellcheck="true">#end of the line</span>dir <span class="token operator">:=</span> /foo/bar    <span class="token comment" spellcheck="true">#end</span>加了<span class="token comment" spellcheck="true">#后，表示这个dir变量最后会有4个空格导致错误。</span>Foo <span class="token operator">?=</span> valueFoo如果没有定义过，就在此处定义</code></pre><ul><li>高级用法</li></ul><pre class=" language-makefile"><code class="language-makefile">1. 变量值的替换  Foo <span class="token operator">:=</span> a.o b.o c.o  Bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>Foo<span class="token punctuation">:</span>.o<span class="token operator">=</span>.c<span class="token punctuation">)</span>2. 变量的值当成变量  Foo <span class="token operator">:=</span> \<span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>3. 追加变量值 <span class="token operator">+=</span>  Object <span class="token operator">:=</span> main.o foo.o  Object <span class="token operator">+=</span> another.o如果前一次的是 <span class="token operator">:=</span> ，那么 <span class="token operator">+=</span> 会以 <span class="token operator">:=</span> 作为其赋值符4. 多行变量使用<span class="token keyword">define</span>   <span class="token keyword">endef</span></code></pre><ul><li>环境变量</li></ul><pre class=" language-makefile"><code class="language-makefile">如果在命令行参数中代入该变量，环境变量的值会被覆盖。如果make时指定了-e，环境变量会覆盖Makefile中定义的变量。Makefile中定义的变量都是全局变量，<span class="token variable">$@</span> <span class="token variable">$^…</span> 都属于规则型变量也可以为某个目标target设置局部变量，该变量会作用到有这个目标所引发的所有规则区域。</code></pre><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">prog </span><span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -g<span class="token symbol">prog </span><span class="token punctuation">:</span> prog.o foo.o bar.o<span class="token variable">$</span><span class="token punctuation">(</span>GCC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.o foo.o bar.o<span class="token variable">$</span><span class="token punctuation">(</span>addprefix src/,foo bar<span class="token punctuation">)</span> 为每个文件名添加前缀src/</code></pre><h3 id="Makefile中的函数"><a href="#Makefile中的函数" class="headerlink" title="Makefile中的函数"></a>Makefile中的函数</h3><h4 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>patsubst <span class="token operator">&lt;</span>pattern<span class="token operator">></span>,<span class="token operator">&lt;</span>replacement<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>查找&lt;text&gt; 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 &lt;pattern&gt;<br>返回被替换后的字符串</p><p>pattern：可以包含通配符%，表示任意长度的字符串。也可以是subst的&lt;from&gt;</p><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>objects:.o<span class="token operator">=</span>.c<span class="token variable">)</span></span> 和 <span class="token variable"><span class="token variable">$(</span>patsubst %.o,%.c,<span class="token punctuation">$(</span>objects<span class="token variable">)</span></span><span class="token punctuation">)</span> 是一样的</code></pre><h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>strip <span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token variable">)</span></span> </code></pre><p>去掉string开头和结尾的空字符</p><h4 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>findstring <span class="token operator">&lt;</span>find<span class="token operator">></span>,<span class="token operator">&lt;</span>in<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>如果找到，那么返回 &lt;find&gt; ，否则返回空字符串<br>在字串 &lt;in&gt; 中查找&lt;find&gt; 字串</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>filter <span class="token operator">&lt;</span>pattern<span class="token punctuation">..</span>.<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，保留符合模式 &lt;pattern&gt; 的单词。可以 有多个模式。 返回符合模式 &lt;pattern&gt; 的字串。<br>filter-out 功能与filter相反</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">sort</span> <span class="token operator">&lt;</span>list<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>给字符串 &lt;list&gt; 中的单词排序（升序）。<br>返回排序后的字符串，sort 函数会去掉 &lt;list&gt; 中相同的单词。</p><h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>word <span class="token operator">&lt;</span>n<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>取字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。（从一开始）<br>返回字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。如果 &lt;n&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串。</p><h4 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h4><p>$(wordlist <ss>,<e>,<text>)<br>从字符串 &lt;text&gt; 中取从 &lt;ss&gt; 开始到 &lt;e&gt; 的单词串。&lt;ss&gt; 和 &lt;e&gt; 是一个数字</text></e></ss></p><h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><p>$(words <text>)<br>统计 &lt;text&gt; 中字符串中的单词个数。 如果我们要取 &lt;text&gt; 中最后的一个单词，我们可以这样：</text></p><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>word <span class="token punctuation">$(</span>words <span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token punctuation">)</span> 。</code></pre><h4 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>firstword <span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>取字符串 &lt;text&gt; 中的第一个单词。 </p><h4 id="dir-文件名操作函数"><a href="#dir-文件名操作函数" class="headerlink" title="dir 文件名操作函数"></a>dir 文件名操作函数</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">dir</span> <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出目录部分。目录部分是指最后一个反斜杠（&#x2F; ）之前的部分。 如果没有反斜杠，那么返回 .&#x2F;</p><h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>notdir <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出非目录部分。非目录部分是指最后一个反斜杠（&#x2F; ）之后的部分。</p><h4 id="Suffix"><a href="#Suffix" class="headerlink" title="Suffix"></a>Suffix</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>suffix <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span> </code></pre><p>从文件名序列 &lt;names&gt; 中取出各个文件名的后缀</p><h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> <span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>从文件名序列 &lt;names&gt; 中取出各个文件名的前缀部分。</p><h4 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>addsuffix <span class="token operator">&lt;</span>suffix<span class="token operator">></span>,<span class="token operator">&lt;</span>names<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>加后缀，把后缀 &lt;suffix&gt; 加到 <names> 中的每个单词后面。</names></p><h4 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h4><p>$(addprefix <prefix>,&lt;names…&gt;)<br>把前缀 &lt;prefix&gt; 加到 &lt;names&gt; 中的每个单词前面。 </prefix></p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">join</span> <span class="token operator">&lt;</span>list1<span class="token operator">></span>,<span class="token operator">&lt;</span>list2<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>连接list1 和list2</p><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token function">join</span> aaa bbb , 111 222 333<span class="token variable">)</span></span> </code></pre><p>返回值是 aaa111 bbb222 333</p><h4 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach 函数"></a>foreach 函数</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>foreach <span class="token operator">&lt;</span>var<span class="token operator">></span>,<span class="token operator">&lt;</span>list<span class="token operator">></span>,<span class="token operator">&lt;</span>text<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中，然后再执行 &lt;text&gt; 所包含的表达式。每一次 &lt;text&gt; 会返回一个字符串，循环过程中，&lt;text&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值.   var是一个临时变量，作用域只在 foreach 函数</p><p>&lt;var&gt; 最好是一个变量名,&lt;list&gt; 可以是一个表达式，而 &lt;text&gt; 中一般会使用 &lt;var&gt; 这个 参数来依次枚举 &lt;list&gt; 中的单词</p><h4 id="if-函数"><a href="#if-函数" class="headerlink" title="if 函数"></a>if 函数</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span><span class="token keyword">if</span> <span class="token operator">&lt;</span>condition<span class="token operator">></span>,<span class="token operator">&lt;</span>then-part<span class="token operator">></span><span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span><span class="token keyword">if</span> <span class="token operator">&lt;</span>condition<span class="token operator">></span>,<span class="token operator">&lt;</span>then-part<span class="token operator">></span>,<span class="token operator">&lt;</span>else-part<span class="token operator">></span><span class="token variable">)</span></span></code></pre><p>即 if 函数的参数可以是两个，也可以是三个。&lt;condition&gt; 参数是 if 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，&lt;then-part&gt; 会被计算，否则 &lt;else-part&gt; 会被计算。</p><h4 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h4><p>操作系统 Shell 的命令<br>shell 函数把执行操作系统命令后的输出作为函数返回</p><h4 id="控制-make-的函数"><a href="#控制-make-的函数" class="headerlink" title="控制 make 的函数"></a>控制 make 的函数</h4><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>error <span class="token operator">&lt;</span>text <span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>warning <span class="token operator">&lt;</span>text <span class="token punctuation">..</span>.<span class="token operator">></span><span class="token variable">)</span></span> </code></pre><p>很像 error 函数，只是它并不会让 make 退出，只是输出一段警告信息，而 make 继续执行。</p><h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a><strong>wildcard</strong></h4><pre class=" language-makefile"><code class="language-makefile"><span class="token comment" spellcheck="true">#显示扩展名</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.v<span class="token punctuation">)</span>  </code></pre><h4 id="readlink"><a href="#readlink" class="headerlink" title="readlink"></a>readlink</h4><pre class=" language-makefile"><code class="language-makefile">打印解析符号链接或符号链接的规范文件名-f 通过递归给出指定名称的符号链接当前脚本的绝对路径：    readlink -m <span class="token variable">$0</span></code></pre><h4 id="用法"><a href="#用法" class="headerlink" title="$$ 用法"></a>$$ 用法</h4><pre class=" language-makefile"><code class="language-makefile">SRC <span class="token operator">:=</span> A.c B.c<span class="token symbol">process</span><span class="token punctuation">:</span>    for i in <span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span class="token punctuation">;</span> do \        readlink -f <span class="token variable">$$i</span> >> <span class="token variable">$file</span> \    done使用两个<span class="token variable">$$，是因为i在shell的for循环中展开，属于shell的变量，相当于两层变量的嵌套。make读到$$i时候，会进行转义，展开成$i，然后交给shell解释程序。施加了$$的变量，需要两次展开，才能得到变量的值。</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim/vscode配置和操作</title>
      <link href="/2023/112521332.html"/>
      <url>/2023/112521332.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><ul><li><p>实现一列序号递增</p><p>ctrl-v 选中列，然后 g + ctrl-a</p></li></ul><pre class=" language-vim"><code class="language-vim">my_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   my_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> my_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>my_array<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim Vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpyGalss</title>
      <link href="/2023/112431792.html"/>
      <url>/2023/112431792.html</url>
      
        <content type="html"><![CDATA[<h3 id="SPYGLASS"><a href="#SPYGLASS" class="headerlink" title="SPYGLASS"></a>SPYGLASS</h3><p>主要用于检查设计中的跨时钟域CDC问题，包含五大模块：lint，CDC（跨时钟域检查），LP（低功耗），Constraint（约束），DFT（可测性）。类似pt，属于静态验证工具，不需要编写testbench。</p><p>Rule：spyglass进行RTL分析的最小单位.<br>Goal：是一系列相关rule的集合，组合起来完成RTL的某个特定任务，user可以用guidewave定义好的goal，也可以自定义，可以指定规则的顺序。<br>Sub-Methodology：一系列Goal的集合，用以达成某方面特定目标。</p><p>SGDC：Constraints文件，包含clock和reset等约束信息</p><pre class=" language-sdc"><code class="language-sdc">current_design "key_top"clock -name clk -period 10 -edge 0 5reset -name rstn -value 0</code></pre><p>Waiver：用以过滤一些结果的文件</p><p>CDC：检查异步信号有没有同步处理就使用，组合逻辑是否有毛刺。</p><p>parameter：可以在进行RTL分析之前设定某些参数，对检查过程进行一些约束。</p><ul><li>Lint 中各个goal主要检查什么？</li></ul><p><img src="/2023/112431792/image-20231128002240109.png"></p><ul><li>Lint 检查时设置方法学，检查目标集合</li></ul><p><img src="/2023/112431792/image-20231128002527247.png"></p><p>具体操作：</p><ul><li><p>按 ‘e’ 修改代码。</p></li><li><p>对于有问题的地方，比如锁存器，可以查看原理图。</p></li></ul><p>spyglass会生成较多报告，其中常用的是<strong>moresimple.rpt</strong>，显示源文件中的错误。</p><p>使用<strong>ifdef</strong>构造来启用固定代码，添加以下内容来启用宏，从而启用<strong>Fix_W415</strong>宏：</p><blockquote><p><strong>set_option define { Fix_W415 }</strong></p><p>可以替换掉文件开头定义的&#96;define</p></blockquote><ul><li><p>读入的文件</p><ol><li>设计文件：.v或者.sv</li><li>约束文件：.sgdc</li><li>HDL libraries：之前编译过的verilog库</li></ol></li></ul><pre class=" language-tcl"><code class="language-tcl"><span class="token comment" spellcheck="true"># tcl 命令</span>read_file <span class="token operator">-</span>type verilog  xx.vread_file <span class="token operator">-</span>type sourcelist filelist.fread_file <span class="token operator">-</span>type sgdc xxx.sgdc<span class="token comment" spellcheck="true"># common settings</span>set_option top xxxset_option enableSV yes<span class="token comment" spellcheck="true"># SDC文件可以直接被spyglass读取，自动转换成SGDC，需要进行以下设置</span>set_option sdc2sgdc yescurrent_design xxxsdc_data <span class="token operator">-</span>file ssss_src.sdc<span class="token comment" spellcheck="true">#设置异步复位的值</span>reset <span class="token operator">-</span>name <span class="token string">"xxx.xx.Z"</span> <span class="token operator">-</span>async <span class="token operator">-</span>value 0</code></pre><ul><li>约束文件 .sgdc</li></ul><p>​包括clock，reset，set_case_analysis( -name -value)</p><ul><li>文件不同颜色标识<ul><li>绿色代表该模块可分析，但是不可综合</li><li>黑色表示作为黑盒子存在</li><li>白色代表可分析，可综合</li></ul></li></ul><p>手动添加waiver放弃对一些电路的检查。</p><h6 id="生成报告"><a href="#生成报告" class="headerlink" title="生成报告"></a>生成报告</h6><pre><code>write_aggregate_report datasheet write_aggregate_report dashboard</code></pre><p><a href="https://blog.csdn.net/qq_21842097/article/details/122538986?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-122538986-blog-122534341.235%5Ev38%5Epc_relevant_sort_base3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-122538986-blog-122534341.235%5Ev38%5Epc_relevant_sort_base3&utm_relevant_index=1">https://blog.csdn.net/qq_21842097/article/details/122538986?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122538986-blog-122534341.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122538986-blog-122534341.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=1</a></p><ul><li><p>时钟和复位</p><p><strong>cdc_setup中的rules</strong>：<strong>clock_info1, reset_info1, setup_clock01</strong></p><ul><li><p>clock_info1</p><p>Primary Clocks: 普通输入时钟<br>Black box clocks：黑盒或工艺库单元输出的时钟<br>Derived：寄存器或工艺库单元输出的时钟<br>Undrived Clocks：悬空的线或者门控锁存器输出的时钟<br>Gated clocks：组合逻辑输出的时钟</p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>  clk1<span class="token punctuation">,</span>    <span class="token keyword">input</span>  rstn<span class="token punctuation">,</span>    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> d<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">wire</span> clk3<span class="token punctuation">,</span> clk4<span class="token punctuation">;</span><span class="token keyword">reg</span> clk2<span class="token punctuation">;</span><span class="token function">BB</span><span class="token punctuation">(</span>clk1<span class="token punctuation">,</span> clk3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk1 <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rstn<span class="token punctuation">)</span> clk2 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> clk2 <span class="token operator">&lt;=</span> <span class="token operator">~</span>clk2<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk4 <span class="token keyword">or</span> <span class="token keyword">negedge</span> rstn<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">end</span><span class="token keyword">endmodule</span></code></pre><p>clk1是primary clock，clk2是Derived clock，clk3是Black box clocks，clk4是Undrived Clocks</p></li><li><p>Reset_info1</p><table><thead><tr><th>普通复位</th><th>Primary Presets&#x2F;Clears</th></tr></thead><tbody><tr><td>黑盒（blackbox）或工艺库单元产生的复位</td><td>Black box Presets&#x2F;Clears</td></tr><tr><td>寄存器产生的复位</td><td>Derived Presets&#x2F;Clears</td></tr><tr><td>悬空的线产生的复位</td><td>Undrived Presets&#x2F;Clears</td></tr><tr><td>锁存器，三态器件产生的复位</td><td>Gated Presets&#x2F;Clears</td></tr></tbody></table></li><li><p>Setup_clock01</p><p>报告时钟源，时钟使能信号和clock cone<br>设计中多个输入时钟通过选择器后只输出一个时钟，输出的时钟称为clock cone。</p><img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70.png" alt style="zoom:50%;"></li></ul></li><li><p>CDC_setup_check</p><p><strong>clock_info03a，clock_info05a&#x2F;b， clock_info18</strong></p><ul><li><p>clock_info03a  报告设计中未被约束的时钟引脚。</p><ol><li>时钟经过组合逻辑被disabled，门控时钟 <img src="/2023/112431792/290753-20220707153610355-1659264831.png" alt style="zoom:67%;"></li><li>约束文件中没有约束时钟引脚，且use_inferred_clocks参数被设置为No<img src="/2023/112431792/290753-20220707153634456-628658853.png" alt style="zoom: 67%;"></li><li>时钟路径上有Blackbox，且Blackbox输出的时钟没有约束<img src="/2023/112431792/290753-20220707153647566-2088386241.png" alt style="zoom:67%;"></li><li>时钟在设计中没有传输，断头时钟。<img src="/2023/112431792/290753-20220707153659862-637731003.png" alt styl="zoom:67%;"></li></ol></li><li><p>clock_info05a&#x2F;b</p><p>在设计如果有clock的mux选择输出，需要指定set_case_analysis命令来约束。</p><pre><code></code></pre></li></ul><p>input ports: clk1, clk2<br>  output port: clkout<br>  enable port: in1<br>  assign clkout &#x3D; in1 ? clk1 : clk2;<br>  在sgdc文件中：<br>  current_design test<br>  clock -name clk1<br>  clock -name clk2<br>  这样报违例。需要进行下面的配置<br>  set_case_analysis -name in1 -value 0</p><pre><code>- clock_info18报告设计中未约束的引脚sgdc中一定要约束所有的输入、输出引脚，时钟引脚以及BLACKBOX的引脚。包括：input，output，clock，reset，set_case_analysis，abstract_port</code></pre></li><li><p>CDC_verify_struct</p><p>​主要检查设计中是否有 未同步的信号，是否有毛刺。</p><ul><li><p><strong>AC_unsync01&#x2F;02</strong></p><p>如果源寄存器是控制信号，检查信号是否通过一个有效同步器。<br>如果源寄存器是数据信号，检查是否使用异步fifo或握手信号。</p></li><li><p><strong>AC_SYNC01&#x2F;02</strong></p><p>报告设计中已经同步的信号，这项规则只会报告信息，不会报告违例。</p></li><li><p><strong>AC_conv01&#x2F;02&#x2F;03</strong></p><p>报告设计中的聚合问题，可能引起数据不一致性，即同步前后数据不一致。</p><p>AC_conv01报告信号经过同步器+寄存器后的聚合违例。</p></li></ul></li></ul><img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706510260564-11.png" alt style="zoom:67%;"><p>​多bit信号，在同步后经过不同数量的寄存器，最终在一个逻辑门聚合。在源寄存器端发送的是00-&gt;11，在目的寄存器聚合的输入端的结果是00-&gt;10-&gt;11，导致和源寄存器端发送的结果不一致（数据一致性问题）。但是如果是单bit的数据变化，就不会有这种问题。<br>​<img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706524314470-14.png" alt style="zoom: 67%;"></p><p>​上图所描述的问题也是一样的。</p><p>​<img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706524438604-17.png" alt style="zoom:67%;"><br>​这种情况下没有违例，两个信号由同一个控制信号控制。如果报出违例，检查设置确实没有问题，可以设置cdc_false_path命令约束。</p><p>​AC_conv02规则报告信号经过同步器后违例，且聚合后又通过了寄存器。</p><p>​<img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706525364578-20.png" alt style="zoom:67%;"><br>​这种方式和上面的conv01不同，上面的聚合发生在寄存器后，而这种方式聚合发生在同步后，同样会出现数据一致性问题。（多bit数据同步，不能采用单bit打两拍的方式）。<strong>解决办法：如果是计数器，可以将多bit数据转成格雷码，在发送端打一拍，然后再传递出去。</strong></p><p>​报告同一个信号经过多条同步路径后，又聚合的问题。类似于多比特数据的同步问题。</p><img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706525889668-23.png" alt style="zoom:67%;"><p>​AC_conv03规则检查不同时钟域信号，经过同一个时钟域同步后的聚合问题。</p><p><img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706526000058-26.png"></p><p>​AC_glitch03 报告设计中的毛刺。</p><ul><li><strong>Clock_sync05&#x2F;06</strong></li></ul><p>​Clock_sync05报告输入信号被多个不同的时钟域寄存器采样。</p><p>​<img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706527099731-29.png" alt style="zoom: 80%;"></p><p>​Clock_syn06报告输出信号由多个时钟域信号组合而成。<br><img src="/2023/112431792/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nX2V0aGFu,size_16,color_FFFFFF,t_70-1706527140384-32.png"></p><p>​<strong>如果确保设计没有问题，可以使用set_case_analysis命令加强对输入信号的约束</strong></p><p><strong>AC_cdc01a AC_cdcdatahold1a AC_conv02&#x2F;04&#x2F;05 AC_fifo01 AC_handshake01&#x2F;02</strong></p><p>检查CDC_verify(functional cdc checks)：数据完整性、格雷码编码、FIFO上溢或下溢和握手协议。</p><p>AC_cdc01a<br>    检查快时钟到慢时钟同步数据传输是否丢失。</p><img src="/2023/112431792/290753-20220707155308615-135013952.png" alt style="zoom:80%;"><p>​如果快时钟域的信号只维持一个周期，慢时钟域很容易采不到。快时钟域的信号变化至少维持慢时钟域的1.5个周期不变。</p><p><img src="/2023/112431792/290753-20220707155318653-96027376.png"></p><p>AC_datahold01a 检查多bit数据被另一个时钟域采样时是否稳定，与上面的cdc_01a检查单bit类似.FIFO、握手、门控同步模块都不会被检查。</p><p>AC_conv02&#x2F;04&#x2F;05 检查跨时钟传输过程中没有聚合，也没有格雷码编码的多比特控制信号。<br>检查是否使用格雷码编码</p><p><img src="/2023/112431792/290753-20220707155437109-1964738978.png"></p><p>检查不同bit信号是否使用不同的同步方式，src_bus[0]采用多级同步器方式同步，src_bus[1]采用同步控制信号方式</p><p><img src="/2023/112431792/290753-20220707155449430-751485405.png"></p><p>检查不同bit信号是否使用同一个同步控制信号，src_bus[0]与src_bus[1]采用不同的同步控制信号</p><p><img src="/2023/112431792/290753-20220707155459981-1844018659.png"></p><p>AC_fifo01：检查fifo是否上溢或者下溢</p><p>AC_handshake01&#x2F;02: </p><p>01检查req-&gt;ack信号是否满足四相握手协议。REQ拉高-&gt;ACK拉高-&gt;REQ拉低-&gt;ACK拉低</p><p><img src="/2023/112431792/290753-20220707155544879-178987688.png"></p><p>02检查是否会有数据丢失</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpyGalss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>add delay to verilog models</title>
      <link href="/2023/112317390.html"/>
      <url>/2023/112317390.html</url>
      
        <content type="html"><![CDATA[<h2 id="verilog中的延迟模型"><a href="#verilog中的延迟模型" class="headerlink" title="verilog中的延迟模型"></a>verilog中的延迟模型</h2><h4 id="block-assignment（always）-“-”-阻塞赋值"><a href="#block-assignment（always）-“-”-阻塞赋值" class="headerlink" title="block assignment（always） “&#x3D;” 阻塞赋值"></a>block assignment（always） “&#x3D;” 阻塞赋值</h4><p>分为两种方式：LHS、RHS</p><ul><li>LHS</li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//LHS always @(a) // RHS</span>  <span class="token number">#5</span> y <span class="token operator">=</span> <span class="token operator">~</span>a<span class="token punctuation">;</span>  y <span class="token operator">=</span> <span class="token number">#5</span> <span class="token operator">~</span>a<span class="token punctuation">;</span></code></pre><img src="/2023/112317390/image-20231123170149369.png" alt="LHS in always" style="zoom: 67%;"><img src="/2023/112317390/image-20231123170340908.png" alt="always 阻塞 LHS" style="zoom: 67%;"><p>​总结：LHS是在第一次变量发生变化后，延迟12ns才进行真正的计算，如上图所示15ns后其他变量发生了变化，输出在统一在27ns时会使用最新的输入数据。<strong>相当于先延迟再计算。</strong>这里，b，ci的输入到输出，并没有经过12ns的延迟。</p><ul><li>RHS</li></ul><img src="/2023/112317390/image-20231123193908804.png" alt="always RHS 阻塞" style="zoom: 67%;"><p>​如果延迟12ns的期间，a，b，ci发生了变化，则输出不会体现出来。<strong>相当于先计算，再延迟。</strong></p><p>​在任何阻塞赋值的语句上，尽可能不使用这种形式。</p><h4 id="noblocking-assignment-（always）“"><a href="#noblocking-assignment-（always）“" class="headerlink" title="noblocking assignment （always）“&lt;&#x3D;” 非阻塞赋值"></a>noblocking assignment （always）“&lt;&#x3D;” 非阻塞赋值</h4><img src="/2023/112317390/image-20231123204725158.png" alt="Nonblocking Assignments with Delays" style="zoom:67%;"><ul><li>LHS</li></ul><p>​这种情况和阻塞赋值的”LHS”具有一样的问题。 </p><ul><li>RHS</li></ul><p>​<strong>这种是延迟组合逻辑的正确方式</strong></p><p>​<img src="/2023/112317390/image-20231123212135502.png" alt="always 非阻塞" style="zoom:67%;"></p><p>​<img src="/2023/112317390/image-20231123212223383.png" alt="always 非阻塞" style="zoom: 50%;"></p><p>​15ns时，a发生变化，在此后的12ns如果a，ci，b发生变化，则在27ns不会使用最新的数据，而是每个变化点后的12ns才发生改变。符合预期效果。</p><h4 id="Continuous-assignment"><a href="#Continuous-assignment" class="headerlink" title="Continuous assignment"></a>Continuous assignment</h4><img src="/2023/112317390/image-20231123213602068.png" alt="continous assignments" style="zoom:50%;"><p>​RHS delay，存在和always同样的问题，间隔小于12ns的任何输入变化都不会被检测到。</p><img src="/2023/112317390/image-20231123213721809.png" alt="assign '=' delay " style="zoom:50%;"><img src="/2023/112317390/image-20231123213918097.png" alt="assign delay wave" style="zoom: 50%;"><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>只有always块的RHS才可以准确描述组合逻辑的延迟。</strong></p>]]></content>
      
      
      <categories>
          
          <category> RTL仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTL延迟建模方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小谈case语句</title>
      <link href="/2023/112324934.html"/>
      <url>/2023/112324934.html</url>
      
        <content type="html"><![CDATA[<h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>​最近一直在写code，随着学习的深入，越来越想知道verilog 语法和对应的电路实现是什么样子的。</p><p>​首先，确定一点，完备的case，所有的分支都是并行的，且互斥，所以讨论有没有优先级是没有意义的，它对应的电路是一个MUX。（没有优先级）</p><pre class=" language-verilog"><code class="language-verilog">完备的<span class="token keyword">case</span>分支，等价于 <span class="token keyword">if</span> <span class="token keyword">else</span><span class="token operator">-</span><span class="token keyword">if</span> <span class="token keyword">else</span><span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><ul><li>缺省case</li></ul><p>​case的分支中，如果缺省，不进行其他操作，dc综合的时候<strong>会生成锁存器latch</strong></p><p>​这个时候如果添加原语 <strong>&#x2F;&#x2F;synopsys full_case</strong> ，目的是让综合器DC知道所有情况都已经列全了，不会生成latch。</p><ul><li><p>full case</p><p>每个可能的case expression的取值，都有与之相对应的分支。都列全了，即使没有default，也是full case</p><p>synopsys的dc_shell把full_case解释为：如果case不是full，对于没有出现的分支条件，输出就当成“不关心”处理，在综合的时候，对于没有出现的分支，会根据逻辑优化赋个常数。<strong>这样会导致前仿和后仿的结果不一致，所以需要注意这个地方</strong>，如果case中有default，case_full会被忽略。</p></li><li><p>parallel case</p><p>parallel case是指case expression只能匹配一个分支，不能出现一对多的情况。</p><p>告诉DC，所有条件都是互斥的，且都是并行，不存在优先级。</p><p>优先级只会存在于多对一的情况下。</p><p><strong>在仿真的时候出现了多对一的情况，会导致仿真执行有一定的优先级，这样就不是parallel case。如果针对这种情况dc时，加上parallel case，会综合出没有优先级的编码器。</strong></p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​当case 是full且是parallel的时候，综合出来的电路是没有优先级的MUX</p><p>​如果case不是full，又没有default，会综合出latch。</p>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高RTL仿真速度</title>
      <link href="/2023/11224275.html"/>
      <url>/2023/11224275.html</url>
      
        <content type="html"><![CDATA[<h2 id="如何提高仿真器的效率"><a href="#如何提高仿真器的效率" class="headerlink" title="如何提高仿真器的效率"></a>如何提高仿真器的效率</h2><p>了解仿真器的底层原理，合适的code style会节省仿真时间。</p><h4 id="仿真算法："><a href="#仿真算法：" class="headerlink" title="仿真算法："></a><strong>仿真算法：</strong></h4><ol><li><p>基于时间的（spice仿真器）</p><p>每个时间节点对所有元件都进行计算，效率低。</p></li><li><p>基于事件的（Verilog XL，NC verilog）</p><p>只有电路发生变化时，才进行处理。效率高。</p></li><li><p>基于周期的（Verilator ）</p><p>只在时钟边沿计算，不管时序，使用两值逻辑。仅适用于同步电路，效率高。比如CPU的仿真。</p></li></ol><p>​以下的测试都是基于Verilog-XL</p><ul><li><h4 id="case语句和多if-else-if语句"><a href="#case语句和多if-else-if语句" class="headerlink" title="case语句和多if else if语句"></a>case语句和多if else if语句</h4><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// case                         // if else-if                    </span><span class="token important">always @</span>（<span class="token operator">*</span>）<span class="token keyword">begin</span>                <span class="token important">always @</span>（<span class="token operator">*</span>）<span class="token keyword">begin</span>                    <span class="token function">case</span><span class="token punctuation">(</span>sel<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                  <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span>                     <span class="token number">2'b00</span><span class="token punctuation">:</span> out <span class="token operator">=</span> a<span class="token punctuation">;</span>                 out <span class="token operator">=</span> a<span class="token punctuation">;</span>                        <span class="token number">2'b01</span><span class="token punctuation">:</span> out <span class="token operator">=</span> b<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span>                     <span class="token number">2'b10</span><span class="token punctuation">:</span> out <span class="token operator">=</span> c<span class="token punctuation">;</span>                 out <span class="token operator">=</span> b<span class="token punctuation">;</span>                        <span class="token number">2'b11</span><span class="token punctuation">:</span> out <span class="token operator">=</span> d<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span>                     <span class="token keyword">default</span> <span class="token punctuation">:</span> out <span class="token operator">=</span> a<span class="token punctuation">;</span>              out <span class="token operator">=</span> c<span class="token punctuation">;</span>                    <span class="token keyword">endcase</span>                         <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b11</span><span class="token punctuation">)</span>             <span class="token keyword">end</span>                                     out <span class="token operator">=</span> d<span class="token punctuation">;</span>                                                   <span class="token keyword">end</span>      </code></pre><p>测试案例：8选1数据选择器，</p><p>仿真发现：基于case的多路选择器，CPU仿真时间更短。</p></li><li><h4 id="带有begin-end和不带begin-end"><a href="#带有begin-end和不带begin-end" class="headerlink" title="带有begin end和不带begin end"></a>带有begin end和不带begin end</h4><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span><span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span>    <span class="token keyword">else</span>  c <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span>    <span class="token function">if</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span>    <span class="token keyword">else</span>  c <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span></code></pre></li></ul><p>​测试结果：nobegin表述的内存利用率和仿真时间要优一些。</p><ul><li><h4 id="define-和-parameters"><a href="#define-和-parameters" class="headerlink" title="&#96;define 和 parameters"></a>&#96;define 和 parameters</h4><img src="/2023/11224275/define1.jpg" alt="define&amp;parameters"></li></ul><p>​parameters要更好一些。</p><ul><li><h4 id="always-group和nogroup"><a href="#always-group和nogroup" class="headerlink" title="always group和nogroup"></a>always group和nogroup</h4><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> <span class="token keyword">begin</span>        out1 <span class="token operator">&lt;=</span> a<span class="token punctuation">;</span>        out2 <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span>        out3 <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span>        out4 <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out1 <span class="token operator">&lt;=</span> a<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out2 <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out3 <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> out4 <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span></code></pre><p><img src="/2023/11224275/image-20231122100101428.png" alt="group&amp;nogroup"></p><p>group的仿真时间明显缩短了。</p></li><li><p>verilog可综合</p></li></ul><p>​左移，右移逻辑的操作数，可以是常数，也可以是变量，都是可以综合的，综合结果不一样。 常数的操作数，综合 出来是一个定值，变量的操作数综合出来是一个mux。</p><ul><li>DC时综合的原语</li></ul><pre class=" language-tcl"><code class="language-tcl"><span class="token operator">/</span><span class="token operator">/</span> synopsys translate_off忽略该部分的代码，DC时不会进行转移。<span class="token operator">/</span><span class="token operator">/</span> synopsys translate_on忽略的部分在前仿时是可以发挥作用的，如果错误使用translate_off on语句，会导致前仿和后仿的结果不一致。</code></pre><pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">// 小心使用translate off on</span>ex<span class="token punctuation">.</span>带两个异步复位信号的D触发器一般的实现方式如下：<span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst <span class="token keyword">or</span> <span class="token keyword">negedge</span> nset<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nset<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         q <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span>这种方式会导致前仿和后仿出现细微的区别。极端测试向量如下：如果nrst和nset同时拉低，则结果输出为<span class="token number">0</span><span class="token punctuation">.</span>经过半个周期后，nrst拉高了，输出结果依然为<span class="token number">0</span><span class="token punctuation">.</span>因为<span class="token important">always</span>块是边沿敏感触发的，但是nset和nrst都是异步的，nset此时为<span class="token number">0</span>，q输出结果应该为<span class="token number">1</span>；计算结果与实际电路不符。解决办法：    加入translate on off语句。配合<span class="token keyword">force</span> 和 relase正确code如下：<span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst <span class="token keyword">or</span> <span class="token keyword">negedge</span> nset<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nset<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// asyn</span>        q <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         q <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">// synopsys translate_off</span><span class="token important">always @</span><span class="token punctuation">(</span>nrst <span class="token keyword">or</span> nset<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>nrst <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nset<span class="token punctuation">)</span>   <span class="token keyword">force</span> q <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>                <span class="token keyword">release</span> q<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">// synopsys translate_on</span>该代码可以保证，在nrst撤离时，nset如果为<span class="token number">0</span>，q输出结果为<span class="token number">1</span>；这是在前仿时需要加入的特殊语句，并加上原语。在实际综合过程中，不会被综合。保证了前仿和实际流片的结果完全一致。在工艺库中，有时钟，异步复位和异步置数的端口，也就是说<span class="token important">always</span>块中的敏感列表，最多可以有三个。但是不能是同时<span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> clk。一个信号不能依赖两个边沿。</code></pre><ul><li><p>verilog调试</p><p>bg：verilog中的参数可以用 &#96;define和parameter指定，这种方式必须要求我们在编译前修改好，编译后就不能再修改了。但是为了节省编译时间，可以使用 $test$plusargs和$value$plusargs来指定。</p></li></ul><pre class=" language-verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps<span class="token keyword">module</span> tb<span class="token punctuation">;</span><span class="token keyword">reg</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> testname<span class="token punctuation">;</span><span class="token keyword">initial</span> <span class="token keyword">begin</span><span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"**********************RESULT IS BELOW*********************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">if</span><span class="token punctuation">(</span><span class="token property">$test</span><span class="token property">$plusargs</span><span class="token punctuation">(</span><span class="token string">"TAISHAN"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"****************TAISHAN is selected******************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"**********************$test$plusargs FAIL**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token property">$value</span><span class="token property">$plusargs</span><span class="token punctuation">(</span><span class="token string">"TESTNAME=%s"</span><span class="token punctuation">,</span> testname<span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">begin</span>  <span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"*****************Running test %0s.********************"</span><span class="token punctuation">,</span> testname<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token property">$display</span><span class="token punctuation">(</span><span class="token string">"**********************$value$plusargs FAIL**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token property">$finish</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span>使用方式：<span class="token number">1</span><span class="token punctuation">.</span>simv<span class="token number">2</span><span class="token punctuation">.</span>simv<span class="token operator">+</span>TATSHAN<span class="token number">3</span><span class="token punctuation">.</span>simv<span class="token operator">+</span>TAISHAN<span class="token operator">+</span>TESTNAME<span class="token operator">=</span>HUASHAN</code></pre><p>在仿真时，0时刻会执行一些系统函数，有些数据没有准备好，导致发生系统仿真错误，因此，可以在代码中初始化变量的值。</p><p><img src="/2023/11224275/image-20240203213035815.png"></p><p><img src="/2023/11224275/image-20240203213107944.png"></p>]]></content>
      
      
      <categories>
          
          <category> RTL仿真 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 仿真器底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
